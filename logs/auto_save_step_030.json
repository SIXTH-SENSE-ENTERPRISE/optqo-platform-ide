{
  "timestamp": "2025-07-21T20:08:26.634374",
  "total_messages": 60,
  "conversation": [
    {
      "role": "user",
      "content": "read and analyze the files in this directory /home/rishav/Documents/Code/6th-sense/Optqo_repo_function/repository. and in the end take all the findings and generate a comprehensive report in HTML and save it in an executable HTML file, then execute it to view"
    },
    {
      "role": "assistant",
      "content": "step: think\ncontent: |\n  I need to analyze the directory structure and files in `/home/rishav/Documents/Code/6th-sense/Optqo_repo_function/repository`. I'll start by exploring what's in this directory with the `ls` command.\n  \n  After I understand the directory structure, I'll examine the files to understand their content, purpose, and relationships. Based on this analysis, I'll create a comprehensive HTML report.\n  \n  Let me begin by listing the contents of the directory."
    },
    {
      "role": "user",
      "content": "Continue to the next step."
    },
    {
      "role": "assistant",
      "content": "step: action\ntool: executeCommand\ninput: ls -la /home/rishav/Documents/Code/6th-sense/Optqo_repo_function/repository"
    },
    {
      "role": "user",
      "content": "OBSERVE: stdout: total 12\ndrwxrwxr-x 3 rishav rishav 4096 Jul 20 16:55 .\ndrwxrwxr-x 7 rishav rishav 4096 Jul 21 14:07 ..\ndrwxrwxr-x 3 rishav rishav 4096 Jul 20 16:55 BSEProject\n\nstderr: "
    },
    {
      "role": "assistant",
      "content": "step: think\ncontent: |\n  I see there's a subdirectory called \"BSEProject\" in the repository. Let's explore this directory to understand its structure and content."
    },
    {
      "role": "user",
      "content": "Continue to the next step."
    },
    {
      "role": "assistant",
      "content": "step: action\ntool: executeCommand\ninput: ls -la /home/rishav/Documents/Code/6th-sense/Optqo_repo_function/repository/BSEProject"
    },
    {
      "role": "user",
      "content": "OBSERVE: stdout: total 428\ndrwxrwxr-x 3 rishav rishav   4096 Jul 20 16:55 .\ndrwxrwxr-x 3 rishav rishav   4096 Jul 20 16:55 ..\n-rw-rw-r-- 1 rishav rishav  11643 Jul 20 16:55 1st Part.sas\n-rw-rw-r-- 1 rishav rishav   6519 Jul 20 16:55 2ndQuery.txt\n-rw-rw-r-- 1 rishav rishav    154 Jul 20 16:55 3rdQuery.txt\n-rw-rw-r-- 1 rishav rishav   7282 Jul 20 16:55 4thQuery_part1.txt\n-rw-rw-r-- 1 rishav rishav   4788 Jul 20 16:55 4thQuery_part2.txt\n-rw-rw-r-- 1 rishav rishav   3267 Jul 20 16:55 4thQuery_part3.txt\n-rw-rw-r-- 1 rishav rishav  11391 Jul 20 16:55 4thQuery_part4.txt\n-rw-rw-r-- 1 rishav rishav   2551 Jul 20 16:55 4thQuery_part5.txt\n-rw-rw-r-- 1 rishav rishav   4858 Jul 20 16:55 4thQuery_part6.sql\n-rw-rw-r-- 1 rishav rishav  91287 Jul 20 16:55 4thQuery.txt\n-rw-rw-r-- 1 rishav rishav    316 Jul 20 16:55 5thQuery.txt\ndrwxrwxr-x 8 rishav rishav   4096 Jul 21 19:55 .git\n-rw-rw-r-- 1 rishav rishav  25096 Jul 20 16:55 JOB ASSIGN CLUSTER ID INCR_4.sql\n-rw-rw-r-- 1 rishav rishav  17929 Jul 20 16:55 JOB REJECT INVALID DATA INCR_2.sql\n-rw-rw-r-- 1 rishav rishav  63400 Jul 20 16:55 LOOP JOB STAND MATCHCODE INCR _3.sql\n-rw-rw-r-- 1 rishav rishav     12 Jul 20 16:55 README.md\n-rw-rw-r-- 1 rishav rishav 110008 Jul 20 16:55 SAS Code for Revised Insider Daily PAN.txt\n-rw-rw-r-- 1 rishav rishav  27648 Jul 20 16:55 SAS_Code_Understanding.xls\n\nstderr: "
    },
    {
      "role": "assistant",
      "content": "step: think\ncontent: |\n  Now I have a better understanding of the repository structure. The BSEProject directory contains various files with SQL queries, SAS code, and text files. It also has a .git directory, indicating it's a Git repository. Let me examine some of these files to understand their purpose and content.\n\n  I'll start by looking at the README.md file, as it might provide an overview of the project."
    },
    {
      "role": "user",
      "content": "Continue to the next step."
    },
    {
      "role": "assistant",
      "content": "step: action\ntool: fileManager\ninput: fileManager('read', '/home/rishav/Documents/Code/6th-sense/Optqo_repo_function/repository/BSEProject/README.md')"
    },
    {
      "role": "user",
      "content": "OBSERVE: File content (12 characters):\n# BSEProject"
    },
    {
      "role": "assistant",
      "content": "step: think\ncontent: |\n  The README.md file is very minimal, only containing the project name \"BSEProject\". It doesn't provide much information about the project's purpose or structure.\n\n  Let me check some of the key files to understand their content and purpose:\n  \n  1. First, let's look at the SAS code file \"1st Part.sas\" to understand what it does."
    },
    {
      "role": "user",
      "content": "Continue to the next step."
    },
    {
      "role": "assistant",
      "content": "step: action\ntool: fileManager\ninput: fileManager('read', '/home/rishav/Documents/Code/6th-sense/Optqo_repo_function/repository/BSEProject/1st Part.sas')"
    },
    {
      "role": "user",
      "content": "OBSERVE: File content (11643 characters):\nlibname tt '/SASDATA/DQ';\n\n%let todate = \"&date\"d;\n%let File2 = \"/home/sasdemo/bse_reports/IT&date\";\n\nproc sql;\n\n/*Distilling information from Announcement table and tagging the news type*/\n\n\tcreate table Annment (drop =issue dividends rights award offer bagging\n\t\t\t\t\t\t\t\tLarge acquisition expansion merger joint option\n\t\t\t\t\t\t\t\tupgraded employee approval insider profit Result\n\t\t\t\t\t\t\t\tLaunch split bonus MoU amalgamation partnership open\n\t\t\t\t\t\t\t\tsissue sdividends srights saward soffer sbagging AnnnouncementTag\n\t\t\t\t\t\t\t\tsLarge sacquisition sexpansion smerger sjoint soption\n\t\t\t\t\t\t\t\t\tsupgraded semployee sapproval sinsider sprofit sResult\n\t\t\t\t\t\t\t\t\tsLaunch ssplit sbonus sMoU samalgamation spartnership sopen) as \n\tselect distinct\n\tb.fld_scripcode as scripcd,\n\tb.FLD_COMPANYID as companyid,\n\ta.FLD_BODY as body,\n\tb.fld_longname,\n\tdatepart(a.FLD_AUTHORISEDATE) as anndate format = date9.,\n\tindexw(fld_body, 'issue') + indexw(fld_body, 'Issue') as issue,\n\tcase\n\t\twhen calculated issue > 0 then 'Issue-' \n\t\telse ''\n\tend as sIssue,\n\tindexw(fld_body, 'dividends') + indexw(fld_body, 'Dividends') + \n\tindexw(fld_body, 'dividend') + indexw(fld_body, 'Dividend') +\n\tindexw(fld_body, 'dividend.') + indexw(fld_body, 'Dividend.') + \n\tindexw(fld_body, \"dividend,\") + indexw(fld_body, 'Dividend,') as dividends,\n\tcase\n\t\twhen calculated dividends > 0 then 'dividends-' \n\t\telse ''\n\tend as sdividends,\n\tindexw(fld_body, 'rights') + indexw(fld_body, 'Rights') as rights,\n\tcase\n\t\twhen calculated rights > 0 then 'rights-' \n\t\telse ''\n\tend as srights,\n\tindexw(fld_body, 'award') + indexw(fld_body, 'Award') +\n\tindexw(fld_body, 'awards') + indexw(fld_body, 'Awards') +\n\tindexw(fld_body, 'awarded') + indexw(fld_body, 'Awarded') +\n\tindexw(fld_body, 'leader') + indexw(fld_body, 'Leader') +\n\tindexw(fld_body, 'leading') + indexw(fld_body, 'Leading') +\n\tindexw(fld_body, 'win' ) + indexw(fld_body, 'Win') + \n\tindexw(fld_body, 'winner' ) + indexw(fld_body, 'Winner') + \n\tindexw(fld_body, 'winners' ) + indexw(fld_body, 'Winners') + \n\tindexw(fld_body, 'won') + indexw(fld_body, 'Wins') + indexw(fld_body, 'wins') +\n\tindexw(fld_body, 'achieves' ) + indexw(fld_body, 'Achieves') +\n\tindexw(fld_body, 'prestigious' ) + indexw(fld_body, 'Prestigious')as award,\n\tcase\n\t\twhen calculated award > 0 then 'award-' \n\t\telse ''\n\tend as saward,\n\tindexw(fld_body, 'open') + indexw(fld_body, 'Open')\n\t+ indexw(fld_body, 'Open ') as open,\n\tcase\n\t\twhen calculated open > 0 then 'open-' \n\t\telse ''\n\tend as sopen,\n\tindexw(fld_body, 'Offer') + indexw(fld_body, 'offer') as offer,\n\tcase\n\t\twhen calculated offer > 0 then 'offer-' \n\t\telse ''\n\tend as soffer,\n\tindexw(fld_body, 'bagging') + indexw(fld_body, 'Bagging') +\n\tindexw(fld_body, 'bagged') + indexw(fld_body, 'Bagged') +\n\tindexw(fld_body, 'secured') + indexw(fld_body, 'Secured') +\n\tindexw(fld_body, 'received') + indexw(fld_body, 'Received') as bagging,\n\tcase\n\t\twhen calculated bagging > 0 then 'bagging-' \n\t\telse ''\n\tend as sbagging,\n\tindexw(fld_body, 'large') + indexw(fld_body, 'Large') as Large,\n\tcase\n\t\twhen calculated Large > 0 then 'Large-' \n\t\telse ''\n\tend as sLarge,\n\t/*indexw(fld_body, 'order') + indexw(fld_body, 'Large Order') */\n\t/*+ indexw(fld_body, 'Large order') as largeorder,*/\n\tindexw(fld_body, 'acquisition') + indexw(fld_body, 'Acquisition') + \n\tindexw(fld_body, 'acquired') + indexw(fld_body, 'Acquired') +\n\tindexw(fld_body, 'acquirer') + indexw(fld_body, 'Acquirer') + \n\tindexw(fld_body, 'acquire') + indexw(fld_body, 'Acquire') + \n\tindexw(fld_body, 'acquires') + indexw(fld_body, 'Acquires')as acquisition,\n\tcase\n\t\twhen calculated acquisition > 0 then 'acquisition-' \n\t\telse ''\n\tend as sacquisition,\n\tindexw(fld_body, 'expand') + indexw(fld_body, 'Expand') +\n\tindexw(fld_body, 'expands') + indexw(fld_body, 'Expands') +\n\tindexw(fld_body, 'expansion') + indexw(fld_body, 'Expansion') +\n\tindexw(fld_body, 'inaugurate') + indexw(fld_body, 'Inaugurate') +\n\tindexw(fld_body, 'inaugurates') + indexw(fld_body, 'Inaugurates') as expansion, \n\tcase\n\t\twhen calculated expansion > 0 then 'expansion-' \n\t\telse ''\n\tend as sexpansion,\n\tindexw(fld_body, 'merger') + indexw(fld_body, 'Merger') as merger,\n\tcase\n\t\twhen calculated merger > 0 then 'merger-' \n\t\telse ''\n\tend as smerger,\n\tindexw(fld_body, 'Joint') + indexw(fld_body, 'joint') +\n\tindexw(fld_body, 'Jointly') + indexw(fld_body, 'jointly') as joint,\n\tcase\n\t\twhen calculated joint > 0 then 'joint-' \n\t\telse ''\n\tend as sjoint,\n\tindexw(fld_body, 'partnership') + indexw(fld_body, 'Partnership') +\n\tindexw(fld_body, 'partner') + indexw(fld_body, 'Partner') as partnership,\n\tcase\n\t\twhen calculated partnership > 0 then 'partnership-' \n\t\telse ''\n\tend as spartnership,\n\tindexw(fld_body, 'amalgamation') + indexw(fld_body, 'Amalgamation') as amalgamation,\n\tcase\n\t\twhen calculated amalgamation > 0 then 'amalgamation-' \n\t\telse ''\n\tend as samalgamation,\n\tindexw(fld_body, 'MoU') as MoU,\n\tcase\n\t\twhen calculated MoU > 0 then 'MoU-' \n\t\telse ''\n\tend as sMoU,\n\tindexw(fld_body, 'bonus') + indexw(fld_body, 'Bonus')as bonus,\n\tcase\n\t\twhen calculated bonus > 0 then 'bonus-' \n\t\telse ''\n\tend as sbonus,\n\tindexw(fld_body, 'split' ) + indexw(fld_body, 'Split') as split,\n\tcase\n\t\twhen calculated split > 0 then 'split-' \n\t\telse ''\n\tend as ssplit,\n\tindexw(fld_body, 'launch' ) + indexw(fld_body, 'Launch')  + \n\tindexw(fld_body, 'launched' ) + indexw(fld_body, 'Launched')  + \n\tindexw(fld_body, 'introduce' ) + indexw(fld_body, 'Introduce') +\n\tindexw(fld_body, 'introduced' ) + indexw(fld_body, 'Introduced') as Launch,\n\tcase\n\t\twhen calculated Launch > 0 then 'Launch-' \n\t\telse ''\n\tend as sLaunch,\n\tindexw(fld_body, 'result') + indexw(fld_body, 'Result') +\n\tindexw(fld_body, 'results') + indexw(fld_body, 'Results') +\n\tindexw(fld_body, 'results,') + indexw(fld_body, 'Results,') +\n\tindexw(fld_body, 'results\"') + indexw(fld_body, 'Results\"') +\n\tindexw(fld_body, 'income') + indexw(fld_body, 'Income') +\n\tindexw(fld_body, 'earnings') + indexw(fld_body, 'Earnings') +\n\tindexw(fld_body, 'quarter') + indexw(fld_body, 'Quarter') +\n\tindexw(fld_body, 'Q2') + indexw(fld_body, 'Q1') +\n\tindexw(fld_body, 'Q4') + indexw(fld_body, 'Q3') + indexw(fld_body, 'FY') +\n\tindexw(fld_body, 'sales') + indexw(fld_body, 'Sales') +\n\tindexw(fld_body, 'revenues') + indexw(fld_body, 'Revenues') +\n\tindexw(fld_body, 'revenue') + indexw(fld_body, 'Revenue') +\n\tindexw(fld_body, 'results\".') + indexw(fld_body, 'Results\".') +\n\tindexw(fld_body, '\"results') + indexw(fld_body, 'Results') as Result,\n\tcase\n\t\twhen calculated Result > 0 then 'Result-' \n\t\telse ''\n\tend as sResult,\n\tindexw(fld_body, 'Profit') + indexw(fld_body, 'profit') +\n\tindexw(fld_body, 'Profits') + indexw(fld_body, 'profits') as profit,\n\tcase\n\t\twhen calculated profit > 0 then 'profit-' \n\t\telse ''\n\tend as sprofit,\n\tindexw(fld_body, 'Insider') + indexw(fld_body, 'insider') as insider,\n\tcase\n\t\twhen calculated insider > 0 then 'insider-' \n\t\telse ''\n\tend as sinsider,\n\tindexw(fld_body, 'Approval') + indexw(fld_body, 'approval') +\n\tindexw(fld_body, 'Approving') + indexw(fld_body, 'approving') +\n\tindexw(fld_body, 'Approved') + indexw(fld_body, 'approved') +\n\tindexw(fld_body, 'Approves') + indexw(fld_body, 'approves') as approval,\n\tcase\n\t\twhen calculated approval > 0 then 'approval-' \n\t\telse ''\n\tend as sapproval,\n\tindexw(fld_body, 'Employees') + indexw(fld_body, 'Employee') +\n\tindexw(fld_body, 'employees') + indexw(fld_body, 'employee') +\n\tindexw(fld_body, \"employees.\") + indexw(fld_body, 'employee.') as employee,\n\tcase\n\t\twhen calculated employee > 0 then 'employee-' \n\t\telse ''\n\tend as semployee,\n\tindexw(fld_body, 'upgraded') + indexw(fld_body, 'Upgraded') +\n\tindexw(fld_body, 'Increase') + indexw(fld_body, 'Increase') as upgraded,\n\tcase\n\t\twhen calculated upgraded > 0 then 'upgraded-' \n\t\telse ''\n\tend as supgraded,\n\tindexw(fld_body, 'option') + indexw(fld_body, 'Option') +\n\tindexw(fld_body, 'options') + indexw(fld_body, 'Options') as option,\n\tcase\n\t\twhen calculated option > 0 then 'option-' \n\t\telse ''\n\tend as soption,\n\t(trimn(calculated Sissue) || trimn(calculated Sdividends) || trimn(calculated Srights) || \n\ttrimn(calculated Saward) || trimn(calculated Soffer) || trimn(calculated Sbagging)|| \n\ttrimn(calculated SLarge) || trimn(calculated Sacquisition) || trimn(calculated Sexpansion) || \n\ttrimn(calculated Smerger) || trimn(calculated Sjoint) || trimn(calculated Soption)|| \n\ttrimn(calculated Supgraded) || trimn(calculated Semployee) || trimn(calculated Sapproval) || \n\ttrimn(calculated Sinsider) || trimn(calculated Sprofit) || trimn(calculated SResult)|| \n\ttrimn(calculated SLaunch) || trimn(calculated Ssplit) || trimn(calculated Sbonus) || \n\ttrimn(calculated SMoU) || trimn(calculated Samalgamation) || trimn(calculated Spartnership) || \n\ttrimn(calculated Sopen)) as NetBody,\n\tcase\n\t\twhen calculated issue > 0 then 'issue'\t\n\t\twhen calculated dividends > 0 then 'dividends'\t\n\t\twhen calculated rights > 0 then 'rights'\n\t\twhen calculated award > 0 then 'award'\n\t\twhen calculated open > 0 then 'open'\n\t\twhen calculated offer > 0 then 'offer'\n\t\twhen calculated bagging > 0 then 'bagging'\n\t\twhen calculated large > 0 then 'large'\n\t/*\twhen calculated largeorder > 0 then 'large order'*/\n\t\twhen calculated acquisition > 0 then 'acquisition'\n\t\twhen calculated merger > 0 then 'merger'\n\t\twhen calculated amalgamation > 0 then 'amalgamation'\n\t\twhen calculated MoU > 0 then 'MoU'\n\t\twhen calculated bonus > 0 then 'bonus'\n\t\twhen calculated split > 0 then 'stock split'\n\t/*\twhen calculated win > 0 then 'win'*/\n\t\twhen calculated launch > 0 then 'launch'\n\t\twhen calculated result > 0 then 'results'\n\t\twhen calculated Insider > 0 then 'insider'\n\t\twhen calculated approval > 0 then 'approval'\n\t\twhen calculated partnership > 0 then 'partnership'\n\t\twhen calculated joint > 0 then 'joint'\n\t\twhen calculated profit > 0 then 'profit'\n\t\twhen calculated expansion > 0 then 'expansion'\n\t\twhen calculated Employee > 0 and calculated option > 0  then 'employee stock option'\n\t\twhen calculated upgraded > 0 then 'upgraded'\n\t\telse \"\"\n\tend as AnnnouncementTag,\n\tcase\n\t\twhen calculated AnnnouncementTag in ('MoU',\t'approval',\t'award',\t'bagging',\t'bonus',\t\n\t\t\t\t\t\t\t\t\t\t\t'dividends', 'expansion', 'issue',\t'joint', 'large',\t\n\t\t\t\t\t\t\t\t\t\t\t'launch', 'offer',\t'open',\t'profit',\t'rights',\t\n\t\t\t\t\t\t\t\t\t\t\t'stock split',\t'upgraded') \n\t\tthen 'Af'\n\t\twhen calculated AnnnouncementTag in ('results', 'merger', \t'acquisition', 'amalgamation', \n\t\t\t\t\t\t\t\t\t\t\t'partnership')\n\t\tThen 'Bb'\n\t\t\t\twhen calculated AnnnouncementTag in ('insider', 'employee stock option')\n\t\tThen 'Cu'\n\t\telse 'Dn'\n\tend as Fav_Unfav\n\tfrom tt.COMPANY_ANNOUNCEMENT_DATA a left outer join tt.COMPANY_SCRIP_MASTER b\n\ton a.fld_companyid = b.fld_companyid\n\twhere fld_critical = 1 and calculated anndate =  &todate;\n\t/*and calculated AnnnouncementTag is null*/\n\n\n\tcreate table Annment&date.temp as\n\tselect distinct\n\tscripcd,\n\tcompanyid,\n\tFLD_LONGNAME,\n\tanndate,\n\tmin(Fav_Unfav) as Fav_Unfav\n\tfrom Annment\n\twhere scripcd > 0\n\tgroup by scripcd, companyid, FLD_LONGNAME, anndate;\n\n\tcreate table Annment&date as \n\tselect distinct\n\tMONOTONIC() AS RowNum FORMAT=COMMA6.,\n\t*\n\tfrom Annment&date.temp\n\torder by rownum asc;\nquit;\n\nproc sql;\n\n\tCREATE table Datetab&date.1 (\n\t\tscripcd num,\n\t\tCompanyName char(50),\n\t\tcompanyid num,\n\t\tAnndate num,\n\t\tEPFirst num,\n\t\tEPLast num,\n\t\tAPFirst num,\n\t\tAPLast num,\n\t\tvarratio num,\n\t\tMaxRate num,\n\t\tminrate num,\n\t\tPriceVariation num,\n\t\tSelection char(25),\n\t\tFav_Unfav char(3),\n\t\tAvgVol num,\n\t\tRateFilter num);\n\n\n\t\t\n\t\t--- Create a variable for this count.\n\t\n\t\t---\n\t\t--A = load Annment&date;\n\t\t--B = foreach a generate *, 1 as grpClm;\n\t\t--C = group B by grpClm;\n\t\t--maxrow = COUNT_STAR(C)\n\t\t--dump D; \n\t\t---\n\t\t\n\t\tproc sql noprint;\n\t\tselect count(*) \n\t\tinto :maxrow\n\t\tfrom Annment&date;\n\nquit;\n"
    },
    {
      "role": "assistant",
      "content": "step: think\ncontent: |\n  I've examined the first SAS script file. It appears to be a data processing script that:\n  \n  1. Sets up a SAS library named \"tt\" pointing to \"/SASDATA/DQ\"\n  2. Processes announcement data from what appears to be a BSE (Bombay Stock Exchange) dataset\n  3. Analyzes announcements by scanning for specific keywords like \"dividend,\" \"merger,\" \"acquisition,\" etc.\n  4. Classifies announcements into categories based on these keywords\n  5. Creates tables to store the processed data\n  \n  This suggests this project is related to financial data analysis, specifically focused on company announcements from the Bombay Stock Exchange.\n  \n  Let me now look at one of the SQL files to understand what database operations are being performed."
    },
    {
      "role": "user",
      "content": "Continue to the next step."
    },
    {
      "role": "assistant",
      "content": "step: action\ntool: fileManager\ninput: fileManager('read', '/home/rishav/Documents/Code/6th-sense/Optqo_repo_function/repository/BSEProject/JOB ASSIGN CLUSTER ID INCR_4.sql')"
    },
    {
      "role": "user",
      "content": "OBSERVE: File content (25096 characters):\n/****************************************************************************** \n * Job:             4 JOB ASSIGN CLUSTER ID INCR            A5HHMQXQ.BB00001U * \n * Description:                                                               * \n *                                                                            * \n * Metadata Server: 192.168.253.166                                           * \n * Port:            8561                                                      * \n * Location:        /SASDIR/FINAL/INCR_JOBS                                   * \n *                                                                            * \n * Server:          SASApp                                  A5HHMQXQ.AR000002 * \n *                                                                            * \n * Generated on:    Thursday, January 30, 2014 12:13:29 PM GMT+05:30          * \n * Generated by:    sasdemo                                                   * \n * Version:         SAS Data Integration Studio 4.21                          * \n ******************************************************************************/ \n\n/* General macro variables  */ \n%let jobID = %quote(A5HHMQXQ.BB00001U);\n%let etls_jobName = %nrquote(4 JOB ASSIGN CLUSTER ID INCR);\n%let etls_userID = %nrquote(sasdemo);\n\n/* Setup to capture return codes  */ \n%global job_rc trans_rc sqlrc; \n%let sysrc = 0;\n%let job_rc = 0;\n%let trans_rc = 0;\n%let sqlrc = 0;\n%global etls_stepStartTime; \n/* initialize syserr to 0 */\ndata _null_; run;\n\n%macro rcSet(error); \n   %if (&error gt &trans_rc) %then \n      %let trans_rc = &error;\n   %if (&error gt &job_rc) %then \n      %let job_rc = &error;\n%mend rcSet; \n\n%macro rcSetDS(error); \n   if &error gt input(symget('trans_rc'),12.) then \n      call symput('trans_rc',trim(left(put(&error,12.))));\n   if &error gt input(symget('job_rc'),12.) then \n      call symput('job_rc',trim(left(put(&error,12.))));\n%mend rcSetDS; \n\n/* Create metadata macro variables */\n%let IOMServer      = %nrquote(SASApp);\n%let metaPort       = %nrquote(8561);\n%let metaServer     = %nrquote(192.168.253.166);\n\n/* Set metadata options */\noptions metaport       = &metaPort \n        metaserver     = \"&metaServer\"; \n\n/* Setup for capturing job status  */ \n%let etls_startTime = %sysfunc(datetime(),datetime.);\n%let etls_recordsBefore = 0;\n%let etls_recordsAfter = 0;\n%let etls_lib = 0;\n%let etls_table = 0;\n\n%global etls_debug; \n%macro etls_setDebug; \n   %if %str(&etls_debug) ne 0 %then \n      OPTIONS MPRINT%str(;); \n%mend; \n%etls_setDebug; \n\n/*---- Start of Pre-Process Code  ----*/ \n\n/*---- Start of User Written Code  ----*/ \n\n\n/* Count of dedupe match codes */\n%let mc_cnt=2;\n\n/* Parameters for clustring user written code */\n%let opdsn=saslib.CLUSTERED_OUTPUT;\n%let seq_dsn_temp=work.CLUSTER_ID_GEN_TEMP;\n%let seq_dsn=saslib.CLUSTER_ID_GENERATOR;\n%let seq_col=CLUSTER_ID_SEQ;\n%let cl_id_col=CLUSTER_ID;\n%let by_col_1=DEDUPE_MATCH_CODE_1;\n%let by_col_2=DEDUPE_MATCH_CODE_2;\n/*%let by_col_3=DEDUPE_MATCH_CODE_3;*/\n/*%let by_col_4=DEDUPE_MATCH_CODE_4;*/\n\n/*%let by_col_5=DEDUPE_MATCH_CODE_5;*/\n/*%let by_col_6=DEDUPE_MATCH_CODE_6;*/\n\n\n\n/* This macro checks if the table SASLIB.Sas_Update_Date exists. \n\tIf no, then it creates one in the DataMart library\t*/\n\n%macro Update_Date();\n\n/* Determine if the SAS_UPDATE_DATE table exists  */ \n%let upd_tbl_Exist = %sysfunc(exist(saslib.SAS_UPDATE_DATE, DATA));\n   \n/*---- Create table  ----*/ \n%if (&upd_tbl_Exist eq 0) %then \n%do;  /* if the table does not exist  */ \n\n\t%put %str(NOTE: Creating table ...);\n\n\tPROC SQL;\n\tCREATE TABLE saslib.SAS_UPDATE_DATE (TABLE_NAME VARCHAR(25), LAST_UPDATE_DATE DATE);\n\tQUIT;\n\t\t\n\t\tproc sql noprint;\n\n\t\t\tinsert into saslib.Sas_Update_Date(Table_Name,Last_Update_Date)\n\t\t\tvalues ('SAS_DIM_DEDUPE',0);\n\t\tquit;\n\t\t\n\t%end; /* if the table does not exist  */\n\n%mend Update_Date;\n\n\n/* Call the macro Update_Date */\n\n%Update_Date;\n\t\t\t\ndata saslib.new_old_cluster_id_xref;\t\nset saslib.new_old_cluster_id_xref(obs=0);\t\nOutput;\nRun;\n\n\n\n/*---- End of User Written Code  ----*/\n/*---- End of Pre-Process Code  ----*/ \n\n%rcSet(&syserr); \n%rcSet(&sqlrc); \n\n/*---- Start of User Written Code  ----*/ \n\n/*============================================================================* \n * Step:          User Written Code                         A5VKCMXH.AR0001L1 * \n * Transform:     User Written Code                                           * \n * Description:                                                               * \n *                                                                            * \n * Source Table:  Extract Target - work.W5P7Z7MJ            A5VKCMXH.AU0001KS * \n * Target Table:  User Written Code Target -                A5VKCMXH.AU0001KQ * \n *                 svoclib.CLUSTERED_OUTPUT                                   * \n *                                                                            * \n * User Written:  UWC_CLUSTER_ID_ASSIGN                     A5VKCMXH.A90002O3 * \n *============================================================================*/ \n\n%let SYSLAST = %nrquote(saslib.SAS_DIM_DEDUPE); \n/*%let SYSLAST = %nrquote(saslib.test_cluster_input2); */\n\n%let transformID = %quote(A5VKCMXH.AR0001L1); \n\n%let trans_rc = 0; \n\n%let _OUTPUT = %nrquote(saslib.CLUSTERED_OUTPUT); \n\n\n/*---- Start of User Written Code  ----*/ \n\n%let ipdsn=&syslast;\n\n%macro Cluster_Assigner(ipdsn, opdsn, seq_dsn_temp, seq_col, cl_id_col, by_col_1);\n\n/* Determine if the sequence table exists  */ \n%let seq_tbl_Exist = %sysfunc(exist(&seq_dsn_temp, DATA));\n   \n/*---- Create a new sequence table  ----*/ \n%if (&seq_tbl_Exist eq 0) %then \n%do;  /* if the sequence table does not exist  */ \n\n\t%put %str(NOTE: Creating table ...);\n\n\tdata &seq_dsn_temp;\n\t\tattrib &seq_col length = 8 format = Best12.;\n\t\t&seq_col=0;\n\trun;\n\n%end; /* if the sequence table does not exist  */\n\n/* Step 1: Separate the input data set into two output data sets. One having missing DMC_1 and \n\tother having valid DMC_1 */\n\ndata inp_cluster_dmc_1_nl (COMPRESS=YES) inp_cluster_dmc_1_nnl (COMPRESS=YES);\n\tattrib cluster_id_old length=8. format=Best12.;\n\tset &ipdsn (keep = SAS_ID CLUSTER_ID DEDUPE_MATCH_CODE_1 DEDUPE_MATCH_CODE_2 \n\t\t\t\t\t\t\t DEDUPE_MATCH_CODE_3 DEDUPE_MATCH_CODE_4 DEDUPE_MATCH_CODE_5 DEDUPE_MATCH_CODE_6 \n\t\t\t\t\t\t\t DMC_1_FLAG DMC_2_FLAG DMC_3_FLAG DMC_4_FLAG DMC_5_FLAG DMC_6_FLAG BROKERCODE CLIENTCODE);\n\tsas_id = CATX('!',PUT(BROKERCODE,11.),CLIENTCODE);\n\tcluster_id_old = cluster_id;\n\tcluster_id = .;\n\tif dmc_1_flag eq 0 then\n\t\toutput inp_cluster_dmc_1_nnl;\n\telse\n\t\toutput inp_cluster_dmc_1_nl;\nrun;\n\n/* Step 2: Sort the data set/view created in the last transformation */\n\nproc sort data=inp_cluster_dmc_1_nnl out=inp_cluster_dmc_1_nnl_srt (COMPRESS=YES) noequals;\n\tby &by_col_1;\nrun;\n\n/* Get the last value of sequence number stored in the sequence generator table */\n\nproc sql noprint;\n   select &seq_col into :var_seq\n\tfrom &seq_dsn_temp;\nquit;\n\n%rcSet(&sqlrc);\n\n/* Step 3A: Assign cluster ids to clusters identified by grouping match code column for records\n\twhich have not null DMC_1 match codes */\n\ndata out_cluster_dmc_1_nnl (COMPRESS=YES);\n\tset inp_cluster_dmc_1_nnl_srt (sortedby=&by_col_1);\n\tby &by_col_1;\t/*This Line Does the Gouping @Yug */\n\t&cl_id_col=symgetn('var_seq');\t\n\tif first.&by_col_1 then do;\n\t\t&cl_id_col = &cl_id_col+1;\n\t\tcall symput('var_seq',&cl_id_col);\n\tend;\nrun;\n\n/* Step 3B: Assign unique cluster ids to records with missing DMC_1 match codes */\n\ndata out_cluster_dmc_1_nl (COMPRESS=YES);\n\tset inp_cluster_dmc_1_nl;\n\t&cl_id_col=symgetn('var_seq');\n\t&cl_id_col = &cl_id_col+1;\n\tcall symput('var_seq',&cl_id_col);\nrun;\n\n/*  Store the last generated value of the sequence in the sequence generator table */\n\nproc sql;\n\tupdate &seq_dsn_temp\n\tset &seq_col = &var_seq;\nquit;\n\n%rcSet(&sqlrc);\n\n/* Step 4: Append the clustering results achieved using DMC_1 match code into one data set */\n\ndata CLUSTER_DMC_1_FINAL (COMPRESS=YES);\n\tdrop &by_col_1;\n\tattrib var_CLUSTER_id length=8. format=Best12.;\n\tset out_cluster_dmc_1_nnl\n\t\t out_cluster_dmc_1_nl;\n\tvar_CLUSTER_id=CLUSTER_id;\nrun;\n\n%mend Cluster_Assigner;\n\n/* Call the clustering macro */\n\n%Cluster_Assigner(&ipdsn, &opdsn, &seq_dsn_temp, &seq_col, &cl_id_col, &by_col_1);\n\n%rcSet(&syserr); \n\n/* Delete temp data sets created in step # 1 */\n\nproc datasets lib=work nolist nowarn memtype=(data);\n   delete inp_cluster_dmc_1_nl inp_cluster_dmc_1_nnl inp_cluster_dmc_1_nnl_srt \n\t\t\t out_cluster_dmc_1_nnl out_cluster_dmc_1_nl;\nquit;\n\n\n/*----------------- Macro to do OR-ing between match codes 2 to n ----------------- */\n\n%macro match_code_oring();\n\n%do seq = 2 %to &mc_cnt;\n\n%let prev_seq = %eval(&seq-1);\n\n%put %str(NOTE: Begin OR-ing with match code # &seq);\n\n/*-------------------- OR-ing with match code (Begin) ----------------------------- */\n\n/* Creating view to act as an input to the hash object in memory */\n\nproc sql noprint;\ncreate view cluster_dmc_&seq._hash as\nselect dedupe_match_code_&seq as dmc_&seq._key, var_CLUSTER_id as CLUSTER_id_data/***/\nfrom cluster_dmc_&prev_seq._final\nwhere dmc_&seq._flag eq 0; /*------ Modified by Yugesh, since 0 without quotes was not working since match_code_flag were character fields------------ */\nquit;\n\n%rcSet(&sqlrc);\n\n/* Create a cross-reference of CLUSTER_IDs w.r.t match code */\n\ndata inp_cluster_dmc_&seq (COMPRESS=YES);\n\t\n\tdrop var_CLUSTER_id CLUSTER_id_data dmc_&seq._key dedupe_match_code_&seq rc;\n\n\tattrib CLUSTER_id length=8. format=Best12.;\n\tattrib CLUSTER_id_&seq length=8. format=Best12.;\n\tattrib CLUSTER_id_data length=8. format=Best12.;\n\tattrib dmc_&seq._key length=$200.; /* Modify to suit the length of individual match code field */\n\n\tretain CLUSTER_id_&seq;\n\n\tset cluster_dmc_&prev_seq._final;\n\n   if _N_ = 1 then \n\tdo;\n\n\t\tdeclare hash myhash(hashexp: 20, dataset: \"cluster_dmc_&seq._hash\");\n      myhash.defineKey(\"dmc_&seq._key\");\n      myhash.defineData('CLUSTER_id_data');\n\t\tmyhash.defineDone(); \n\n%put %str(NOTE: Post Hash);\n\n\t\tcall missing(dmc_&seq._key, CLUSTER_id_data);\n\n\tend;\n\n\tCLUSTER_id = var_CLUSTER_id;\n\n\tdmc_&seq._key = dedupe_match_code_&seq;\n\n\trc = myhash.find();\n\n\tif (rc = 0) then\n\t\tdo;\n\t\t\tCLUSTER_id_&seq = CLUSTER_id_data;\n\t\tend;\t\n\telse\n\t\tdo;\n\t\t\tCLUSTER_id_&seq = var_CLUSTER_id;\n\t\tend;\n\nrun;\n\n%rcSet(&syserr); \n\n/* sorting the inp_cluster dataset against CLUSTER_id field */\n\nproc sort data=inp_cluster_dmc_&seq;\n\tby CLUSTER_id;\nrun;\n\n%rcSet(&syserr); \n\n/* create a view to act as a input for hash */\n\ndata inp_cluster_temp_&seq / view=inp_cluster_temp_&seq ;\n \tattrib CLUSTER_id_key length=8. format=Best12.;\n \tattrib CLUSTER_id_data length=8. format=Best12.;\n\tkeep CLUSTER_id_key CLUSTER_id_data;\n\tretain CLUSTER_id_data;\n\tset inp_cluster_dmc_&seq (sortedby=CLUSTER_id);\n\tby CLUSTER_id;\n\tif (last.CLUSTER_id ne 1) then\n\t\tdo;\n\t\t\tif (CLUSTER_id ne CLUSTER_id_&seq) & (CLUSTER_id_data eq .) then\n\t\t\tdo;\n\t\t\t\tCLUSTER_id_data = CLUSTER_id_&seq;\n\t\t\tend;\n\t\tend;\n\t\n\tif (CLUSTER_id ne CLUSTER_id_&seq) then\n\t\tdo;\n\t\t\tCLUSTER_id_key = CLUSTER_id_&seq;\n\t\tend;\n\t\t\n\tif (CLUSTER_id_key ne .) & (CLUSTER_id_data ne .) & (CLUSTER_id_key ne CLUSTER_id_data) then\n\t\tdo;\n\t\t\toutput;\n\t\tend;\n\t\n\tif last.CLUSTER_id then\n\tdo;\n\t\tCLUSTER_id_data =.;\n\tend; \nrun;\n\n%rcSet(&syserr); \n\n/* This step will rectify instances of one old CLUSTER_id having multiple new CLUSTER_id linkages */\n\ndata cluster_dmc_&seq._temp (COMPRESS=YES);\n\tdrop CLUSTER_id_key CLUSTER_id_data rc;\n \tattrib CLUSTER_id_key length=8. format=Best12.;\n \tattrib CLUSTER_id_data length=8. format=Best12.;\n   if _N_ = 1 then \n\tdo;\n\t\tdeclare hash myhash(hashexp: 13, dataset: \"inp_cluster_temp_&seq\");\n      myhash.defineKey('CLUSTER_id_key');\n      myhash.defineData('CLUSTER_id_data');\n      myhash.defineDone();\n\t\tcall missing(CLUSTER_id_key, CLUSTER_id_data);\n\tend;\n\tset inp_cluster_dmc_&seq;\n\tCLUSTER_id_key=CLUSTER_id_&seq;\n\trc = myhash.find();\n\tif (rc = 0) then\n\tdo;\n\t\tCLUSTER_id_&seq = CLUSTER_id_data;\n\tend;\nrun;\n\n%rcSet(&syserr); \n\n/* Creating view1 to act as an input to the hash object in memory */\n\nproc sql noprint;\n create view inp_cluster_dmc_&seq._v as\n\tselect CLUSTER_id as CLUSTER_id_key, CLUSTER_id_&seq as CLUSTER_id_data \n\tfrom cluster_dmc_&seq._temp\n\twhere CLUSTER_id <> CLUSTER_id_&seq;\nquit;\n\n%rcSet(&sqlrc);\n\n/* Creating view2 to act as an input to the hash object in memory */\n\ndata cluster_temp_&seq._v / view=cluster_temp_&seq._v;\n \tattrib CLUSTER_id_key_2 length=8. format=Best12.;\n \tattrib CLUSTER_id_data_2 length=8. format=Best12.;\n\tkeep CLUSTER_id_key_2 CLUSTER_id_data_2;\n\tretain CLUSTER_id_data_2;\n\tset cluster_dmc_&seq._temp (sortedby=CLUSTER_id);\n\tby CLUSTER_id;\n\tif (last.CLUSTER_id ne 1) then\n\t\tdo;\n\t\t\tif (CLUSTER_id ne CLUSTER_id_&seq) & (CLUSTER_id_data_2 eq .) then\n\t\t\tdo;\n\t\t\t\tCLUSTER_id_data_2 = CLUSTER_id_&seq;\n\t\t\tend;\n\t\tend;\n\t\n\tif (CLUSTER_id ne CLUSTER_id_&seq) then\n\t\tdo;\n\t\t\tCLUSTER_id_key_2 = CLUSTER_id_&seq;\n\t\tend;\n\t\t\n\tif (CLUSTER_id_key_2 ne .) & (CLUSTER_id_data_2 ne .) & (CLUSTER_id_key_2 ne CLUSTER_id_data_2) then\n\t\tdo;\n\t\t\toutput;\n\t\tend;\n\t\n\tif last.CLUSTER_id then\n\tdo;\n\t\tCLUSTER_id_data_2 =.;\n\tend;\nrun;\n\n/* Re-aligning CLUSTER_IDs for 'n' level of recursive CLUSTER_ID linkage */\n\ndata cluster_dmc_&seq._final (COMPRESS=YES);\n\n\tdrop CLUSTER_id CLUSTER_id_&seq CLUSTER_id_key CLUSTER_id_data CLUSTER_id_key_2 \n\t\t  CLUSTER_id_data_2 s_CLUSTER_id s_var_CLUSTER_id rc rc2 rc3 rc4 rc5;\n\n \tattrib var_CLUSTER_id length=8. format=Best12.;\n \tattrib CLUSTER_id_key length=8. format=Best12.;\n \tattrib CLUSTER_id_data length=8. format=Best12.;\n\tattrib s_CLUSTER_id length=8. format=Best12.;\n\tattrib s_var_CLUSTER_id length=8. format=Best12.;\n \tattrib CLUSTER_id_key_2 length=8. format=Best12.;\n \tattrib CLUSTER_id_data_2 length=8. format=Best12.;\t\n\n   if _N_ = 1 then \n\tdo;\n\t\tdeclare hash myhash(hashexp: 13, dataset: \"inp_cluster_dmc_&seq._v\");\n      myhash.defineKey('CLUSTER_id_key');\n      myhash.defineData('CLUSTER_id_data');\n      myhash.defineDone();\n\t\tcall missing(CLUSTER_id_key, CLUSTER_id_data);\n\n\t\tdeclare hash s_hash(hashexp: 13);\n\t\ts_hash.defineKey(\"s_CLUSTER_id\");\n\t\ts_hash.defineData(\"s_var_CLUSTER_id\");\n\t\ts_hash.defineDone();\n\t\tcall missing(s_CLUSTER_id, s_var_CLUSTER_id);\n\n\t\tdeclare hash hash2(hashexp: 13, dataset: \"cluster_temp_&seq._v\");\n      hash2.defineKey('CLUSTER_id_key_2');\n      hash2.defineData('CLUSTER_id_data_2');\n      hash2.defineDone();\n\t\tcall missing(CLUSTER_id_key_2, CLUSTER_id_data_2);\n\n\tend;\n\n\tset cluster_dmc_&seq._temp;\n\n\tvar_CLUSTER_id=CLUSTER_id_&seq;\n\tCLUSTER_id_key=CLUSTER_id_&seq;\n\trc = myhash.find();\n\t\n\tif (rc = 0) then\n\t\tdo;\n\t\t\tvar_CLUSTER_id=CLUSTER_id_data;\n\t\t\ts_CLUSTER_id=CLUSTER_id_data;\n\n\t\t\trc2 = s_hash.find();\n\t\t\tif (rc2 = 0) then\n\t\t\t\tdo;\n\t\t\t\t\tvar_CLUSTER_id=s_var_CLUSTER_id;\n\t\t\t\tend;\n\t\t\telse\n\t\t\t\tdo;\n\t\t\t\t\tCLUSTER_id_key=CLUSTER_id_data;\n\t\t\t\t\ts_var_CLUSTER_id=CLUSTER_id_data;\n\t\t\t\t\trc3 = myhash.find();\n\t\t\t\t\tif (rc3 = 0) then\n\t\t\t\t\t\tdo;\n\t\t\t\t\t\t\tvar_CLUSTER_id=CLUSTER_id_data; /* last addition */\n\t\t\t\t\t\t\ts_var_CLUSTER_id=CLUSTER_id_data;\n\t\t\t\t\t\t\tif (CLUSTER_id_data = CLUSTER_id_&seq) then\n\t\t\t\t\t\t\t\tdo;\n\t\t\t\t\t\t\t\t\tvar_CLUSTER_id = CLUSTER_id_&seq;\n\t\t\t\t\t\t\t\tend;\n\t\t\t\t\t\tend;\n\t\t\t\t\ts_CLUSTER_id=CLUSTER_id_&seq;\n\t\t\t\t\trc4 = s_hash.add();\n\t\t\t\tend;\n\t\tend;\n\telse\n\t\tdo;\n\t\t\tCLUSTER_id_key_2=CLUSTER_id_&seq;\n\t\t\trc5 = hash2.find();\n\t\t\tif (rc5 = 0) then\n\t\t\t\tdo;\n\t\t\t\t\tvar_CLUSTER_id=CLUSTER_id_data_2;\n\t\t\t\tend;\n\t\tend;\n\nrun;\n\n/*-------------------- OR-ing with match code (End) ----------------------------- */\n\n%rcSet(&syserr); \n\n%put %str(NOTE: End OR-ing with match code # &seq);\n\n%put %str(NOTE: Deleting temporary work tables);\n\nproc datasets lib=work nolist nowarn;\n   delete cluster_dmc_&prev_seq._final inp_cluster_dmc_&seq cluster_dmc_&seq._temp;\nquit;\n\nproc datasets lib=work nolist nowarn memtype=(view);\n   delete cluster_dmc_&seq._hash inp_cluster_temp_&seq inp_cluster_dmc_&seq._v cluster_temp_&seq._v;\nquit;\n\n%end;\n\n%mend match_code_oring;\n\n/* Call the macro to do OR-ing between match codes 2 to n */\n\n%match_code_oring;\n\n/*---------------------------Assign CLUSTER_IDs to clusters-------------------------------*/\n\n%let ipdsn=&syslast;\n\ndata _null_;\n\nif &mc_cnt lt 2  then\n\tcall symput('ipdsn','WORK.CLUSTER_DMC_1_FINAL');\nelse\n\tcall symput('ipdsn',\"&syslast\");\n\nrun;\n\n/* sort on CLUSTER_ID_OLD to resolve any de-linking of clusters */\n\nproc sort data=&ipdsn;\n\tby CLUSTER_ID_OLD VAR_CLUSTER_ID;\nrun;\n\n/* create a view to act as a input for hash */\n\ndata CLUSTER_DMC_FINAL_V / view=CLUSTER_DMC_FINAL_V ;\n \tattrib CLUSTER_id_key length=8. format=Best12.;\n \tattrib CLUSTER_id_data length=8. format=Best12.; \n\tkeep CLUSTER_id_key CLUSTER_id_data;\n\tretain CLUSTER_id_data;\n\tset &ipdsn (sortedby=CLUSTER_ID_OLD);\n\tby CLUSTER_ID_OLD;\n\tif (CLUSTER_ID_OLD ne .) then\n\t\tdo;\n\t\t\tif (last.CLUSTER_ID_OLD ne 1) then\n\t\t\t\tdo;\n\t\t\t\t\tif (CLUSTER_id_data eq .) then\n\t\t\t\t\t\tdo;\n\t\t\t\t\t\t\tCLUSTER_id_data = VAR_CLUSTER_ID;\n\t\t\t\t\t\tend;\n\t\t\t\tend;\n\t\n\t\t\tif (CLUSTER_id_data ne var_CLUSTER_id) then\n\t\t\t\tdo;\n\t\t\t\t\tCLUSTER_id_key = var_CLUSTER_id;\n\t\t\t\tend;\n\t\t\n\t\t\tif (CLUSTER_id_key ne .) & (CLUSTER_id_data ne .) & (CLUSTER_id_key ne CLUSTER_id_data) then\n\t\t\t\tdo;\n\t\t\t\t\toutput;\n\t\t\t\tend;\n\t\n\t\t\tif last.CLUSTER_ID_OLD then\n\t\t\t\tdo;\n\t\t\t\t\tCLUSTER_id_data =.;\n\t\t\t\tend; \n\t\tend;\nrun;\n\n%rcSet(&syserr); \n\n/* This step will rectify instances of one old CLUSTER_id having multiple new CLUSTER_id linkages */\n\ndata NEW_CLUSTER_TEMP (COMPRESS=YES);\n\tdrop CLUSTER_id_new CLUSTER_id_key CLUSTER_id_data s_CLUSTER_id s_var_CLUSTER_id rc rc2 rc3 rc4;\n\n \tattrib CLUSTER_id_new length=8. format=Best12.;\n \tattrib CLUSTER_id_key length=8. format=Best12.;\n \tattrib CLUSTER_id_data length=8. format=Best12.;\n\tattrib s_CLUSTER_id length=8. format=Best12.;\n\tattrib s_var_CLUSTER_id length=8. format=Best12.;\n\t\n\tif _N_ = 1 then \n\tdo;\n\t\tdeclare hash myhash(hashexp: 13, dataset: \"CLUSTER_DMC_FINAL_V\");\n\t\tmyhash.defineKey('CLUSTER_id_key');\n\t\tmyhash.defineData('CLUSTER_id_key','CLUSTER_id_data');\n\t\tmyhash.defineDone();\n\t\tcall missing(CLUSTER_id_key, CLUSTER_id_data);\n\n\t\tdeclare hash s_hash(hashexp: 13);\n\t\ts_hash.defineKey(\"s_CLUSTER_id\");\n\t\ts_hash.defineData(\"s_var_CLUSTER_id\");\n\t\ts_hash.defineDone();\n\t\tcall missing(s_CLUSTER_id, s_var_CLUSTER_id);\t\t\n\tend;\n\tset &ipdsn;\n\tCLUSTER_id_key = var_CLUSTER_id;\n\trc = myhash.find();\n\tif (rc = 0) then\n\t\tdo;\n\t\t\tCLUSTER_id_new = CLUSTER_id_data;\n\t\t\ts_CLUSTER_id = CLUSTER_id_data;\n\n\t\t\trc2 = s_hash.find();\n\t\t\tif (rc2 = 0) then\n\t\t\t\tdo;\n\t\t\t\t\tCLUSTER_id_new = s_var_CLUSTER_id;\n\t\t\t\tend;\n\t\t\telse\n\t\t\t\tdo;\n\t\t\t\t\tCLUSTER_id_key = CLUSTER_id_data;\n\t\t\t\t\ts_var_CLUSTER_id = CLUSTER_id_data;\n\t\t\t\t\trc3 = myhash.find();\n\t\t\t\t\tif (rc3 = 0) then\n\t\t\t\t\t\tdo;\n\t\t\t\t\t\t\tCLUSTER_id_new = CLUSTER_id_data; \n\t\t\t\t\t\t\ts_var_CLUSTER_id = CLUSTER_id_data;\n\t\t\t\t\t\t\tif (CLUSTER_id_data = var_CLUSTER_id) then\n\t\t\t\t\t\t\t\tdo;\n\t\t\t\t\t\t\t\t\tCLUSTER_id_new = var_CLUSTER_id;\n\t\t\t\t\t\t\t\tend;\n\t\t\t\t\t\tend;\n\t\t\t\t\ts_CLUSTER_id = var_CLUSTER_id;\n\t\t\t\t\trc4 = s_hash.add();\n\t\t\t\tend;\n\t\tend;\n\tif CLUSTER_id_new ne . then\n\t\tdo;\n\t\t\tvar_CLUSTER_id = CLUSTER_id_new;\n\t\tend;\nrun;\n\n%rcSet(&syserr); \n\n/* Delete the temporary data step view */\n\nproc datasets lib=work nolist memtype=(Data View);\n\tdelete CLUSTER_DMC_FINAL_V;\nquit;\n\n%rcSet(&syserr); \n\n/* sort on CLUSTER_ID_OLD to resolve any de-linking of clusters */\n\nproc sort data=NEW_CLUSTER_TEMP;\n\tby CLUSTER_ID_OLD VAR_CLUSTER_ID;\nrun;\n\n%rcSet(&syserr); \n\n/* create a view to act as a input for hash */\n\ndata CLUSTER_DMC_FINAL_V / view=CLUSTER_DMC_FINAL_V ;\n \tattrib CLUSTER_id_key length=8. format=Best12.;\n \tattrib CLUSTER_id_data length=8. format=Best12.;\n\tkeep CLUSTER_id_key CLUSTER_id_data;\n\tretain CLUSTER_id_data;\n\tset NEW_CLUSTER_TEMP (sortedby=CLUSTER_ID_OLD);\n\tby CLUSTER_ID_OLD;\n\tif (CLUSTER_ID_OLD ne .) then\n\t\tdo;\n\t\t\tif (last.CLUSTER_ID_OLD ne 1) then\n\t\t\t\tdo;\n\t\t\t\t\tif (CLUSTER_id_data eq .) then\n\t\t\t\t\t\tdo;\n\t\t\t\t\t\t\tCLUSTER_id_data = VAR_CLUSTER_ID;\n\t\t\t\t\t\tend;\n\t\t\t\tend;\n\t\n\t\t\tif (CLUSTER_id_data ne var_CLUSTER_id) then\n\t\t\t\tdo;\n\t\t\t\t\tCLUSTER_id_key = var_CLUSTER_id;\n\t\t\t\tend;\n\t\t\n\t\t\tif (CLUSTER_id_key ne .) & (CLUSTER_id_data ne .) & (CLUSTER_id_key ne CLUSTER_id_data) then\n\t\t\t\tdo;\n\t\t\t\t\toutput;\n\t\t\t\tend;\n\t\n\t\t\tif last.CLUSTER_ID_OLD then\n\t\t\t\tdo;\n\t\t\t\t\tCLUSTER_id_data =.;\n\t\t\t\tend; \n\t\tend;\nrun;\n\n%rcSet(&syserr); \n\n/* This step will rectify instances of one old CLUSTER_id having multiple new CLUSTER_id linkages */\n\ndata NEW_CLUSTER_TEMP_2 (COMPRESS=YES);\n\tdrop CLUSTER_id_new CLUSTER_id_key CLUSTER_id_data s_CLUSTER_id s_var_CLUSTER_id rc rc2 rc3 rc4;\n\n \tattrib CLUSTER_id_new length=8. format=Best12.;\n \tattrib CLUSTER_id_key length=8. format=Best12.;\n \tattrib CLUSTER_id_data length=8. format=Best12.;\n\tattrib s_CLUSTER_id length=8. format=Best12.;\n\tattrib s_var_CLUSTER_id length=8. format=Best12.;\n\t\n\tif _N_ = 1 then \n\tdo;\n\t\tdeclare hash myhash(hashexp: 13, dataset: \"CLUSTER_DMC_FINAL_V\");\n\t\tmyhash.defineKey('CLUSTER_id_key');\n\t\tmyhash.defineData('CLUSTER_id_key','CLUSTER_id_data');\n\t\tmyhash.defineDone();\n\t\tcall missing(CLUSTER_id_key, CLUSTER_id_data);\n\n\t\tdeclare hash s_hash(hashexp: 13);\n\t\ts_hash.defineKey(\"s_CLUSTER_id\");\n\t\ts_hash.defineData(\"s_var_CLUSTER_id\");\n\t\ts_hash.defineDone();\n\t\tcall missing(s_CLUSTER_id, s_var_CLUSTER_id);\t\t\n\tend;\n\tset NEW_CLUSTER_TEMP;\n\tCLUSTER_id_key = var_CLUSTER_id;\n\trc = myhash.find();\n\tif (rc = 0) then\n\t\tdo;\n\t\t\tCLUSTER_id_new = CLUSTER_id_data;\n\t\t\ts_CLUSTER_id = CLUSTER_id_data;\n\n\t\t\trc2 = s_hash.find();\n\t\t\tif (rc2 = 0) then\n\t\t\t\tdo;\n\t\t\t\t\tCLUSTER_id_new = s_var_CLUSTER_id;\n\t\t\t\tend;\n\t\t\telse\n\t\t\t\tdo;\n\t\t\t\t\tCLUSTER_id_key = CLUSTER_id_data;\n\t\t\t\t\ts_var_CLUSTER_id = CLUSTER_id_data;\n\t\t\t\t\trc3 = myhash.find();\n\t\t\t\t\tif (rc3 = 0) then\n\t\t\t\t\t\tdo;\n\t\t\t\t\t\t\tCLUSTER_id_new = CLUSTER_id_data; \n\t\t\t\t\t\t\ts_var_CLUSTER_id = CLUSTER_id_data;\n\t\t\t\t\t\t\tif (CLUSTER_id_data = var_CLUSTER_id) then\n\t\t\t\t\t\t\t\tdo;\n\t\t\t\t\t\t\t\t\tCLUSTER_id_new = var_CLUSTER_id;\n\t\t\t\t\t\t\t\tend;\n\t\t\t\t\t\tend;\n\t\t\t\t\ts_CLUSTER_id = var_CLUSTER_id;\n\t\t\t\t\trc4 = s_hash.add();\n\t\t\t\tend;\n\t\tend;\n\tif CLUSTER_id_new ne . then\n\t\tdo;\n\t\t\tvar_CLUSTER_id = CLUSTER_id_new;\n\t\tend;\nrun;\n\n%rcSet(&syserr); \n\n%Let ipdsn = NEW_CLUSTER_TEMP_2;\n\n%macro Cluster_Assigner_final(ipdsn, opdsn, seq_dsn, seq_col);\n\n/* Determine if the sequence table exists  */ \n%let seq_tbl_Exist = %sysfunc(exist(&seq_dsn, DATA));\n   \n/*---- Create a new sequence table  ----*/ \n%if (&seq_tbl_Exist eq 0) %then \n%do;  /* if the sequence table does not exist  */ \n\n\t%put %str(NOTE: Creating table ...);\n\n\tdata &seq_dsn;\n\t\tattrib &seq_col length = 8 format = Best12.;\n\t\t&seq_col=10000000;\n\trun;\n\n%end; /* if the sequence table does not exist  */\n\n/* Sort the data set/view created in the last transformation */\n\nproc sort data=&ipdsn out=&ipdsn._sort (COMPRESS=YES) noequals;\n\tby var_CLUSTER_id descending CLUSTER_id_old;\nrun;\n\n/* Get the last value of sequence number stored in the sequence generator table */\n\nproc sql noprint;\n    select &seq_col into :var_seq\n\tfrom &seq_dsn;\nquit;\n\n%rcSet(&sqlrc);\n\n/* Assign cluster ids to clusters identified by grouping match code column */\n%macro DELETE_CLUSTER_TABLE();\n\n/* Determine if the CLUSTER_OUTPUT table exists  */ \n%let upd_tbl_Exist = %sysfunc(exist(saslib.CLUSTERED_OUTPUT, DATA));\n   \n/*---- DROP table  ----*/ \n%if (&upd_tbl_Exist eq 1) %then \n%do;  /* if the table exists  */ \n\n\t%put %str(NOTE: DROPing table ...);\n\t\tproc sql;\n\t\tdrop table saslib.CLUSTERED_OUTPUT;\n\tquit;\n%end; \n\n%mend DELETE_CLUSTER_TABLE;\n\n/* Call the macro DELETE_CLUSTER_TABLE */\n\n%DELETE_CLUSTER_TABLE;\n\ndata &opdsn(compress=yes);\n/*\tdrop var_CLUSTER_id;*/\n\tdrop var_CLUSTER_id DEDUPE_MATCH_CODE_5 DEDUPE_MATCH_CODE_6 DMC_1_FLAG DMC_2_FLAG DMC_3_FLAG DMC_4_FLAG DMC_5_FLAG DMC_6_FLAG;\n\n\tattrib CLUSTER_id length=8. format=Best12.;\n\tset &ipdsn._sort (sortedby=var_CLUSTER_id);\n\tby var_CLUSTER_id;\n\tretain CLUSTER_id;\t\n\tif first.var_CLUSTER_id then\n\tdo;\n\t\tif CLUSTER_id_old eq . then\n\t\tdo;\n\t\t\tCLUSTER_id = symgetn('var_seq');\n\t\t\tCLUSTER_id = CLUSTER_id + 1;\n\t\t\tcall symput('var_seq',CLUSTER_id);\n\t\tend;\n\t\telse\n\t\tdo;\n\t\t\tCLUSTER_id = CLUSTER_id_old;\n\t\tend;\n\tend;\nrun;\n\n/* Store the last generated value of the sequence in the sequence generator table */\n\nproc sql;\n\tupdate &seq_dsn\n\tset &seq_col = &var_seq;\nquit;\n\n%rcSet(&sqlrc);\n\n%mend Cluster_Assigner_final;\n\n/* Call the clustering macro */\n\n%Cluster_Assigner_final(&ipdsn, &opdsn, &seq_dsn, &seq_col);\n\n/*---- End of User Written Code  ----*/\n/*---- End of User Written Code  ----*/ \n\n/*---- Start of Post-Process Code  ----*/ \n\n\n\nPROC SQL; \n\tcreate index sas_id on SASLIB.CLUSTERED_OUTPUT (sas_id);\nQUIT;\n\nPROC SQL; \n\tdrop index cluster_id on SASLIB.SAS_DIM_DEDUPE;\nQUIT;\n\n\nPROC SQL ;\nUPDATE   SASLIB.SAS_DIM_DEDUPE  A \nSET CLUSTER_ID = \n( \tSELECT min(B.CLUSTER_ID) FROM SASLIB.CLUSTERED_OUTPUT  B WHERE  A.SAS_ID  EQ B.SAS_ID )\n;\nQUIT;\nPROC SQL; \n\tcreate index cluster_id on SASLIB.SAS_DIM_DEDUPE(cluster_id);\nQUIT;\n/*---- Start of User Written Code  ----*/ \n\n/* Insert the records from new_old_cluster_id_xref to new_old_cluster_id_xref_hist */\nproc sql;\ninsert into saslib.new_old_cluster_id_xref_hist select * from saslib.new_old_cluster_id_xref;\nquit;\n\n\n\n/*---- End of User Written Code  ----*/\n\n\nPROC SQL ;\nUPDATE  DQ.UCC_DIM_SAS \nSET UPDATE_STATUS = ''\t\n;\nQUIT;\n\n\n/*---- End of Post-Process Code  ----*/ \n\n%rcSet(&syserr); \n%rcSet(&sqlrc); \n\n%let etls_endTime = %sysfunc(datetime(),datetime.);\n"
    },
    {
      "role": "assistant",
      "content": "step: think\ncontent: |\n  This SQL file appears to be a complex clustering job for data deduplication. It's part of what seems to be a larger data processing system. The file contains:\n\n  1. A job definition (4 JOB ASSIGN CLUSTER ID INCR)\n  2. Configuration settings for the SAS metadata server\n  3. Macros for handling clustering and deduplication of data\n  4. Code to assign cluster IDs to records based on match codes\n  5. References to data tables that appear to be related to BSE (Bombay Stock Exchange) data\n\n  Let me also look at one more key file to understand the overall structure of the project better. I'll examine the SAS_Code_Understanding.xls file which might provide more context about the overall project."
    },
    {
      "role": "user",
      "content": "Continue to the next step."
    },
    {
      "role": "assistant",
      "content": "step: action\ntool: fileManager\ninput: fileManager('read', '/home/rishav/Documents/Code/6th-sense/Optqo_repo_function/repository/BSEProject/4thQuery.txt')"
    },
    {
      "role": "user",
      "content": "OBSERVE: File content (91287 characters):\n/**********************************************/\n/**********************************************/\n\n%macro Eventact;\n\n\n/*Report creation macro*/\n%macro report;\n\ndata InsiderReportTemp;\nset ABTTEMPV1i;\nif trandate < &anndate and trandate >= &APFirst then PEBuy = TotBuyQty;\nelse PEBUY = 0;\nif trandate < &anndate and trandate >= &APFirst then PESell = TotSellQty;\nelse PESell = 0;\nif trandate >= &anndate and trandate <= &APLast then PoBuy = TotBuyQty;\nelse PoBUY = 0;\nif trandate >= &anndate and trandate <= &APLast then PoSell = TotSellQty;\nelse PoSell = 0;\n\nif trandate < &anndate and trandate >= &APFirst then PEBuyVal = TotBuyVal/100;\nelse PEBUYVal= 0;\nif trandate < &anndate and trandate >= &APFirst then PESellVal = TotSellVal/100;\nelse PESellVal = 0;\nif trandate >= &anndate and trandate <= &APLast then PoBuyVal = TotBuyVal/100;\nelse PoBUYVal = 0;\nif trandate >= &anndate and trandate <= &APLast then PoSellVal = TotSellVal/100;\nelse PoSellVal = 0;\nrun;\n\n%put  &favTag;\n\n/*Summary Table*/\nproc sql;\ncreate table IRSum&scripcd as \nselect distinct\nb.rownum,\na.panno,\n/*max(b.clientname) as clientname,*/\n/*max(b.phone) as phone,*/\n/*max(b.address) as address,*/\na.scripcd,\n&anndate as AnnDate  format date9. ,\n&APFirst as FromDate format date9.,\n&APLast as ToDate format date9.,\n\nsum(PEBUY) as PreGPQTY format comma15.0,\ncase\n\twhen calculated PreGPQTY <> 0 then (sum(PEBUYVal)/calculated PreGPQTY) \n\telse 0\nend as PreBuyRate  format comma15.2,\nsum(PESell) as PreGSQty format comma15.0,\ncase\n\twhen Calculated PreGSQty <> 0 then (sum(PESellVal)/Calculated PreGSQty)\n\telse 0\nend as PreSellRate format comma15.2,\ncalculated PreGPQTY - calculated PreGSQty as PreNPQTY format comma15.0,\ncalculated PreGSQty - calculated PreGPQTY as PreNSQty format comma15.0,\n\nsum(PoBUY) as PostGPQTY format comma15.0,\ncase\n\twhen calculated PostGPQTY <> 0 then (sum(PoBUYVal)/calculated PostGPQTY) \n\telse 0\nend as PostBuyRate format comma15.2,\nsum(PoSell) as PostGSQty format comma15.0,\ncase\n\twhen Calculated PostGSQty <> 0 then (sum(PoSellVal)/Calculated PostGSQty)  \n\telse 0\nend as PostSellRate format comma15.2,\ncalculated PostGPQTY - calculated PostGSQty as PostNPQTY format comma15.0,\ncalculated PostGSQty - calculated PostGPQTY as PostNSQty format comma15.0,\n\n(calculated PreGPQTY + calculated PostGPQTY) as GPQTY format comma15.0,\ncase\n\twhen calculated GPQTY <> 0 then ((sum(PEBUYVal)+ sum(PoBUYVal))/calculated GPQTY) \n\telse 0\nend as NetBuyRate format comma15.2,\n(calculated PreGSQTY + calculated PostGSQTY) as GSQty format comma15.0,\ncase\n\twhen calculated GSQty <> 0 then ((sum(PESellVal) + sum(PoSellVal))/calculated GSQty) \n\telse 0\nend as NetSellRate format comma15.2,\n(calculated PreGSQTY + calculated PostGSQTY) - (calculated PreGPQTY + calculated PostGPQTY) as NetGSQty format comma15.0,\n(calculated PreGPQTY + calculated PostGPQTY) - (calculated PreGSQTY + calculated PostGSQTY) as NetGPQTY format comma15.0,\n\n/*&Close_rateBSE/100 as CloseRate format comma15.2,*/\n/*&Open_rateBSE/100 as OpenRate format comma15.2,*/\n/*case*/\n/*\twhen calculated PostGSQty < calculated PreGPQTY then calculated PostGSQty * (calculated PostSellRate - calculated PreBuyRate)*/\n/*\twhen calculated PreGPQTY <= calculated PostGSQty then calculated PreGPQTY * (calculated PostSellRate - calculated PreBuyRate)*/\n/*\telse 0*/\n/*end as Profit format comma15.0,*/\nmin(max(0, calculated PreNPQTY), max(0, calculated PostNSQty)) * (calculated PostSellRate - calculated PreBuyRate) as Profit format comma15.0,\nmin(max(0, calculated PreNPQTY), max(0, calculated PostNSQty)) * (calculated PostSellRate - calculated PreBuyRate) as Profit format comma15.0,\n/*&Close_rate/100 as CloseRate,*/\n&Close_rateBSE/100 as CloseRate,\ncase\n\twhen &favtag = \"F\" then\n(max(0, calculated PostNSQty) * calculated PostSellRate) - (max(0, calculated PreNPQTY) * calculated PreBuyRate) + (max(0, calculated PreNPQTY) * &Close_rateBSE/100) \n\twhen &favTag = \"U\" then b.notprof/100\n\telse 0\nend as NotionalProfit format comma15.0\n/*case*/\n/*\twhen calculated PostGSQty >= calculated PreGPQTY then (calculated PostGSQty * calculated PostSellRate) - (calculated PreGPQTY * calculated PreBuyRate)*/\n/*\twhen calculated PostGSQty < calculated PreGPQTY then (calculated PreGPQTY * (calculated PostSellRate - calculated PreBuyRate)) + ((calculated PreGPQTY - calculated PostGSQty) * &Close_rateBSE/100) */\n/*\telse 0*/\n/*end as NotionalProfit format comma15.0*/\n/*b.notprof as NotionalProfit format comma15.0*/\n/*sum(PoSellVal) - sum(PEBUYVal) + (max(0, (sum(PEBUY) - sum(PoSell))) * &Close_rateBSE)/100 as NotionalProfit format comma15.0*/\nfrom InsiderReportTemp a right outer join Insiders&scripcd b on a.panno = b.pannoap\n/*where a.panno in (select pannoap from Insiders&scripcd)*/\ngroup by a.panno, b.rownum\norder by b.rownum asc;\nquit;\n\n/*proc sql;*/\n/*create table IRSum&scripcd as */\n/*select distinct*/\n/*a.*,*/\n/*case*/\n/*\twhen b.NotprofBSe/100 > 0 then b.NotprofBSe/100*/\n/*\telse .*/\n/*end as NotionalProfit format comma15.0*/\n/*from IRSum&scripcd a left outer join INSIDERS&scripcd b*/\n/*on a.panno = b.pannoap*/\n/*order by calculated NotionalProfit desc;*/\n/*quit; */\n\n/*Transaction detail table*/\nproc sql;\ncreate table IRTran&scripcd as \nselect distinct\na.panno,\na.scripcd,\na.trandate format date9.,\na.totbuyqty as GPQty format comma15.0,\n(a.TotBuyval/a.totbuyqty)/100  as buy_rate format comma15.2,\n(a.totbuyqty/a.no_of_shares_traded) * 100 as GPToScripVol format comma15.5,\na.totsellqty as GSQTY format comma15.0, \n(a.totsellval/a.totsellqty)/100  as sell_rate format comma15.2,\n(a.totsellqty/a.no_of_shares_traded) * 100 as GSToScripVol format comma15.5,\n(a.totbuyqty - a.totsellqty) as NPQty format comma15.0,\na.no_of_shares_traded as ScripVolume format comma15.0,\nb.NotionalProfit\nfrom ABTTEMPV1i a left outer join IRSum&scripcd b\non a.panno = b.panno\nwhere a.panno in (select pannoap from Insiders&scripcd)\norder by b.rownum asc, a.panno, a.trandate;\nquit;\n\n/*Across the market bahviour table*/\nproc sql;\ncreate table IRMart&scripcd.1 as \nselect distinct\npanno,\nscripcd,\nsum(totbuyqty) as GPQty format comma15.0,\n(sum(TotBuyval)/sum(totbuyqty))/100 as buy_rate format comma15.2,\nsum(totsellqty) as GSQTY format comma15.0, \n(sum(totsellval)/sum(totsellqty))/100  as sell_rate format comma15.2,\n(sum(totbuyqty) - sum(totsellqty)) as NPQty format comma15.0,\n(sum(totbuyqty) + sum(totsellqty)) as TotQty,\nsum(no_of_shares_traded) as ScripVolume format comma15.0\nfrom ABT&scripcd.Raw\nwhere panno in (select pannoap from Insiders&scripcd)\ngroup by  panno, scripcd\norder by panno, scripcd;\nquit;\n\nproc sql;\ncreate table IRMart&scripcd as \nselect\na.PANNO,\na.SCRIPCD,\na.GPQty,\na.buy_rate,\na.GPQty/a.ScripVolume * 100 as GPToScripVol format comma15.2,\na.GSQTY,\na.sell_rate,\na.GSQty/a.ScripVolume * 100 as GSToScripVol format comma15.2,\na.NPQty,\na.TotQty/b.GrandTot * 100 as Exposureratio format comma15.2,\na.ScripVolume \nfrom IRMart&scripcd.1 a left outer join \n(select panno, sum(TotQty) as GrandTot, \nsum(GPQty) as GrandBuy,  \nsum(GSQty) as GrandSell\nfrom IRMart&scripcd.1 group by panno) b\non a.panno = b.panno\norder by a.panno, a.scripcd;\nquit;\n\nproc sql;\ncreate table IRSum&scripcd.v1 as\nselect a.*,\nb.Exposureratio\nfrom IRSum&scripcd a left outer join IRMart&scripcd b \non a.panno = b.panno and a.scripcd = b.scripcd\norder by a.rownum asc;\nquit;\n\nproc sql;\ncreate table UCCTemp as\nselect\npanno,\nmax(ClientName) as ClientName,\nmax(address) as address,\nmax(city) as city,\nmax(pincode) as pincode,\nmax(phone) as phone\nfrom tt.UCC_DIM_SAS \nwhere panno in (select distinct panno from IRSUM&scripcd.V1)\ngroup by panno;\nquit;\n\nproc sql;\ncreate table IRSUM&scripcd.V2 as\nselect distinct \na.*,\nc.ClientName,\nc.address,\nc.city,\nc.pincode,\nc.phone\nfrom IRSUM&scripcd.V1 a left outer join UCCTemp c \non a.panno = c.panno\norder by a.rownum asc;\nquit;\n\n\nproc sql;\ncreate table Announcement&scripcd as \nselect distinct\n\tb.fld_scripcode as scripcd,\n\tb.FLD_COMPANYID as companyid,\n\ta.FLD_BODY as body,\n\tb.fld_longname,\n\tdatepart(a.FLD_AUTHORISEDATE) as anndate format = date9.\n\tfrom tt.COMPANY_ANNOUNCEMENT_DATA a left outer join tt.COMPANY_SCRIP_MASTER b\n\ton a.fld_companyid = b.fld_companyid\n\twhere fld_critical = 1 and calculated anndate =  &anndate and scripcd = &scripcd;\nquit;\n\n/*exporting file in excel format*/\n\nPROC EXPORT OUTFILE=&File DATA=Announcement&scripcd DBMS=xls REPLACE; \nSHEET=\"Announcement&scripcd\"; \nrun;\n\nPROC EXPORT OUTFILE=&File DATA=Date&Scripcd DBMS=xls REPLACE; \nSHEET=\"DateDetails&scripcd\"; \nrun;\n\nPROC EXPORT OUTFILE=&File DATA=IRSUM&scripcd.V2 DBMS=xls REPLACE; \nSHEET=\"Summary&scripcd\"; \nrun;\n\nPROC EXPORT OUTFILE=&File DATA=IRTran&scripcd DBMS=xls REPLACE; \nSHEET=\"Transaction&scripcd\"; \nrun;\n\nPROC EXPORT OUTFILE=&File DATA=IRMart&scripcd DBMS=xls REPLACE; \nSHEET=\"Market&scripcd\"; \nrun;\n\n%mend report;\n\n/*looping through all announcements with their respective time windows\nand running the insider module for each*/\n\n%let i = 1;\n\nPROC EXPORT OUTFILE=&File2 DATA=Datetab&date DBMS=xls REPLACE; \nSHEET=\"Announcement&date\"; \nrun;\n\nproc sql;\ncreate table eventtab as \nselect\nMONOTONIC() AS RowNum FORMAT=COMMA6., \n*\nfrom Datetab&date\nwhere eplast is not null and fav_Unfav in ('Af', 'Bb', 'Dn') and selection <> 'c. Not Select' and AnalyseFlag = 1;\nquit;\n\n\tproc sql noprint;\n\t\tselect count(*) \n\t\tinto :maxrown\n\t\tfrom eventtab;\n\tquit;\n/*\t%let maxrown = 1;*/\n\n%do %while(&i <= &maxrown);\n\n\tdata _null_;\n\t\tset eventtab;\n\t\tcall symputx('scripcd', scripcd);\n\t\tcall symputx('anndate1', put(anndate , Date9. ));\n\t\tcall symputx('Eplast', EPLast);\n\t\tcall symputx('EPFirst', EPFirst);\n\t\tcall symputx('Aplast', APLast);\n\t\tcall symputx('APFirst', APFirst);\n\t\tcall symputx('fav_Unfav', fav_Unfav);\n\t\twhere rownum = &i;\n\trun;\n\n\t%let anndate  = \"&anndate1\"d ;\n\t\n\n\tproc sql;\n\t\tcreate table Date&Scripcd as\n\t\tselect * from eventtab\n\t\twhere rownum = &i;\n\tquit;\n\n/*-----------INSIDER MODULE-------------*/\n/*extracting raw data*/\n\n%put &i &scripcd &fav_Unfav;\n\n/*** IF FAVORABLE ***/\n\n%if &fav_Unfav = Af or &fav_Unfav = Bb %then %do;\n\n%let FavTag = \"F\";\n\nproc sql;\n\tcreate table ABT&scripcd.Raw as\n\tselect distinct\n\tmax(a.panno) as pannotemp,\n\tc.panno,\n\ta.Scripcd,\n\tdatepart(trandate) as trandate format = date9.,\n\tsum(TotBuyQty) as TotBuyQty,\n\tsum(TotSellQty) as TotSellQty,\n\tsum(TotBuyVal) as TotBuyVal,\n\tsum(TotSellVal) as TotSellVal,\n\tcalculated TotBuyVal ne 0 as BuyTag,\n\tcalculated TotSellVal ne 0 as SellTag,\n\tmax(b.no_of_shares_traded) as no_of_shares_traded,\n\tmax(net_turnover) as net_turnover,\n\tmax(close_rate) as Close_rate,\n\tmax(open_rate) as open_rate\n\tfrom ((tt.MEMBER_SCRIP_CLIENT_SUMMERY a left outer join tt.SCRIP_SUMMERY b \n\ton (datepart(a.trandate) = datepart(b.trade_date)) and (b.scrip_code = a.Scripcd))\n\tleft outer join tt.UCC_DIM_SAS c on a.clientcd = c.clientcode and a.membercd = c.brokercode)\n\twhere datepart(a.trandate)>= &APFirst and datepart(a.trandate) <= &APLast \n\tgroup by a.Scripcd, c.panno, calculated trandate;\nquit;\n\n/*raw data manipulation to create ABT*/\nproc sql;\n\tcreate table ABTTEMPV1i as\n\tselect * from ABT&scripcd.Raw\n\twhere scripcd = &scripcd\n\torder by panno, trandate;\nquit;\n\n\ndata ABTTEMPV1i;\n\tset ABTTEMPV1i;\n\tby panno;\n\tformat POST_ADJST_LONG_QUANTITY best8. POST_ADJST_SHORT_QUANTITY best8.;\n\tretain POST_ADJST_LONG_QUANTITY 0 POST_ADJST_SHORT_QUANTITY 0;\n\tif first.panno then do;\n\tPOST_ADJST_LONG_QUANTITY =0 ;\n\tPOST_ADJST_SHORT_QUANTITY =0;\n\tend;\n\tif sum(TotBuyQty, 0) > sum(TotSellQty, 0) then DayStatus = \"B\";\n\telse if sum(TotBuyQty, 0) < sum(TotSellQty, 0) then DayStatus = \"S\";\n\telse if sum(TotBuyQty, 0) = sum(TotSellQty, 0) then DayStatus = \"N\";\n\tif TotBuyQty > TotSellQty then do;\n\tPOST_ADJST_LONG_QUANTITY = max(sum(POST_ADJST_LONG_QUANTITY, TotBuyQty, - TotSellQty, - POST_ADJST_SHORT_QUANTITY),0);\n\tPOST_ADJST_short_QUANTITY = max(sum(POST_ADJST_short_QUANTITY, -TotBuyQty, TotSellQty),0);\n\tend;\n\telse do;\n\tPOST_ADJST_SHORT_QUANTITY = max(sum(POST_ADJST_SHORT_QUANTITY, TotSellQty, - TotBuyQty, - POST_ADJST_long_QUANTITY),0);\n\tPOST_ADJST_LONG_QUANTITY = max(sum(POST_ADJST_LONG_QUANTITY, - TotSellQty, TotBuyQty),0);\n\tend;\n\tif POST_ADJST_LONG_QUANTITY = POST_ADJST_SHORT_QUANTITY then type_intrst='NT';\n\telse if POST_ADJST_LONG_QUANTITY > POST_ADJST_SHORT_QUANTITY then type_intrst='LG';\n\telse if POST_ADJST_LONG_QUANTITY < POST_ADJST_SHORT_QUANTITY then type_intrst='ST';\n\topen_intrst= ABS(POST_ADJST_LONG_QUANTITY - POST_ADJST_SHORT_QUANTITY);\n\tif sum(POST_ADJST_LONG_QUANTITY ,- POST_ADJST_SHORT_QUANTITY) > 0 and TotBuyQty ne 0 then\n\thold_INTRST = (sum(POST_ADJST_LONG_QUANTITY, -POST_ADJST_SHORT_QUANTITY)/no_of_shares_traded);\n\telse HOLD_INTRST=0;\n\tif sum(TotBuyQty,-TotSellQty)>0 and TotBuyQty ne 0 then\n\tdays_hold = ((sum(TotBuyQty,-TotSellQty)) / no_of_shares_traded);\n\tELSE days_hold = 0;\n\tOpenIntrstRat = open_intrst/no_of_shares_traded;\nrun;\n\nproc sort data = ABTTEMPV1i;\n\tby panno trandate;\nrun;\n\ndata test1;\n\tset ABTTEMPV1i (KEEP= type_intrst trandate);\n\trename type_intrst = nxt_type_intrst ;\n\trename trandate = nxt_date ;\n\tif _n_ not = 1 ;\nrun;\n\ndata cmcase;\n\tmerge ABTTEMPV1i test1;\nrun;\n\nproc sort data = cmcase;\n\tby panno trandate;\nrun;\n\n%macro ABTTemp(First, Last, Period, s);\n\ndata ABTTemp&Period.v1;\n\tset cmcase (where = (trandate BETWEEN &first AND &last));\n\tBY panno;\n\tretain fdate 0;\n\tformat dur best8.;\n\tformat tdate fdate date9.;\n\tif first.panno or type_intrst ne lag1(type_intrst) then count1 = 0;\n\telse count1 + 1;\n/*\tEPLast = &EPLast;*/\n\tif last.panno then tDate = &last;\n\telse tDate = trandate;\n\tif first.panno or type_intrst ne lag1(type_intrst) then fdate = trandate;\n\telse fdate = fdate;\n\tif last.panno or type_intrst ne nxt_type_intrst then dur = (tdate - fdate);\n\tif last.panno or type_intrst ne nxt_type_intrst then count = count1;\nrun;\n\nproc sql;\n\n\tcreate table ABTTemp&Period.v2 as\n\tselect\n\tpanno as panno1&s,\n\ttype_intrst as type_intrst&s,\n\tsum(dur) as dur,\n\tcount(dur) as run,\n\t(&Last - &first) as PLenght,\n\t(calculated dur/ (&Last - &first)) as hold_dur,\n\t((calculated dur)/(calculated run)) as avg_dur\n\tfrom ABTTemp&Period.v1\n\tgroup by panno, type_intrst;\n\nquit;\n\ndata LGrun&period (keep = panno1&s LG:)\n\tSTrun&period (keep = panno1&s  ST:)\n\tNTrun&period (keep = panno1&s  NT:);\nset ABTTemp&Period.v2;\n\nif type_intrst&s= 'LG' then do ;\n  LG_dur&s = dur;\n  LG_avg_dur&s=avg_dur;\n  LG_run&s=run;\n  LG_hold&s=hold_dur;\n  output LGrun&period;\nend;\nelse if type_intrst&s= 'NT' then do ;\n  NT_dur&s = dur;\n  NT_avg_dur&s=avg_dur;\n  NT_run&s=run;\n  NT_hold&s=hold_dur;\n  output NTrun&period;\n end;\n else if type_intrst&s= 'ST' then do ;\n  ST_dur&s = dur;\n  ST_avg_dur&s=avg_dur;\n  ST_run&s=run;\n  ST_hold&s=hold_dur;\n  output STrun&period;\n end;\nrun;\n\nproc sql;\n\tcreate table ABTTemp&Period as \n\tselect\n\tpanno as panno&s,\n\tsum(TotBuyQty) as QtyB&s,\n\tsum(TotSellQty) as QtyS&s,\n\tsum(TotBuyVal) as ValB&s,\n\tsum(TotSellVal) as ValS&s,\n\tsum(TotBuyVal ne 0) as FreqB&s,\n\tsum(TotSellVal ne 0) as FreqS&s,\n\t(calculated QtyB&s + calculated QtyS&s) as QTY&s,\n\t(calculated QtyB&s - calculated QtyS&s) as NetBuy&s,\n\t(calculated ValB&s + calculated VAlS&s) as Val&s,\n\t(calculated ValB&s - calculated VAlS&s) as NetVal&s,\n\t(calculated FreqB&s + calculated FreqS&s) as Freq&s,\n\tsum(type_intrst = 'NT') as FreqNT&s,\n\tsum(type_intrst = 'LG') as FreqLG&s,\n\tsum(type_intrst = 'ST') as FreqST&s,\n\tsum(DayStatus = 'B') as FreqDB&s,\n\tsum(DayStatus = 'S') as FreqDS&s,\n\tsum(DayStatus = 'N') as FreqDN&s,\n\tcount(panno) as FreqOpen&s,\n\t(calculated FreqLG&s)/(calculated FreqOpen&s) as LGOpenRatio&s,\n\t1000000 * avg(hold_intrst) as AvgHoldIntrst&s format = 10.4,\n\t1000000 * max(hold_intrst) as MaxHoldIntsrt&s format = 10.4,\n\t1000000 * min(hold_intrst) as MinHoldIntrst&s format = 10.4,\n\t1000000 * avg(OpenIntrstRat) as AvgOpenIntRat&s format = 10.4,\n\t1000000 * max(OpenIntrstRat) as MaxOpenIntRat&s format = 10.4,\n\t1000000 * min(OpenIntrstRat) as MinOpenIntRat&s format = 10.4,\n\t1000000 * avg(days_hold) as AvgDaysHold&s format = 10.4,\n\t1000000 * max(Days_hold) as MaxDaysHold&s format = 10.4,\n\t1000000 * min(days_hold) as minDaysHold&s format = 10.4\n\tfrom ABTTemp&Period.v1\n\tgroup by panno; \n\nquit;\n\n%mend AbtTemp;\noption mprint;\n%abttemp(&EPFirst, &EPLast, EP, )\n%abttemp(&APFirst, &APLast, AP, AP)\n%abttemp(&APFirst, &Anndate, PE, PE)\n%abttemp(&anndate, &ApLAst, PO, PO)\n\nproc sql;\n\tcreate table ABTTempv3 as\n\tselect distinct\n\ta.*, b.*, c.*, d.*, e.*, f.*, g.*, h.*, i.*, j.QTYBPO, j.QTYSPO, j.NetBuyPO\n\tfrom (((((((((ABTTEMPEP a right outer join ABTTEMPAP b on a.panno = b.pannoap)\n\t\t\t\t\t\tleft outer join ABTTEMPPE i on b.pannoap = i.pannoPE)\n\t\t\t\t\t\tleft outer join ABTTEMPPO j on b.pannoap = j.pannoPo)\n\t\t\t\t\t\tleft outer join LGRUNAP c on b.pannoap = c.panno1Ap)\n\t\t\t\t\t\tleft outer join LGRUNEP d on b.pannoap = d.panno1)\n\t\t\t\t\t\tleft outer join NTRUNAP e on b.pannoap = e.panno1ap)\n\t\t\t\t\t\tleft outer join NTRUNEP f on b.pannoap = f.panno1)\n\t\t\t\t\t\tleft outer join STRUNAP g on b.pannoap = g.panno1ap)\n\t\t\t\t\t\tleft outer join STRUNEP h on b.pannoap = h.panno1)\n\t;\nquit;\n\ndata ABTTempv3;\n\tset ABTTempv3;\n\tdrop panno1 panno1AP panno pannoPE;\nrun;\n\nproc sort data = ABTTEMPV1i (where = (buytag ne 0)) nodupkey out = Periodb;\n\tby panno buytag;\nrun;\n\nproc sort data = ABTTEMPV1i (where = (selltag ne 0)) nodupkey out = Periods;\n\tby panno selltag;\nrun;\n\n\nproc sql;\n\tcreate table ABTTempv4 as \n\tselect distinct\n\ta.*, \n\t(&AnnDate - &ApFirst) as Preevnt,\n\tb.totsellqty as fSellqty,\n\tb.totsellval as fSellVol,\n\tb.trandate as Fselldt,\n\t(b.trandate - &APFirst) as dsfsell,\n\t(calculated dsfsell)/(calculated Preevnt) as EntrySell,\n\tc.totbuyqty as fBuyqty,\n\tc.totbuyval as fBuyVol,\n\tc.trandate as FBuydt,\n\t(c.trandate - &APFirst) as dsfbuy,\n\t(calculated dsfbuy)/(calculated Preevnt) as EntryBuy\n\tfrom ((ABTTempv3 a left outer join Periods b on a.pannoAP = b.panno)\n\t\t\t\t\t\tleft outer join Periodb c on a.pannoAP = c.panno);\nquit;\n\nproc sort data= ABTTEMPV1i out=ABTTempv1D;\n\tby panno descending trandate ;\nrun;\n\nproc sort data = ABTTempv1D (where = (buytag ne 0)) nodupkey out = Periodbl;\n\tby panno buytag;\nrun;\n\nproc sort data = ABTTempv1D (where = (selltag ne 0)) nodupkey out = Periodsl;\n\tby panno selltag;\nrun;\n\nproc sql;\n\tcreate table ABTTempv5 as \n\tselect distinct\n\ta.*, \n\tb.totsellqty as lSellqty,\n\tb.totsellval as lSellVol,\n\tb.trandate as lselldt,\n\t(b.trandate - &APFirst) as dslsell,\n\t(calculated dslsell)/Preevnt as ExitSell,\n\tc.totbuyqty as lBuyqty,\n\tc.totbuyval as lBuyVol,\n\tc.trandate as lBuydt,\n\t(c.trandate - &APFirst) as dslbuy,\n\t(calculated dslbuy)/Preevnt as ExitBuy,\n\tnetbuyAP as OverAllNetbuy,\n\tcase when qty = . then 0 else Qty/QtyAp end as TradeRatio,\n\tcase when Freq = . then 0 else Freq/FreqAP end as FreqRatio\n\tfrom ((ABTTempv4 a left outer join Periodsl b on a.pannoAP = b.panno)\n\t\t\t\t\t\tleft outer join Periodbl c on a.pannoAP = c.panno);\n\n\n\tcreate table OtherScrip&scripcd as\n\tselect \n\tpanno,\n\tsum(TotBuyQty) as oth_buy,\n\tsum(TotSellQty) as oth_sale,\n\t(calculated oth_buy - calculated oth_sale) as oth_net_buy,\n\tcount(distinct scripcd) as oth_stock_n,\n\tcount(panno) as oth_freq,\n\tsum(TotBuyQty > 0) as oth_freq_b,\n\tsum(TotSellQty > 0) as oth_freq_s,\n\tsum(TotbuyQty = TotSellqty) as oth_freq_n\n\tfrom ABT&scripcd.Raw\n\twhere scripcd ne &scripcd\n\tgroup by panno\n\torder by panno;\n\n\n\tselect \n\tmax(close_rate) * 100,\n\tmin(close_rate) * 100 \n\tinto :close_rate, :open_rate\n\tfrom ABT&scripcd.Raw\n\tWHERE scripcd = &Scripcd;\n\n\tselect \n\tmax(close_rate) * 100\n\tinto :Close_rateBSE\n\tfrom ABTTEMPV1i\n\twhere trandate >= &todate;\n\n\tselect \n\tmin(close_rate) * 100\n\tinto :open_rateBSE\n\tfrom ABTTEMPV1i\n\twhere trandate = (Select min(trandate) from ABTTEMPV1i); \n\n\n\t/**%put &close_rate &open_rate;*/\n\tcreate table abt_&scripcd.v1 as\n\tselect distinct\n\ta.*,\n\tb.*,\n\t&scripcD as Scripcd,\n\t&AnnDate as Anndate format = date9., \n\t/*--proportion of buy after event;*/\n\tcase\n\t\twhen sum(0, QtySPO, QTYBPO) = 0 then 0\n\t\telse sum(QtyBPO, 0)/sum(0, QtySPO, QTYBPO) \n\tend as PropBuyPO,\n\t/*--proportion of sell before event;*/\n\tcase\n\t\twhen sum(0, QTYSPO, QTYSPE) = 0 then 0\n\t\telse QTYSPE/sum(0, QTYSPO, QTYSPE)\n\tend as PropSell,\n\t/*--proportion of buy before event;*/\n\tcase\n\t\twhen sum(0, QtySPE, QTYBPE) = 0 then 0\n\t\telse sum(QtyBPE, 0)/sum(0, QtySPE, QTYBPE) \n\tend as PropBuyPE,\n\t/*--proportion of ScripVal bought compared to total invested;*/\n\tcase\n\t\twhen oth_buy in (0,.) then ( 1 - (1 /(1 + sum(0,ValBAP)) ))*100\n\t\tELSE ( 1 - (1 /(1 + sum(0,ValBAP)/oth_buy) ))*100\n\tend as hold_buy_all,\n\n\t/**proportion of ScripVal bought compared to total sold;*/\n\tcase\n\t\twhen oth_sale in (0,.) then ( 1 - (1 /(1 + sum(0,ValBAP)) ))\n\t\tELSE ( 1 - (1 /(1 + sum(0,ValBAP)/oth_sale) ))*100\n\tend as hold_buy_sale_all,\n\n\t/**proportion of ScripVal sold compared to total sold;*/\n\tcase\n\t\twhen OTH_SALE in (0,.) then ( 1 - (1 /(1 + sum(0,VAlSAP)) ))*100\n\t\tELSE ( 1 - (1 /(1 + sum(0,ValSap)/OTH_SALE) ))*100\n\tEND AS hold_SALE_all,\n\t/**ratio between frequncy of nuetral vs long or short max;*/\n\tCASE\n\t\tWHEN max(FreqSTAP, FreqLGAP) = 0 then 0\n\t\telse freqntAP/max(FreqSTAP, FreqLGAP)\n\tEND AS freq_n_ratio,\n\t/*Profit as is*/\n\tcase\n\t\twhen NetBuyAP > 0 then ValSAP - ValBAP\n\t\twhen NetBuyAP < 0 then ValSAP + (NetBuyAP * &open_rate) - ValBAP\n\t\telse ValSAP - ValBAP\n\tend as profit\n\tfrom ABTTempv5 a left outer join OtherScrip&scripcd b\n\ton a.pannoAP = b.panno;\n\t*where a.pannoAp is not null;\nquit;\n\nproc sql;\n\tcreate table abt_&scripcd as\n\tselect\n\t*,\n\tcase\n\t\twhen QTYSap = 0 and NetBuyAP > 0 then (&close_rate-(VALBAP/QTYBAP))*NetBuyAP\n\t\twhen QTYSap ne 0 and NetBuyAP > 0 THEN sum(((&close_rate-(VAlBAP/QTYBAP))*NetBuyAP),\n\t\t\t(((ValSAP/(QTYSAP+0.0000001))-(ValBAP/QTYBAP))*QTYSap))\n\t\twhen QTYBap = 0 and NetBuyAP < 0 then &close_rate * (-NetBuyAP)\n\t\twhen NetBuyAP < 0 and QTYBAP ne 0 then SUM(((&close_rate-(ValBAP/(QTYBAP+0.00000001)))*(-NetBuyAP)),\n\t\t\t(((ValSAP/QTYSAP)-(ValBAP/(QTYBAP+0.00000001)))*QTYBap))\n\t\telse ValSAP - ValBAP\n\tend as Notprof format 10.0,\n\tcase \n\t\twhen NetBuyAP > 0 then  sum(ValSAP, - ValBAP) + NetBuyAp * (&Close_rateBSE)\n\t\twhen sum(ValBAP, 0) = 0 then .\n\t\telse sum(ValSAP, - ValBAP)\n\tend as  NotprofBSe format 10.0,\n\tQtyB = sum(0, QtyB)\n\tfrom abt_&scripcd.v1;\nquit;\n\n\n\ndata Modelv1;\n\tset ABT_&scripcd;\n\t\tdrop lBuydt LG_dur LG_durAP lselldt NT_dur \n\t\t\t\tNT_durAP OverAllNetbuy PANNO Preevnt ST_dur ST_durAP;\n\t\twholevent = &APLast - &APFirst;\n\t\tif dsfbuy in (., 0) then dsfbuy = (Preevnt + 10); else dsfbuy = sum(dsfbuy, 0);\n\t\tif dsfsell in (., 0) then dsfsell = (Preevnt + 10); else dsfsell = sum(dsfsell, 0);\n\t\tif dslbuy in (., 0) then dslbuy = wholevent + 10; else dslbuy = sum(dslbuy, 0);\n\t\tif dslsell in (., 0) then dslsell = wholevent + 10; else dslsell = sum(dslsell, 0);\n\t\tLG_avg_dur = sum(LG_avg_dur, 0);\n\t\tLG_avg_durAP = sum(LG_avg_durAP, 0);\n\t\tNT_avg_dur = sum(NT_avg_dur, 0);\n\t\tNT_avg_durAP = sum(NT_avg_durAP, 0);\n\t\tST_avg_dur = sum(ST_avg_dur, 0);\n\t\tST_avg_durAP = sum(ST_avg_durAP, 0);\n\t\tExitBuy = dslbuy/wholevent;\n\t\tExitSell = dslsell/wholevent;\n\t\tAvgDaysHold = sum(AvgDaysHold, 0);\n\t\tAvgDaysHoldAP = sum(AvgDaysHoldAP, 0);\n\t\tAvgDaysHoldPE = sum(AvgDaysHoldPE, 0);\n\t\tAvgHoldIntrst = sum(AvgHoldIntrst, 0);\n\t\tAvgHoldIntrstAP = sum(AvgHoldIntrstAP, 0);\n\t\tAvgHoldIntrstPE = sum(AvgHoldIntrstPE, 0);\n\t\tAvgOpenIntRat = sum(AvgOpenIntRat, 0);\n\t\tAvgOpenIntRatAP = sum(AvgOpenIntRatAP, 0);\n\t\tAvgOpenIntRatPE = sum(AvgOpenIntRatPE, 0);\n\t\tFreq = sum(Freq, 0);\n\t\tfreq_n_ratio = sum(freq_n_ratio, 0);\n\t\tFreqAP = sum(FreqAP, 0);\n\t\tFreqB = sum(FreqB, 0);\n\t\tFreqBAP = sum(FreqBAP, 0);\n\t\tFreqBPE = sum(FreqBPE, 0);\n\t\tFreqLG = sum(FreqLG, 0);\n\t\tFreqLGAP = sum(FreqLGAP, 0);\n\t\tFreqLGPE = sum(FreqLGPE, 0);\n\t\tFreqNT = sum(FreqNT, 0);\n\t\tFreqNTAP = sum(FreqNTAP, 0);\n\t\tFreqNTPE = sum(FreqNTPE, 0);\n\t\tFreqOpen = sum(FreqOpen, 0);\n\t\tFreqOpenAP = sum(FreqOpenAP, 0);\n\t\tFreqOpenPE = sum(FreqOpenPE, 0);\n\t\tFreqPE = sum(FreqPE, 0);\n\t\tFreqS = sum(FreqS, 0);\n\t\tFreqSAP = sum(FreqSAP, 0);\n\t\tFreqSPE = sum(FreqSPE, 0);\n\t\tFreqST = sum(FreqST, 0);\n\t\tFreqSTAP = sum(FreqSTAP, 0);\n\t\tFreqSTPE = sum(FreqSTPE, 0);\n\t\tFreqDb = sum(FreqDb, 0);\n\t\tFreqDN = sum(FreqDN, 0);\n\t\tFreqDS = sum(FreqDS, 0);\n\t\tFreqDbAP = sum(FreqDbAP, 0);\n\t\tFreqDNAP = sum(FreqDNAP, 0);\n\t\tFreqDSAP = sum(FreqDSAP, 0);\n\t\tFreqDbPE = sum(FreqDbPE, 0);\n\t\tFreqDNPE = sum(FreqDNPE, 0);\n\t\tFreqDSPE = sum(FreqDSPE, 0);\n\t\thold_buy_all = sum(hold_buy_all, 0);\n\t\thold_buy_sale_all = sum(hold_buy_sale_all, 0);\n\t\thold_SALE_all = sum(hold_SALE_all, 0);\n\t\tLG_hold = sum(LG_hold, 0);\n\t\tLG_holdAP = sum(LG_holdAP, 0);\n\t\tLG_run = sum(LG_run, 0);\n\t\tLG_runAP = sum(LG_runAP, 0);\n\t\tLGOpenRatio = sum(LGOpenRatio, 0);\n\t\tLGOpenRatioAP = sum(LGOpenRatioAP, 0);\n\t\tLGOpenRatioPE = sum(LGOpenRatioPE, 0);\n\t\tMaxDaysHold = sum(MaxDaysHold, 0);\n\t\tMaxDaysHoldAP = sum(MaxDaysHoldAP, 0);\n\t\tMaxDaysHoldPE = sum(MaxDaysHoldPE, 0);\n\t\tMaxHoldIntsrt = sum(MaxHoldIntsrt, 0);\n\t\tMaxHoldIntsrtAP = sum(MaxHoldIntsrtAP, 0);\n\t\tMaxHoldIntsrtPE = sum(MaxHoldIntsrtPE, 0);\n\t\tMaxOpenIntRat = sum(MaxOpenIntRat, 0);\n\t\tMaxOpenIntRatAP = sum(MaxOpenIntRatAP, 0);\n\t\tMaxOpenIntRatPE = sum(MaxOpenIntRatPE, 0);\n\t\tminDaysHold = sum(minDaysHold, 0);\n\t\tminDaysHoldAP = sum(minDaysHoldAP, 0);\n\t\tminDaysHoldPE = sum(minDaysHoldPE, 0);\n\t\tMinHoldIntrst = sum(MinHoldIntrst, 0);\n\t\tMinHoldIntrstAP = sum(MinHoldIntrstAP, 0);\n\t\tMinHoldIntrstPE = sum(MinHoldIntrstPE, 0);\n\t\tMinOpenIntRat = sum(MinOpenIntRat, 0);\n\t\tMinOpenIntRatAP = sum(MinOpenIntRatAP, 0);\n\t\tMinOpenIntRatPE = sum(MinOpenIntRatPE, 0);\n\t\tNT_hold = sum(NT_hold, 0);\n\t\tNT_holdAP = sum(NT_holdAP, 0);\n\t\tNT_run = sum(NT_run, 0);\n\t\tNT_runAP = sum(NT_runAP, 0);\n\t\toth_freq = sum(oth_freq, 0);\n\t\toth_freq_b = sum(oth_freq_b, 0);\n\t\toth_freq_n = sum(oth_freq_n, 0);\n\t\toth_freq_s = sum(oth_freq_s, 0);\n\t\tST_hold = sum(ST_hold, 0);\n\t\tST_holdAP = sum(ST_holdAP, 0);\n\t\tST_run = sum(ST_run, 0);\n\t\tST_runAP = sum(ST_runAP, 0);\n\t\tTradeRatio = sum(TradeRatio, 0);\n\t\tfBuyqty = sum(fBuyqty, 0);\n\t\tfBuyVol = sum(fBuyVol, 0);\n\t\tfSellqty = sum(fSellqty, 0);\n\t\tfSellVol = sum(fSellVol, 0);\n\t\tlBuyqty = sum(lBuyqty, 0);\n\t\tlBuyVol = sum(lBuyVol, 0);\n\t\tlSellqty = sum(lSellqty, 0);\n\t\tlSellVol = sum(lSellVol, 0);\n\t\tNetBuy = sum(NetBuy, 0);\n\t\tNetBuyAP = sum(NetBuyAP, 0);\n\t\tNetBuyPE = sum(NetBuyPE, 0);\n\t\tNetVal = sum(NetVal, 0);\n\t\tNetValAP = sum(NetValAP, 0);\n\t\tNetValPE = sum(NetValPE, 0);\n\t\toth_buy = sum(oth_buy, 0);\n\t\toth_net_buy = sum(oth_net_buy, 0);\n\t\toth_sale = sum(oth_sale, 0);\n\t\tQTY = sum(QTY, 0);\n\t\tQTYAP = sum(QTYAP, 0);\n\t\tQtyB = sum(QtyB, 0);\n\t\tQtyBAP = sum(QtyBAP, 0);\n\t\tQtyBPE = sum(QtyBPE, 0);\n\t\tQtyBPO = sum(QtyBPO, 0);\n\t\tQTYPE = sum(QTYPE, 0);\n\t\tQtyS = sum(QtyS, 0);\n\t\tQtySAP = sum(QtySAP, 0);\n\t\tQtySPE = sum(QtySPE, 0);\n\t\tQtySPO = sum(QtySPO, 0);\n\t\tVal = sum(Val, 0);\n\t\tValAP = sum(ValAP, 0);\n\t\tValB = sum(ValB, 0);\n\t\tValBAP = sum(ValBAP, 0);\n\t\tValBPE = sum(ValBPE, 0);\n\t\tValPE = sum(ValPE, 0);\n\t\tValS = sum(ValS, 0);\n\t\tValSAP = sum(ValSAP, 0);\n\t\tValSPE = sum(ValSPE, 0);\n\t\tEntryBuy = sum(EntryBuy, 0);\n\t\tEntrySell = sum(EntrySell, 0);\n\t\tFreqRatio = sum(FreqRatio, 0);\n\t\tprofit = sum(profit, 0);\n\t\tPropSell = sum(PropSell, 0);\n\t\tNotprofBSe = sum(NotprofBSe, 0);\n\t\tif (FBuydt > Anndate) and valsap in (0, .) then BuyExcl = 1;\nrun;\n\n%macro rank (dsn = Tab, wgt = W_QtyBAP, var = QtyBAP, \nrank = r_QtyBAP, quintiles = 100, OUT = temp);\n\nPROC SQL ;\n\tCREATE TABLE temp AS SELECT &var,\n\tcount(&var) as &wgt\t \n\tFROM &dsn \n\tgroup by  &var\n\tORDER BY  &var;\nQUIT;\n\ndata _NULL_;\n\tset temp end=last;\n\tsumofwgt + &wgt;\n\tif last then call symput ('SUM', trim(left(put(sumofwgt, best.))));\nrun;\n\nproc sort data = temp;\n\tby &VAR;\nrun;\n\ndata temp;\n\tset temp;\n    drop sumofwgt;\n\tsumofwgt + &WGT;\n\t&rank = 0;\n\tdo i = 1 to (&quintiles - 1) ;\n\t\tif ((&rank = 0) and (sumofwgt le ((symget('SUM') * i)/&quintiles))) \n\t\tthen &rank = i;\n\tend;\n\tif (&rank = 0) then &rank = &quintiles;\n\t\tdrop i;\n\t*label &rank = \"Rank for the Variable: &VAR.\";\nrun;\n\nproc sort data = &dsn;\n\tby &VAR;\nrun;\n\n\ndata &dsn(drop = &wgt);\n\tmerge &dsn (in= a) temp (in=b);\n\tby &var;\n\tif a;\nrun;\n%mend rank;\n\n*Ranking;\noption mprint;\n/*%rank(dsn = Modelv1, wgt = W_AvgDaysHold, var = AvgDaysHold, rank = r_AvgDaysHold, quintiles = 1000, OUT = Temp)*/\n/*%rank(dsn = Modelv1, wgt = W_AvgDaysHoldAP, var = AvgDaysHoldAP, rank = r_AvgDaysHoldAP, quintiles = 1000, OUT = Temp)*/\n/*%rank(dsn = Modelv1, wgt = W_AvgDaysHoldPE, var = AvgDaysHoldPE, rank = r_AvgDaysHoldPE, quintiles = 1000, OUT = Temp)*/\n/*%rank(dsn = Modelv1, wgt = W_AvgHoldIntrst, var = AvgHoldIntrst, rank = r_AvgHoldIntrst, quintiles = 1000, OUT = Temp)*/\n/*%rank(dsn = Modelv1, wgt = W_AvgHoldIntrstAP, var = AvgHoldIntrstAP, rank = r_AvgHoldIntrstAP, quintiles = 1000, OUT = Temp)*/\n/*%rank(dsn = Modelv1, wgt = W_AvgHoldIntrstPE, var = AvgHoldIntrstPE, rank = r_AvgHoldIntrstPE, quintiles = 1000, OUT = Temp)*/\n/*%rank(dsn = Modelv1, wgt = W_AvgOpenIntRat, var = AvgOpenIntRat, rank = r_AvgOpenIntRat, quintiles = 1000, OUT = Temp)*/\n/*%rank(dsn = Modelv1, wgt = W_AvgOpenIntRatAP, var = AvgOpenIntRatAP, rank = r_AvgOpenIntRatAP, quintiles = 1000, OUT = Temp)*/\n/*%rank(dsn = Modelv1, wgt = W_AvgOpenIntRatPE, var = AvgOpenIntRatPE, rank = r_AvgOpenIntRatPE, quintiles = 1000, OUT = Temp)*/\n*;\n%rank(dsn = Modelv1, wgt = W_Freq, var = Freq, rank = r_Freq, quintiles = 1000, OUT = Temp)\n/*%rank(dsn = Modelv1, wgt = W_freq_n_ratio, var = freq_n_ratio, rank = r_freq_n_ratio, quintiles = 1000, OUT = Temp)*/\n%rank(dsn = Modelv1, wgt = W_FreqAP, var = FreqAP, rank = r_FreqAP, quintiles = 1000, OUT = Temp)\n/*%rank(dsn = Modelv1, wgt = W_FreqB, var = FreqB, rank = r_FreqB, quintiles = 1000, OUT = Temp)*/\n/*%rank(dsn = Modelv1, wgt = W_FreqBAP, var = FreqBAP, rank = r_FreqBAP, quintiles = 1000, OUT = Temp)*/\n/*%rank(dsn = Modelv1, wgt = W_FreqBPE, var = FreqBPE, rank = r_FreqBPE, quintiles = 1000, OUT = Temp)*/\n/*%rank(dsn = Modelv1, wgt = W_FreqLG, var = FreqLG, rank = r_FreqLG, quintiles = 1000, OUT = Temp)*/\n*;\n%rank(dsn = Modelv1, wgt = W_FreqLGAP, var = FreqLGAP, rank = r_FreqLGAP, quintiles = 1000, OUT = Temp)\n/*%rank(dsn = Modelv1, wgt = W_FreqLGPE, var = FreqLGPE, rank = r_FreqLGPE, quintiles = 1000, OUT = Temp)*/\n*;\n%rank(dsn = Modelv1, wgt = W_FreqNT, var = FreqNT, rank = r_FreqNT, quintiles = 1000, OUT = Temp)\n/*%rank(dsn = Modelv1, wgt = W_FreqNTAP, var = FreqNTAP, rank = r_FreqNTAP, quintiles = 1000, OUT = Temp)*/\n/*%rank(dsn = Modelv1, wgt = W_FreqNTPE, var = FreqNTPE, rank = r_FreqNTPE, quintiles = 1000, OUT = Temp)*/\n/*%rank(dsn = Modelv1, wgt = W_FreqOpen, var = FreqOpen, rank = r_FreqOpen, quintiles = 1000, OUT = Temp)*/\n/*%rank(dsn = Modelv1, wgt = W_FreqOpenAP, var = FreqOpenAP, rank = r_FreqOpenAP, quintiles = 1000, OUT = Temp)*/\n/*%rank(dsn = Modelv1, wgt = W_FreqOpenPE, var = FreqOpenPE, rank = r_FreqOpenPE, quintiles = 1000, OUT = Temp)*/\n/*%rank(dsn = Modelv1, wgt = W_FreqPE, var = FreqPE, rank = r_FreqPE, quintiles = 1000, OUT = Temp)*/\n/*%rank(dsn = Modelv1, wgt = W_FreqS, var = FreqS, rank = r_FreqS, quintiles = 1000, OUT = Temp)*/\n/*%rank(dsn = Modelv1, wgt = W_FreqSAP, var = FreqSAP, rank = r_FreqSAP, quintiles = 1000, OUT = Temp)*/\n/*%rank(dsn = Modelv1, wgt = W_FreqSPE, var = FreqSPE, rank = r_FreqSPE, quintiles = 1000, OUT = Temp)*/\n/*%rank(dsn = Modelv1, wgt = W_FreqST, var = FreqST, rank = r_FreqST, quintiles = 1000, OUT = Temp)*/\n/*%rank(dsn = Modelv1, wgt = W_FreqSTAP, var = FreqSTAP, rank = r_FreqSTAP, quintiles = 1000, OUT = Temp)*/\n*;\n%rank(dsn = Modelv1, wgt = W_FreqSTPE, var = FreqSTPE, rank = r_FreqSTPE, quintiles = 1000, OUT = Temp)\n/*%rank(dsn = Modelv1, wgt = W_hold_buy_all, var = hold_buy_all, rank = r_hold_buy_all, quintiles = 1000, OUT = Temp)*/\n/*%rank(dsn = Modelv1, wgt = W_hold_buy_sale_all, var = hold_buy_sale_all, rank = r_hold_buy_sale_all, quintiles = 1000, OUT = Temp)*/\n/*%rank(dsn = Modelv1, wgt = W_hold_SALE_all, var = hold_SALE_all, rank = r_hold_SALE_all, quintiles = 1000, OUT = Temp)*/\n/*%rank(dsn = Modelv1, wgt = W_LG_hold, var = LG_hold, rank = r_LG_hold, quintiles = 1000, OUT = Temp)*/\n/*%rank(dsn = Modelv1, wgt = W_LG_holdAP, var = LG_holdAP, rank = r_LG_holdAP, quintiles = 1000, OUT = Temp)*/\n/*%rank(dsn = Modelv1, wgt = W_LG_run, var = LG_run, rank = r_LG_run, quintiles = 1000, OUT = Temp)*/\n/*%rank(dsn = Modelv1, wgt = W_LG_runAP, var = LG_runAP, rank = r_LG_runAP, quintiles = 1000, OUT = Temp)*/\n/*%rank(dsn = Modelv1, wgt = W_LGOpenRatio, var = LGOpenRatio, rank = r_LGOpenRatio, quintiles = 1000, OUT = Temp)*/\n*;\n%rank(dsn = Modelv1, wgt = W_LGOpenRatioAP, var = LGOpenRatioAP, rank = r_LGOpenRatioAP, quintiles = 1000, OUT = Temp)\n/*%rank(dsn = Modelv1, wgt = W_LGOpenRatioPE, var = LGOpenRatioPE, rank = r_LGOpenRatioPE, quintiles = 1000, OUT = Temp)*/\n/*%rank(dsn = Modelv1, wgt = W_MaxDaysHold, var = MaxDaysHold, rank = r_MaxDaysHold, quintiles = 1000, OUT = Temp)*/\n/*%rank(dsn = Modelv1, wgt = W_MaxDaysHoldAP, var = MaxDaysHoldAP, rank = r_MaxDaysHoldAP, quintiles = 1000, OUT = Temp)*/\n/*%rank(dsn = Modelv1, wgt = W_MaxDaysHoldPE, var = MaxDaysHoldPE, rank = r_MaxDaysHoldPE, quintiles = 1000, OUT = Temp)*/\n/*%rank(dsn = Modelv1, wgt = W_MaxHoldIntsrt, var = MaxHoldIntsrt, rank = r_MaxHoldIntsrt, quintiles = 1000, OUT = Temp)*/\n/*%rank(dsn = Modelv1, wgt = W_MaxHoldIntsrtAP, var = MaxHoldIntsrtAP, rank = r_MaxHoldIntsrtAP, quintiles = 1000, OUT = Temp)*/\n/*%rank(dsn = Modelv1, wgt = W_MaxHoldIntsrtPE, var = MaxHoldIntsrtPE, rank = r_MaxHoldIntsrtPE, quintiles = 1000, OUT = Temp)*/\n/*%rank(dsn = Modelv1, wgt = W_MaxOpenIntRat, var = MaxOpenIntRat, rank = r_MaxOpenIntRat, quintiles = 1000, OUT = Temp)*/\n/*%rank(dsn = Modelv1, wgt = W_MaxOpenIntRatAP, var = MaxOpenIntRatAP, rank = r_MaxOpenIntRatAP, quintiles = 1000, OUT = Temp)*/\n/*%rank(dsn = Modelv1, wgt = W_MaxOpenIntRatPE, var = MaxOpenIntRatPE, rank = r_MaxOpenIntRatPE, quintiles = 1000, OUT = Temp)*/\n/*%rank(dsn = Modelv1, wgt = W_minDaysHold, var = minDaysHold, rank = r_minDaysHold, quintiles = 1000, OUT = Temp)*/\n/*%rank(dsn = Modelv1, wgt = W_minDaysHoldAP, var = minDaysHoldAP, rank = r_minDaysHoldAP, quintiles = 1000, OUT = Temp)*/\n/*%rank(dsn = Modelv1, wgt = W_minDaysHoldPE, var = minDaysHoldPE, rank = r_minDaysHoldPE, quintiles = 1000, OUT = Temp)*/\n/*%rank(dsn = Modelv1, wgt = W_MinHoldIntrst, var = MinHoldIntrst, rank = r_MinHoldIntrst, quintiles = 1000, OUT = Temp)*/\n/*%rank(dsn = Modelv1, wgt = W_MinHoldIntrstAP, var = MinHoldIntrstAP, rank = r_MinHoldIntrstAP, quintiles = 1000, OUT = Temp)*/\n/*%rank(dsn = Modelv1, wgt = W_MinHoldIntrstPE, var = MinHoldIntrstPE, rank = r_MinHoldIntrstPE, quintiles = 1000, OUT = Temp)*/\n/*%rank(dsn = Modelv1, wgt = W_MinOpenIntRat, var = MinOpenIntRat, rank = r_MinOpenIntRat, quintiles = 1000, OUT = Temp)*/\n/*%rank(dsn = Modelv1, wgt = W_MinOpenIntRatAP, var = MinOpenIntRatAP, rank = r_MinOpenIntRatAP, quintiles = 1000, OUT = Temp)*/\n/*%rank(dsn = Modelv1, wgt = W_MinOpenIntRatPE, var = MinOpenIntRatPE, rank = r_MinOpenIntRatPE, quintiles = 1000, OUT = Temp)*/\n/*%rank(dsn = Modelv1, wgt = W_NT_hold, var = NT_hold, rank = r_NT_hold, quintiles = 1000, OUT = Temp)*/\n/*%rank(dsn = Modelv1, wgt = W_NT_holdAP, var = NT_holdAP, rank = r_NT_holdAP, quintiles = 1000, OUT = Temp)*/\n/*%rank(dsn = Modelv1, wgt = W_NT_run, var = NT_run, rank = r_NT_run, quintiles = 1000, OUT = Temp)*/\n/*%rank(dsn = Modelv1, wgt = W_NT_runAP, var = NT_runAP, rank = r_NT_runAP, quintiles = 1000, OUT = Temp)*/\n/*%rank(dsn = Modelv1, wgt = W_oth_freq, var = oth_freq, rank = r_oth_freq, quintiles = 1000, OUT = Temp)*/\n/*%rank(dsn = Modelv1, wgt = W_oth_freq_b, var = oth_freq_b, rank = r_oth_freq_b, quintiles = 1000, OUT = Temp)*/\n/*%rank(dsn = Modelv1, wgt = W_oth_freq_n, var = oth_freq_n, rank = r_oth_freq_n, quintiles = 1000, OUT = Temp)*/\n/*%rank(dsn = Modelv1, wgt = W_oth_freq_s, var = oth_freq_s, rank = r_oth_freq_s, quintiles = 1000, OUT = Temp)*/\n*;\n%rank(dsn = Modelv1, wgt = W_ST_hold, var = ST_hold, rank = r_ST_hold, quintiles = 1000, OUT = Temp)\n/*%rank(dsn = Modelv1, wgt = W_ST_holdAP, var = ST_holdAP, rank = r_ST_holdAP, quintiles = 1000, OUT = Temp)*/\n/*%rank(dsn = Modelv1, wgt = W_ST_run, var = ST_run, rank = r_ST_run, quintiles = 1000, OUT = Temp)*/\n/*%rank(dsn = Modelv1, wgt = W_ST_runAP, var = ST_runAP, rank = r_ST_runAP, quintiles = 1000, OUT = Temp)*/\n/*%rank(dsn = Modelv1, wgt = W_TradeRatio, var = TradeRatio, rank = r_TradeRatio, quintiles = 1000, OUT = Temp)*/\n/*%rank(dsn = Modelv1, wgt = W_fBuyqty, var = fBuyqty, rank = r_fBuyqty, quintiles = 1000, OUT = Temp)*/\n/*%rank(dsn = Modelv1, wgt = W_fBuyVol, var = fBuyVol, rank = r_fBuyVol, quintiles = 1000, OUT = Temp)*/\n/*%rank(dsn = Modelv1, wgt = W_fSellqty, var = fSellqty, rank = r_fSellqty, quintiles = 1000, OUT = Temp)*/\n/*%rank(dsn = Modelv1, wgt = W_fSellVol, var = fSellVol, rank = r_fSellVol, quintiles = 1000, OUT = Temp)*/\n/*%rank(dsn = Modelv1, wgt = W_lBuyqty, var = lBuyqty, rank = r_lBuyqty, quintiles = 1000, OUT = Temp)*/\n/*%rank(dsn = Modelv1, wgt = W_lBuyVol, var = lBuyVol, rank = r_lBuyVol, quintiles = 1000, OUT = Temp)*/\n/*%rank(dsn = Modelv1, wgt = W_lSellqty, var = lSellqty, rank = r_lSellqty, quintiles = 1000, OUT = Temp)*/\n/*%rank(dsn = Modelv1, wgt = W_lSellVol, var = lSellVol, rank = r_lSellVol, quintiles = 1000, OUT = Temp)*/\n/*%rank(dsn = Modelv1, wgt = W_NetBuy, var = NetBuy, rank = r_NetBuy, quintiles = 1000, OUT = Temp)*/\n/*%rank(dsn = Modelv1, wgt = W_NetBuyAP, var = NetBuyAP, rank = r_NetBuyAP, quintiles = 1000, OUT = Temp)*/\n/*%rank(dsn = Modelv1, wgt = W_NetBuyPE, var = NetBuyPE, rank = r_NetBuyPE, quintiles = 1000, OUT = Temp)*/\n/*%rank(dsn = Modelv1, wgt = W_NetVal, var = NetVal, rank = r_NetVal, quintiles = 1000, OUT = Temp)*/\n/*%rank(dsn = Modelv1, wgt = W_NetValAP, var = NetValAP, rank = r_NetValAP, quintiles = 1000, OUT = Temp)*/\n*;\n%rank(dsn = Modelv1, wgt = W_NetValPE, var = NetValPE, rank = r_NetValPE, quintiles = 1000, OUT = Temp)\n/*%rank(dsn = Modelv1, wgt = W_oth_buy, var = oth_buy, rank = r_oth_buy, quintiles = 1000, OUT = Temp)*/\n/*%rank(dsn = Modelv1, wgt = W_oth_net_buy, var = oth_net_buy, rank = r_oth_net_buy, quintiles = 1000, OUT = Temp)*/\n/*%rank(dsn = Modelv1, wgt = W_oth_sale, var = oth_sale, rank = r_oth_sale, quintiles = 1000, OUT = Temp)*/\n/*%rank(dsn = Modelv1, wgt = W_QTY, var = QTY, rank = r_QTY, quintiles = 1000, OUT = Temp)*/\n/*%rank(dsn = Modelv1, wgt = W_QTYAP, var = QTYAP, rank = r_QTYAP, quintiles = 1000, OUT = Temp)*/\n/*%rank(dsn = Modelv1, wgt = W_QtyB, var = QtyB, rank = r_QtyB, quintiles = 1000, OUT = Temp)*/\n/*%rank(dsn = Modelv1, wgt = W_QtyBAP, var = QtyBAP, rank = r_QtyBAP, quintiles = 1000, OUT = Temp)*/\n/*%rank(dsn = Modelv1, wgt = W_QtyBPE, var = QtyBPE, rank = r_QtyBPE, quintiles = 1000, OUT = Temp)*/\n/*%rank(dsn = Modelv1, wgt = W_QTYPE, var = QTYPE, rank = r_QTYPE, quintiles = 1000, OUT = Temp)*/\n/*%rank(dsn = Modelv1, wgt = W_QtyS, var = QtyS, rank = r_QtyS, quintiles = 1000, OUT = Temp)*/\n/*%rank(dsn = Modelv1, wgt = W_QtySAP, var = QtySAP, rank = r_QtySAP, quintiles = 1000, OUT = Temp)*/\n/*%rank(dsn = Modelv1, wgt = W_QtySPE, var = QtySPE, rank = r_QtySPE, quintiles = 1000, OUT = Temp)*/\n/*%rank(dsn = Modelv1, wgt = W_Val, var = Val, rank = r_Val, quintiles = 1000, OUT = Temp)*/\n%rank(dsn = Modelv1, wgt = W_ValAP, var = ValAP, rank = r_ValAP, quintiles = 1000, OUT = Temp)\n/*%rank(dsn = Modelv1, wgt = W_ValB, var = ValB, rank = r_ValB, quintiles = 1000, OUT = Temp)*/\n/*%rank(dsn = Modelv1, wgt = W_ValBAP, var = ValBAP, rank = r_ValBAP, quintiles = 1000, OUT = Temp)*/\n/*%rank(dsn = Modelv1, wgt = W_ValBPE, var = ValBPE, rank = r_ValBPE, quintiles = 1000, OUT = Temp)*/\n/*%rank(dsn = Modelv1, wgt = W_ValPE, var = ValPE, rank = r_ValPE, quintiles = 1000, OUT = Temp)*/\n/*%rank(dsn = Modelv1, wgt = W_ValS, var = ValS, rank = r_ValS, quintiles = 1000, OUT = Temp)*/\n/*%rank(dsn = Modelv1, wgt = W_ValSAP, var = ValSAP, rank = r_ValSAP, quintiles = 1000, OUT = Temp)*/\n/*%rank(dsn = Modelv1, wgt = W_ValSPE, var = ValSPE, rank = r_ValSPE, quintiles = 1000, OUT = Temp)*/\n*;\n%rank(dsn = Modelv1, wgt = W_NotProf, var = NotProf, rank = r_NotProf, quintiles = 1000, OUT = Temp)\n*;\n%rank(dsn = Modelv1, wgt = W_dsfbuy, var = dsfbuy, rank = r_dsfbuy, quintiles = 1000, OUT = Temp)\n/*%rank(dsn = Modelv1, wgt = W_dsfsell, var = dsfsell, rank = r_dsfsell, quintiles = 1000, OUT = Temp)*/\n/*%rank(dsn = Modelv1, wgt = W_dslbuy, var = dslbuy, rank = r_dslbuy, quintiles = 1000, OUT = Temp)*/\n/*%rank(dsn = Modelv1, wgt = W_dslsell, var = dslsell, rank = r_dslsell, quintiles = 1000, OUT = Temp)*/\n/*%rank(dsn = Modelv1, wgt = W_LG_avg_dur, var = LG_avg_dur, rank = r_LG_avg_dur, quintiles = 1000, OUT = Temp)*/\n/*%rank(dsn = Modelv1, wgt = W_LG_avg_durAP, var = LG_avg_durAP, rank = r_LG_avg_durAP, quintiles = 1000, OUT = Temp)*/\n/*%rank(dsn = Modelv1, wgt = W_NT_avg_dur, var = NT_avg_dur, rank = r_NT_avg_dur, quintiles = 1000, OUT = Temp)*/\n/*%rank(dsn = Modelv1, wgt = W_NT_avg_durAP, var = NT_avg_durAP, rank = r_NT_avg_durAP, quintiles = 1000, OUT = Temp)*/\n/*%rank(dsn = Modelv1, wgt = W_ST_avg_dur, var = ST_avg_dur, rank = r_ST_avg_dur, quintiles = 1000, OUT = Temp)*/\n/*%rank(dsn = Modelv1, wgt = W_ST_avg_durAP, var = ST_avg_durAP, rank = r_ST_avg_durAP, quintiles = 1000, OUT = Temp)*/\n/*%rank(dsn = Modelv1, wgt = W_QtyBPO, var = QtyBPO, rank = r_QtyBPO, quintiles = 1000, OUT = Temp)*/\n/*%rank(dsn = Modelv1, wgt = W_QtySPO, var = QtySPO, rank = r_QtySPO, quintiles = 1000, OUT = Temp)*/\n/*%rank(dsn = Modelv1, wgt = W_NetBuyPo, var = NetBuyPo, rank = r_NetBuyPo, quintiles = 1000, OUT = Temp)*/\n*;\n%rank(dsn = Modelv1, wgt = W_Profit, var = Profit, rank = r_Profit, quintiles = 1000, OUT = Temp)\n\n\ndata Model&scripcd;\n\tset Modelv1;\n\tdrop dsfbuy\tdsfsell\tdslbuy\tdslsell\tLG_avg_dur\tLG_avg_durAP\t\n\t\tNT_avg_dur\tNT_avg_durAP\tST_avg_dur\tST_avg_durAP\t\n\t\tExitBuy\tExitSell\tfBuyqty\tfBuyVol\tfSellqty\tfSellVol\t\n\t\tlBuyqty\tlBuyVol\tlSellqty\tlSellVol\tNetBuy\tNetBuyAP\t\n\t\tNetBuyPE\tNetVal\tNetValAP\tNetValPE\toth_buy\t\n\t\toth_net_buy\toth_sale\tQTY\tQTYAP\tQtyB\tQtyBAP\tQtyBPE\t\n\t\tQTYPE\tQtyS\tQtySAP\tQtySPE\tVal\tValAP\tValB\tValBAP\t\n\t\tValBPE\tValPE\tValS\tValSAP\tValSPE  NetbuyPO Profit;\n/*\tr_AvgDaysHold =r_AvgDaysHold/10;*/\n/*\tr_AvgDaysHoldAP =r_AvgDaysHoldAP/10;*/\n/*\tr_AvgDaysHoldPE =r_AvgDaysHoldPE/10;*/\n/*\tr_AvgHoldIntrst =r_AvgHoldIntrst/10;*/\n/*\tr_AvgHoldIntrstAP =r_AvgHoldIntrstAP/10;*/\n/*\tr_AvgHoldIntrstPE =r_AvgHoldIntrstPE/10;*/\n/*\tr_AvgOpenIntRat =r_AvgOpenIntRat/10;*/\n/*\tr_AvgOpenIntRatAP =r_AvgOpenIntRatAP/10;*/\n/*\tr_AvgOpenIntRatPE =r_AvgOpenIntRatPE/10;*/\n*;\n\tr_Freq =r_Freq/10;\n\tr_FreqAP =r_FreqAP/10;\n/*\tr_FreqB =r_FreqB/10;*/\n/*\tr_FreqBAP =r_FreqBAP/10;*/\n/*\tr_FreqBPE =r_FreqBPE/10;*/\n/*\tr_FreqLG =r_FreqLG/10;*/\n*;\n\tr_FreqLGAP =r_FreqLGAP/10;\n/*\tr_FreqLGPE =r_FreqLGPE/10;*/\n*;\n\tr_FreqNT =r_FreqNT/10;\n/*\tr_FreqNTAP =r_FreqNTAP/10;*/\n/*\tr_FreqNTPE =r_FreqNTPE/10;*/\n/*\tr_FreqOpen =r_FreqOpen/10;*/\n/*\tr_FreqOpenAP =r_FreqOpenAP/10;*/\n/*\tr_FreqOpenPE =r_FreqOpenPE/10;*/\n/*\tr_FreqPE =r_FreqPE/10;*/\n/*\tr_FreqS =r_FreqS/10;*/\n/*\tr_FreqSAP =r_FreqSAP/10;*/\n/*\tr_FreqSPE =r_FreqSPE/10;*/\n/*\tr_FreqST =r_FreqST/10;*/\n/*\tr_FreqSTAP =r_FreqSTAP/10;*/\n*;\n\tr_FreqSTPE =r_FreqSTPE/10;\n/*\tr_LGOpenRatio =r_LGOpenRatio/10;*/\n*;\n\tr_LGOpenRatioAP =r_LGOpenRatioAP/10;\n/*\tr_LGOpenRatioPE =r_LGOpenRatioPE/10;*/\n/*\tr_LG_avg_dur =r_LG_avg_dur/10;*/\n/*\tr_LG_avg_durAP =r_LG_avg_durAP/10;*/\n/*\tr_LG_hold =r_LG_hold/10;*/\n/*\tr_LG_holdAP =r_LG_holdAP/10;*/\n/*\tr_LG_run =r_LG_run/10;*/\n/*\tr_LG_runAP =r_LG_runAP/10;*/\n/*\tr_MaxDaysHold =r_MaxDaysHold/10;*/\n/*\tr_MaxDaysHoldAP =r_MaxDaysHoldAP/10;*/\n/*\tr_MaxDaysHoldPE =r_MaxDaysHoldPE/10;*/\n/*\tr_MaxHoldIntsrt =r_MaxHoldIntsrt/10;*/\n/*\tr_MaxHoldIntsrtAP =r_MaxHoldIntsrtAP/10;*/\n/*\tr_MaxHoldIntsrtPE =r_MaxHoldIntsrtPE/10;*/\n/*\tr_MaxOpenIntRat =r_MaxOpenIntRat/10;*/\n/*\tr_MaxOpenIntRatAP =r_MaxOpenIntRatAP/10;*/\n/*\tr_MaxOpenIntRatPE =r_MaxOpenIntRatPE/10;*/\n/*\tr_MinHoldIntrst =r_MinHoldIntrst/10;*/\n/*\tr_MinHoldIntrstAP =r_MinHoldIntrstAP/10;*/\n/*\tr_MinHoldIntrstPE =r_MinHoldIntrstPE/10;*/\n/*\tr_MinOpenIntRat =r_MinOpenIntRat/10;*/\n/*\tr_MinOpenIntRatAP =r_MinOpenIntRatAP/10;*/\n/*\tr_MinOpenIntRatPE =r_MinOpenIntRatPE/10;*/\n/*\tr_NT_avg_dur =r_NT_avg_dur/10;*/\n/*\tr_NT_avg_durAP =r_NT_avg_durAP/10;*/\n/*\tr_NT_hold =r_NT_hold/10;*/\n/*\tr_NT_holdAP =r_NT_holdAP/10;*/\n/*\tr_NT_run =r_NT_run/10;*/\n/*\tr_NT_runAP =r_NT_runAP/10;*/\n/*\tr_NetBuy =r_NetBuy/10;*/\n/*\tr_NetBuyAP =r_NetBuyAP/10;*/\n/*\tr_NetBuyPE =r_NetBuyPE/10;*/\n/*\tr_NetVal =r_NetVal/10;*/\n/*\tr_NetValAP =r_NetValAP/10;*/\n*;\n\tr_NetValPE =r_NetValPE/10;\n*;\n\tr_NotProf =r_NotProf/10;\n*;\n\tr_Profit = r_profit/10;\n/*\tr_QTY =r_QTY/10;*/\n/*\tr_QTYAP =r_QTYAP/10;*/\n/*\tr_QTYPE =r_QTYPE/10;*/\n/*\tr_QtyB =r_QtyB/10;*/\n/*\tr_QtyBAP =r_QtyBAP/10;*/\n/*\tr_QtyBPE =r_QtyBPE/10;*/\n/*\tr_QtyS =r_QtyS/10;*/\n/*\tr_QtySAP =r_QtySAP/10;*/\n/*\tr_QtySPE =r_QtySPE/10;*/\n/*\tr_ST_avg_dur =r_ST_avg_dur/10;*/\n/*\tr_ST_avg_durAP =r_ST_avg_durAP/10;*/\n*;\n\tr_ST_hold =r_ST_hold/10;\n/*\tr_ST_holdAP =r_ST_holdAP/10;*/\n/*\tr_ST_run =r_ST_run/10;*/\n/*\tr_ST_runAP =r_ST_runAP/10;*/\n/*\tr_TradeRatio =r_TradeRatio/10;*/\n/*\tr_Val =r_Val/10;*/\n\tr_ValAP =r_ValAP/10;\n/*\tr_ValB =r_ValB/10;*/\n/*\tr_ValBAP =r_ValBAP/10;*/\n/*\tr_ValBPE =r_ValBPE/10;*/\n/*\tr_ValPE =r_ValPE/10;*/\n/*\tr_ValS =r_ValS/10;*/\n/*\tr_ValSAP =r_ValSAP/10;*/\n/*\tr_ValSPE =r_ValSPE/10;*/\n*;\n\tr_dsfbuy =r_dsfbuy/10;\n/*\tr_dsfsell =r_dsfsell/10;*/\n/*\tr_dslbuy =r_dslbuy/10;*/\n/*\tr_dslsell =r_dslsell/10;*/\n/*\tr_fBuyVol =r_fBuyVol/10;*/\n/*\tr_fBuyqty =r_fBuyqty/10;*/\n/*\tr_fSellVol =r_fSellVol/10;*/\n/*\tr_fSellqty =r_fSellqty/10;*/\n/*\tr_freq_n_ratio =r_freq_n_ratio/10;*/\n/*\tr_hold_SALE_all =r_hold_SALE_all/10;*/\n/*\tr_hold_buy_all =r_hold_buy_all/10;*/\n/*\tr_hold_buy_sale_all =r_hold_buy_sale_all/10;*/\n/*\tr_lBuyVol =r_lBuyVol/10;*/\n/*\tr_lBuyqty =r_lBuyqty/10;*/\n/*\tr_lSellVol =r_lSellVol/10;*/\n/*\tr_lSellqty =r_lSellqty/10;*/\n/*\tr_minDaysHold =r_minDaysHold/10;*/\n/*\tr_minDaysHoldAP =r_minDaysHoldAP/10;*/\n/*\tr_minDaysHoldPE =r_minDaysHoldPE/10;*/\n/*\tr_oth_buy =r_oth_buy/10;*/\n/*\tr_oth_freq =r_oth_freq/10;*/\n/*\tr_oth_freq_b =r_oth_freq_b/10;*/\n/*\tr_oth_freq_n =r_oth_freq_n/10;*/\n/*\tr_oth_freq_s =r_oth_freq_s/10;*/\n/*\tr_oth_net_buy =r_oth_net_buy/10;*/\n/*\tr_oth_sale =r_oth_sale/10;*/\n/*\tr_QtyBPO = r_QtyBPO/10;*/\n/*\tr_QtySPO = r_QtySPO/10;*/\n/*\tr_NetBuyPo = r_NetBuyPo/10;*/\nRUN;\n\n/*-----------End of ABT Creation-----------*/\n\n/*\tselect */\n/*\ta.*, */\n/*\tcat(a.PannoAP, a.scripcd) as IDTot,*/\n/*\tcase*/\n/*\t\twhen b.Panno is not null then 1*/\n/*\t\telse 0*/\n/*\tend as Insider*/\n/*\tfrom Insider_Totalv1 a left outer join tt.INSIDERPANS b*/\n/*\ton a.scripcd = b.scripcd and a.pannoAP = b.panno*/\n/*\twhere a.r_NotProf >= 90.0 and r_ValAP >= 50.0 and a.PannoAP is not null*/\n/*\torder by a.scripcd;*/\n\n/*Scoring the scrip*/\nproc sql;\n\tcreate table TestVal as\n\tselect\n\t\tcat(a.PannoAP, a.scripcd) as IDTot,\n\t\ta.scripcd,\n\t\ta.pannoap,\n\t\ta.FreqLGAP,\n\t\ta.LGOpenRatio format 10.2,\n\t\ta.freqAP,\n\t\ta.r_freqAP,\n\t\tLog(a.MaxDaysHold + 1) as LogMaxDayHold  format 10.2,\n\t\tLog(a.MaxopenintRat + 1) as LogMaxopenintRat format 10.2,\n\t\tLog(a.MinHoldIntrst + 1) as LogMinHoldInst format 10.2,\n\t\tLog(a.MinHoldIntrstPE + 1) as LogMinHoldInstPE format 10.2,\n\t\tlog(a.mindaysholdAP + 1) as logmindayholdAP format 10.2,\n\t\ta.r_Freq,\n\t\ta.r_FreqLGAP,\n\t\ta.r_FreqNT,\n\t\ta.r_FreqSTPE,\n\t\ta.r_LGOpenRatioAP,\n\t\ta.r_NetValPE,\n\t\ta.r_NotProf,\n\t\ta.r_ST_hold,\n\t\ta.r_dsfbuy,\n\t\ta.r_profit,\n\t\ta.freqNTAP,\n\t\ta.QtySPO format comma10.0,\n\t\ta.QtyBPO format comma10.0,\n\t\ta.PropBuyPE format 10.2,\n\t\ta.PropBuyPo format 10.2,\n\t\ta.PropSell format 10.2,\n\t\ta.anndate, \n\t\ta.fbuydt, \n\t\ta.FreqBAP, \n\t\ta.FreqSAP, \n\t\ta.fselldt,\n\t\ta.freqdnap,\n\t\ta.notprof format comma10.0,\n\t\ta.NotprofBSe format comma10.0,\n/*\t\t***  Effect: FreqLGAP ;*/\n\t\t-0.12834041446128 * a.FreqLGAP as eFreqLGAP,\n/*\t\t***  Effect: LGOpenRatio ;*/\n\t\t9.35171677320432 * a.LGOpenRatio as eLGOpenRatio,\n/*\t\t***  Effect: LogMaxDayHold ;*/\n\t\t0.50721933937774 * calculated LogMaxDayHold as eLogMaxDayHold,\n/*\t\t***  Effect: LogMaxopenintRat ;*/\n\t\t0.50647075156291 * calculated LogMaxopenintRat as eLogMaxopenintRat,\n/*\t\t***  Effect: LogMinHoldInst ;*/\n\t\t-0.41578799362144 * calculated LogMinHoldInst as eLogMinHoldInst,\n/*\t\t***  Effect: LogMinHoldInstPE ;*/\n\t\t0.33056824248213 * calculated LogMinHoldInstPE as eLogMinHoldInstPE,\n/*\t\t***  Effect: logmindayholdAP ;*/\n\t\t0.30009596072814 * calculated logmindayholdAP as elogmindayholdAP,\n/*\t\t***  Effect: r_Freq ;*/\n\t\t0.04775158362027 * a.r_Freq as er_Freq,\n/*\t\t***  Effect: r_FreqLGAP ;*/\n\t\t-0.07847124677054 * a.r_FreqLGAP as er_FreqLGAP,\n/*\t\t***  Effect: r_FreqNT ;*/\n\t\t-0.04362903766159 * a.r_FreqNT as er_FreqNT,\n/*\t\t***  Effect: r_FreqSTPE ;*/\n\t\t0.06488499557156 * a.r_FreqSTPE as er_FreqSTPE,\n/*\t\t***  Effect: r_LGOpenRatioAP ;*/\n\t\t-0.15819735875969 * a.r_LGOpenRatioAP as er_LGOpenRatioAP,\n/*\t\t***  Effect: r_NetValPE ;*/\n\t\t0.02325929070143 * a.r_NetValPE as er_NetValPE,\n/*\t\t***  Effect: r_NotProf ;*/\n\t\t1.16144265698088 * a.r_NotProf as er_NotProf,\n/*\t\t***  Effect: r_ST_hold ;*/\n\t\t-0.07294345844204 * a.r_ST_hold as er_ST_hold,\n/*\t\t***  Effect: r_dsfbuy ;*/\n\t\t0.03202068081495 * a.r_dsfbuy as er_dsfbuy,\n/*\t\t*** Intercept;*/\n\t\t-118.931680520813 as eIntercept\n\t\tfrom Model&scripcd a\n\t\twhere a.r_NotProf >= 90.0 and r_ValAP >= 50.0 and a.PannoAP is not null\n\t\torder by a.scripcd;\nquit;\n\nproc sql;\n\tcreate table test as \n\tselect \n\t*,\n\tcase\n/*\t\twhen freqdnap >= 1 then \"day trader\"*/\n\t\twhen FreqSAP = 0 and fbuydt >= anndate then \"only buy & after event\"\n\t\twhen FreqBAP = 0 and PropSell > 0.80 then \"No buy and sell happen before event date\"\n\t\twhen FreqBAP = 0 and qtySPO = 0 then \"only sell & before event\"\n\t\twhen PropBuyPO >= 0.60 then \"mostly buy after event\"\n\t\twhen qtyBpo = 0 and QtySPO = 0 and PropBuyPE <= 0.75 then \"mostly sell before event\"\n\t\telse \"potential insider\"\n\tend as Waterfall,\n\t((-0.12834041446128 * FreqLGAP) +\n\t\t(9.35171677320432 * LGOpenRatio) +\n\t\t(0.50721933937774 * LogMaxDayHold) +\n\t\t(0.50647075156291 * LogMaxopenintRat) + \n\t\t(-0.41578799362144 * LogMinHoldInst) +\n\t\t(0.33056824248213 * LogMinHoldInstPE) +\n\t\t(0.30009596072814 * logmindayholdAP) +\n\t\t(0.04775158362027 * r_Freq) +\n\t\t(-0.07847124677054 * r_FreqLGAP) +\n\t\t(-0.04362903766159 * r_FreqNT) +\n\t\t(0.06488499557156 * r_FreqSTPE) +\n\t\t(-0.15819735875969 * r_LGOpenRatioAP) +\n\t\t(0.02325929070143 * r_NetValPE) +\n\t\t(1.16144265698088 * r_NotProf) + \n\t\t(-0.07294345844204 * r_ST_hold) +\n\t\t(0.03202068081495 * r_dsfbuy) +\n\t\t(-118.931680520813)) as x,\n\texp(calculated x) / (1 + exp(calculated x)) as px,\n\tcase\n\t\twhen calculated px >= 3/45 and calculated waterfall = \"potential insider\" then 1\n\t\telse 0\n\tEND AS Decision,\n\tcase\n\t\twhen calculated Decision = 0 then \"Not Insider\"\n\t\twhen calculated Decision = 1 and PropBuyPE < 0.10 and PropBuyPO < 0.60 then \"insider - possibly(sell)\"\n\t\twhen calculated Decision = 1 and qtyBpo = 0 and QtySPO = 0 and PropBuyPE > 0.75 then \"insider - possibly(buy)\"\n\t\telse \"Insider proper\"\n\tend as InsiderFine\n\tfrom TestVal\norder by scripcd, Decision desc, px desc;\nquit;\n\nproc sql noprint;\ncreate table intermed as\nselect * \nfrom test\nwhere waterfall = \"potential insider\"\norder by scripcd, Decision desc, px desc;\nquit;\n\nproc sql;\ncreate table Insiders&scripcd as\nselect \nMONOTONIC() AS RowNum,\na.*\nfrom intermed a, (select sum(decision) as Sumdesc from intermed) b\nwhere calculated rownum <= max(30, b.Sumdesc);\nquit;\n\n%let File = \"/home/sasdemo/bse_reports/ITf&scripcd.&date\";\n/*%let File = \"/SASDATA/DQ/Reports/ITf&scripcd.&date\";*/\n\n%report\n\nproc datasets library = work nolist;\n    delete ABT&scripcd.Raw ABTTEMPV1i;\nquit;\n\n/*proc datasets library = work nolist;*/\n/*    delete Date&Scripcd ABT&scripcd.Raw ABTTEMPV1i test1 cmcase ABTTempAPv1 ABTTempEPv1 ABTTempPEv1  */\n/*\t\t\tABTTempAPv2 ABTTempEPv2 ABTTempPEv2 LGrunAP LGrunPE LGrunEP */\n/*\t\t\tSTrunAP STrunEP STrunPE NTrunAP NTrunPE NTrunEP */\n/*\t\t\tABTTempAP ABTTempEP ABTTempPE ABTTempv3 ABTTempv4 ABTTempv1D Periodsl ABTTempv5 */\n/*\t\t\tPeriodbl Periodsl Periods Periodb OtherScrip&scripcd abt_&scripcd.v1 */\n/*\t\t\tabt_&scripcd Modelv1 Model&scripcd TestVal test intermed InsiderReportTemp */\n/*\t\t\tInsiders&scripcd;*/\n/*quit;*/\n\n\n%end;\n\n/*** IF UNFAVORABLE ***/\n\n\n\n%if &fav_Unfav = Dn or &fav_Unfav = Bb %then %do;\n\n%let FavTag = \"U\";\n\n%let PreAnn = \"%sysfunc(INTNX(Day, &anndate, -1), date9.)\"d;\n/*%let Preann = '&preann.'d;*/\n/*%put &anndate, &PreAnn;*/\n/*libname tt '/SASDATA/DQ';*/\n\nproc sql;\n\tcreate table ABT&scripcd.Raw as\n\tselect distinct\n\tmax(a.panno) as pannotemp,\n\tc.panno,\n\ta.Scripcd,\n\tdatepart(trandate) as trandate format = date9.,\n\tsum(TotBuyQty) as TotBuyQty,\n\tsum(TotSellQty) as TotSellQty,\n\tsum(TotBuyVal) as TotBuyVal,\n\tsum(TotSellVal) as TotSellVal,\n\tcalculated TotBuyVal ne 0 as BuyTag,\n\tcalculated TotSellVal ne 0 as SellTag,\n\tmax(b.no_of_shares_traded) as no_of_shares_traded,\n\tmax(net_turnover) as net_turnover,\n\tmax(close_rate) as Close_rate,\n\tmax(open_rate) as open_rate\n\tfrom ((tt.MEMBER_SCRIP_CLIENT_SUMMERY a left outer join tt.SCRIP_SUMMERY b \n\ton (datepart(a.trandate) = datepart(b.trade_date)) and (b.scrip_code = a.Scripcd))\n\tleft outer join tt.UCC_DIM_SAS c on a.clientcd = c.clientcode and a.membercd = c.brokercode)\n\twhere datepart(a.trandate)>= &APFirst and datepart(a.trandate) <= &APLast \n\tgroup by a.Scripcd, c.panno, calculated trandate;\nquit;\n\nproc sql;\n\tcreate table ABTTEMPV1i as\n\tselect * from ABT&scripcd.Raw\n\twhere scripcd = &scripcd\n\torder by panno, trandate;\nquit;\n\n\ndata ABTTEMPV1i;\n\tset ABTTEMPV1i;\n\tby panno;\n\tformat POST_ADJST_LONG_QUANTITY best8. POST_ADJST_SHORT_QUANTITY best8.;\n\tretain POST_ADJST_LONG_QUANTITY 0 POST_ADJST_SHORT_QUANTITY 0;\n\tif first.panno then do;\n\tPOST_ADJST_LONG_QUANTITY =0 ;\n\tPOST_ADJST_SHORT_QUANTITY =0;\n\tend;\n\tif sum(TotBuyQty, 0) > sum(TotSellQty, 0) then DayStatus = \"B\";\n\telse if sum(TotBuyQty, 0) < sum(TotSellQty, 0) then DayStatus = \"S\";\n\telse if sum(TotBuyQty, 0) = sum(TotSellQty, 0) then DayStatus = \"N\";\n\tif TotBuyQty > TotSellQty then do;\n\tPOST_ADJST_LONG_QUANTITY = max(sum(POST_ADJST_LONG_QUANTITY, TotBuyQty, - TotSellQty, - POST_ADJST_SHORT_QUANTITY),0);\n\tPOST_ADJST_short_QUANTITY = max(sum(POST_ADJST_short_QUANTITY, -TotBuyQty, TotSellQty),0);\n\tend;\n\telse do;\n\tPOST_ADJST_SHORT_QUANTITY = max(sum(POST_ADJST_SHORT_QUANTITY, TotSellQty, - TotBuyQty, - POST_ADJST_long_QUANTITY),0);\n\tPOST_ADJST_LONG_QUANTITY = max(sum(POST_ADJST_LONG_QUANTITY, - TotSellQty, TotBuyQty),0);\n\tend;\n\tif POST_ADJST_LONG_QUANTITY = POST_ADJST_SHORT_QUANTITY then type_intrst='NT';\n\telse if POST_ADJST_LONG_QUANTITY > POST_ADJST_SHORT_QUANTITY then type_intrst='LG';\n\telse if POST_ADJST_LONG_QUANTITY < POST_ADJST_SHORT_QUANTITY then type_intrst='ST';\n\topen_intrst= ABS(POST_ADJST_LONG_QUANTITY - POST_ADJST_SHORT_QUANTITY);\n\tif sum(POST_ADJST_LONG_QUANTITY ,- POST_ADJST_SHORT_QUANTITY) > 0 and TotBuyQty ne 0 then\n\thold_INTRST = (sum(POST_ADJST_LONG_QUANTITY, -POST_ADJST_SHORT_QUANTITY)/no_of_shares_traded);\n\telse HOLD_INTRST=0;\n\tif sum(TotBuyQty,-TotSellQty)>0 and TotBuyQty ne 0 then\n\tdays_hold = ((sum(TotBuyQty,-TotSellQty)) / no_of_shares_traded);\n\tELSE days_hold = 0;\n\tOpenIntrstRat = open_intrst/no_of_shares_traded;\nrun;\n\nproc sort data = ABTTEMPV1i;\n\tby panno trandate;\nrun;\n\ndata test1;\n\tset ABTTEMPV1i (KEEP= type_intrst trandate);\n\trename type_intrst = nxt_type_intrst ;\n\trename trandate = nxt_date ;\n\tif _n_ not = 1 ;\nrun;\n\ndata cmcase;\n\tmerge ABTTEMPV1i test1;\nrun;\n\nproc sort data = cmcase;\n\tby panno trandate;\nrun;\n\n%macro ABTTemp(First, Last, Period, s);\n\ndata ABTTemp&Period.v1;\n\tset cmcase (where = (trandate BETWEEN &first AND &last));\n\tBY panno;\n\tretain fdate 0;\n\tformat dur best8.;\n\tformat tdate fdate date9.;\n\tif first.panno or type_intrst ne lag1(type_intrst) then count1 = 0;\n\telse count1 + 1;\n/*\tEPLast = &EPLast;*/\n\tif last.panno then tDate = &last;\n\telse tDate = trandate;\n\tif first.panno or type_intrst ne lag1(type_intrst) then fdate = trandate;\n\telse fdate = fdate;\n\tif last.panno or type_intrst ne nxt_type_intrst then dur = (tdate - fdate);\n\tif last.panno or type_intrst ne nxt_type_intrst then count = count1;\nrun;\n\nproc sql;\n\n\tcreate table ABTTemp&Period.v2 as\n\tselect\n\tpanno as panno1&s,\n\ttype_intrst as type_intrst&s,\n\tsum(dur) as dur,\n\tcount(dur) as run,\n\t(&Last - &first) as PLenght,\n\t(calculated dur/ (&Last - &first)) as hold_dur,\n\t((calculated dur)/(calculated run)) as avg_dur\n\tfrom ABTTemp&Period.v1\n\tgroup by panno, type_intrst;\n\nquit;\n\ndata LGrun&period (keep = panno1&s LG:)\n\tSTrun&period (keep = panno1&s  ST:)\n\tNTrun&period (keep = panno1&s  NT:);\nset ABTTemp&Period.v2;\n\nif type_intrst&s= 'LG' then do ;\n  LG_dur&s = dur;\n  LG_avg_dur&s=avg_dur;\n  LG_run&s=run;\n  LG_hold&s=hold_dur;\n  output LGrun&period;\nend;\nelse if type_intrst&s= 'NT' then do ;\n  NT_dur&s = dur;\n  NT_avg_dur&s=avg_dur;\n  NT_run&s=run;\n  NT_hold&s=hold_dur;\n  output NTrun&period;\n end;\n else if type_intrst&s= 'ST' then do ;\n  ST_dur&s = dur;\n  ST_avg_dur&s=avg_dur;\n  ST_run&s=run;\n  ST_hold&s=hold_dur;\n  output STrun&period;\n end;\nrun;\n\nproc sql;\n\tcreate table ABTTemp&Period as \n\tselect\n\tpanno as panno&s,\n\tsum(TotBuyQty) as QtyB&s,\n\tsum(TotSellQty) as QtyS&s,\n\tsum(TotBuyVal) as ValB&s,\n\tsum(TotSellVal) as ValS&s,\n\tsum(TotBuyVal ne 0) as FreqB&s,\n\tsum(TotSellVal ne 0) as FreqS&s,\n\t(calculated QtyB&s + calculated QtyS&s) as QTY&s,\n\t(calculated QtyS&s - calculated QtyB&s) as NetSell&s,\n\t(calculated ValB&s + calculated VAlS&s) as Val&s,\n\t(calculated VAlS&s - calculated ValB&s) as NetValSell&s,\n\t(calculated FreqB&s + calculated FreqS&s) as Freq&s,\n\tsum(type_intrst = 'NT') as FreqNT&s,\n\tsum(type_intrst = 'LG') as FreqLG&s,\n\tsum(type_intrst = 'ST') as FreqST&s,\n\tsum(DayStatus = 'B') as FreqDB&s,\n\tsum(DayStatus = 'S') as FreqDS&s,\n\tsum(DayStatus = 'N') as FreqDN&s,\n\tcount(panno) as FreqOpen&s,\n\t(calculated FreqLG&s)/(calculated FreqOpen&s) as LGOpenRatio&s,\n\t1000000 * avg(hold_intrst) as AvgHoldIntrst&s format = 10.4,\n\t1000000 * max(hold_intrst) as MaxHoldIntsrt&s format = 10.4,\n\t1000000 * min(hold_intrst) as MinHoldIntrst&s format = 10.4,\n\t1000000 * avg(OpenIntrstRat) as AvgOpenIntRat&s format = 10.4,\n\t1000000 * max(OpenIntrstRat) as MaxOpenIntRat&s format = 10.4,\n\t1000000 * min(OpenIntrstRat) as MinOpenIntRat&s format = 10.4,\n\t1000000 * avg(days_hold) as AvgDaysHold&s format = 10.4,\n\t1000000 * max(Days_hold) as MaxDaysHold&s format = 10.4,\n\t1000000 * min(days_hold) as minDaysHold&s format = 10.4\n\tfrom ABTTemp&Period.v1\n\tgroup by panno; \n\nquit;\n\n%mend AbtTemp;\noption mprint;\n%abttemp(&EPFirst, &EPLast, EP, )\n%abttemp(&APFirst, &APLast, AP, AP)\n%abttemp(&EPFirst, &PreAnn, PE, PE)\n%abttemp(&APFirst, &PreAnn, PEB, PEB)\n%abttemp(&anndate, &ApLAst, PO, PO)\n\nproc sql;\n\tcreate table ABTTempv3 as\n\tselect distinct\n\ta.*, b.*, c.*, d.*, e.*, f.*, g.*, h.*, i.*, j.*,k.*\n\tfrom ((((((((((ABTTEMPEP a right outer join ABTTEMPAP b on a.panno = b.pannoap)\n\t\t\t\t\t\tleft outer join ABTTEMPPE i on b.pannoap = i.pannoPE)\n\t\t\t\t\t\tleft outer join ABTTEMPPO j on b.pannoap = j.pannoPo)\n\t\t\t\t\t\tleft outer join ABTTEMPPEB k on b.pannoap = k.pannoPEB)\n\t\t\t\t\t\tleft outer join LGRUNAP c on b.pannoap = c.panno1Ap)\n\t\t\t\t\t\tleft outer join LGRUNEP d on b.pannoap = d.panno1)\n\t\t\t\t\t\tleft outer join NTRUNAP e on b.pannoap = e.panno1ap)\n\t\t\t\t\t\tleft outer join NTRUNEP f on b.pannoap = f.panno1)\n\t\t\t\t\t\tleft outer join STRUNAP g on b.pannoap = g.panno1ap)\n\t\t\t\t\t\tleft outer join STRUNEP h on b.pannoap = h.panno1)\n\t;\nquit;\n\ndata ABTTempv3;\n\tset ABTTempv3;\n\tdrop panno1 panno1AP panno pannoPE;\nrun;\n\nproc sort data = ABTTEMPV1i (where = (buytag ne 0)) nodupkey out = Periodb;\n\tby panno buytag;\nrun;\n\nproc sort data = ABTTEMPV1i (where = (selltag ne 0)) nodupkey out = Periods;\n\tby panno selltag;\nrun;\n\n\nproc sql;\n\tcreate table ABTTempv4 as \n\tselect distinct\n\ta.*, \n\t(&AnnDate - &ApFirst) as Preevnt,\n\tb.totsellqty as fSellqty,\n\tb.totsellval as fSellVol,\n\tb.trandate as Fselldt,\n\t(b.trandate - &APFirst) as dsfsell,\n\t(calculated dsfsell)/(calculated Preevnt) as EntrySell,\n\tc.totbuyqty as fBuyqty,\n\tc.totbuyval as fBuyVol,\n\tc.trandate as FBuydt,\n\t(c.trandate - &APFirst) as dsfbuy,\n\t(calculated dsfbuy)/(calculated Preevnt) as EntryBuy\n\tfrom ((ABTTempv3 a left outer join Periods b on a.pannoAP = b.panno)\n\t\t\t\t\t\tleft outer join Periodb c on a.pannoAP = c.panno);\nquit;\n\nproc sort data= ABTTEMPV1i out=ABTTempv1D;\n\tby panno descending trandate ;\nrun;\n\nproc sort data = ABTTempv1D (where = (buytag ne 0)) nodupkey out = Periodbl;\n\tby panno buytag;\nrun;\n\nproc sort data = ABTTempv1D (where = (selltag ne 0)) nodupkey out = Periodsl;\n\tby panno selltag;\nrun;\n\nproc sql;\n\tcreate table ABTTempv5 as \n\tselect distinct\n\ta.*, \n\tb.totsellqty as lSellqty,\n\tb.totsellval as lSellVol,\n\tb.trandate as lselldt,\n\t(b.trandate - &APFirst) as dslsell,\n\t(calculated dslsell)/Preevnt as ExitSell,\n\tc.totbuyqty as lBuyqty,\n\tc.totbuyval as lBuyVol,\n\tc.trandate as lBuydt,\n\t(c.trandate - &APFirst) as dslbuy,\n\t(calculated dslbuy)/Preevnt as ExitBuy,\n\tnetSellAP as OverAllNetSell,\n\tcase when qty = . then 0 else Qty/QtyAp end as TradeRatio,\n\tcase when Freq = . then 0 else Freq/FreqAP end as FreqRatio\n\tfrom ((ABTTempv4 a left outer join Periodsl b on a.pannoAP = b.panno)\n\t\t\t\t\t\tleft outer join Periodbl c on a.pannoAP = c.panno);\n\n\n\tcreate table OtherScrip&scripcd as\n\tselect \n\tpanno,\n\tsum(TotBuyQty) as oth_buy,\n\tsum(TotSellQty) as oth_sale,\n\t(calculated oth_sale - calculated oth_buy) as oth_net_Sell,\n\tcount(distinct scripcd) as oth_stock_n,\n\tcount(panno) as oth_freq,\n\tsum(TotBuyQty > 0) as oth_freq_b,\n\tsum(TotSellQty > 0) as oth_freq_s,\n\tsum(TotbuyQty = TotSellqty) as oth_freq_n\n\tfrom ABT&scripcd.Raw\n\twhere scripcd ne &scripcd\n\tgroup by panno\n\torder by panno;\nquit;\n\n/*proc sql;*/\n/**/\n/*\tselect */\n/*\tmax(close_rate) * 100,*/\n/*\tmin(close_rate) * 100 */\n/*\tinto :close_rate, :open_rate*/\n/*\tfrom ABT&scripcd.Raw*/\n/*\tWHERE scripcd = &Scripcd;*/\n/**/\n/*%put &open_rate &close_rate &Close_rateBSE &open_rateBSE;*/\n/*quit;*/\n\nproc sql;\n\tselect \n\tmax(close_rate) * 100\n\tinto :Close_rateBSE\n\tfrom ABTTEMPV1i\n\twhere trandate >= &anndate;\n\n\tselect \n\tmax(close_rate) * 100\n\tinto :AnnRate\n\tfrom ABTTEMPV1i\n\twhere trandate = &anndate;\n\n\n\tselect \n\tmin(close_rate) * 100\n\tinto :open_rateBSE\n\tfrom ABTTEMPV1i\n\twhere trandate = (Select min(trandate) from ABTTEMPV1i); \nquit;\n\n\n\nProc sql;\n\n\t/**%put &close_rate &open_rate;*/\n\tcreate table abt_&scripcd.v1 as\n\tselect distinct\n\ta.*,\n\tb.*,\n\t&scripcD as Scripcd,\n\t&AnnDate as Anndate format = date9., \n\t/*--proportion of buy after event;*/\n\tcase\n\t\twhen sum(0, QtySPO, QTYBPO) = 0 then 0\n\t\telse sum(QtyBPO, 0)/sum(0, QtySPO, QTYBPO) \n\tend as PropBuyPO,\n\t/*--proportion of sell before event;*/\n\tcase\n\t\twhen sum(0, QTYSPO, QTYSPE) = 0 then 0\n\t\telse QTYSPE/sum(0, QTYSPO, QTYSPE)\n\tend as PropSell,\n\t/*--proportion of buy before event;*/\n\tcase\n\t\twhen sum(0, QtySPE, QTYBPE) = 0 then 0\n\t\telse sum(QtyBPE, 0)/sum(0, QtySPE, QTYBPE) \n\tend as PropBuyPE,\n\t/*--proportion of ScripVal bought compared to total invested;*/\n\tcase\n\t\twhen oth_buy in (0,.) then ( 1 - (1 /(1 + sum(0,ValBAP)) ))*100\n\t\tELSE ( 1 - (1 /(1 + sum(0,ValBAP)/oth_buy) ))*100\n\tend as hold_buy_all,\n\n\t/**proportion of ScripVal bought compared to total sold;*/\n\tcase\n\t\twhen oth_sale in (0,.) then ( 1 - (1 /(1 + sum(0,ValBAP)) ))\n\t\tELSE ( 1 - (1 /(1 + sum(0,ValBAP)/oth_sale) ))*100\n\tend as hold_buy_sale_all,\n\n\t/**proportion of ScripVal sold compared to total sold;*/\n\tcase\n\t\twhen OTH_SALE in (0,.) then ( 1 - (1 /(1 + sum(0,VAlSAP)) ))*100\n\t\tELSE ( 1 - (1 /(1 + sum(0,ValSap)/OTH_SALE) ))*100\n\tEND AS hold_SALE_all,\n\t/**ratio between frequncy of nuetral vs long or short max;*/\n\tCASE\n\t\tWHEN max(FreqSTAP, FreqLGAP) = 0 then 0\n\t\telse freqntAP/max(FreqSTAP, FreqLGAP)\n\tEND AS freq_n_ratio,\n\t/*Profit as is*/\n\tsum(valSPE, - VALBPE) as profit format 10.0\n\tfrom ABTTempv5 a left outer join OtherScrip&scripcd b\n\ton a.pannoAP = b.panno;\n\t*where a.pannoAp is not null;\nquit;\n\nproc sql;\n\tcreate table abt_&scripcd as\n\tselect\n\t*,\n\tcase\n\t\twhen QTYSPE < QTYBPE then \n\t\tQTYSPE * (sum(0, valSPE)/sum(QTYSPE, .0001) - sum(0, valBPE)/sum(QTYBPE, .0001)) - ((sum(QTYBPE, 0) - sum(QTYSPE, 0)) * &annrate)\n\t\twhen QTYSPE > QTYBPE then \t\n\t\tQTYBPE * (sum(0, valSPE)/sum(QTYSPE, .0001) - sum(0, valBPE)/sum(QTYBPE, .0001)) + ((sum(QTYSPE, 0) - sum(QTYBPE, 0)) * &annrate)\n\t\telse sum(valSPE, - VALBPE)\n\tend as NotProf,\n\tcalculated NotProf - profit as NotNetGain\n\tfrom abt_&scripcd.v1;\nquit;\n\n\n\ndata Modelv1;\n\tset ABT_&scripcd;\n\t\tdrop lBuydt LG_dur LG_durAP lselldt NT_dur \n\t\t\t\tNT_durAP OverAllNetbuy PANNO Preevnt ST_dur ST_durAP;\n\t\twholevent = &APLast - &APFirst;\n\t\tif dsfbuy in (., 0) then dsfbuy = (Preevnt + 10); else dsfbuy = sum(dsfbuy, 0);\n\t\tif dsfsell in (., 0) then dsfsell = (Preevnt + 10); else dsfsell = sum(dsfsell, 0);\n\t\tif dslbuy in (., 0) then dslbuy = wholevent + 10; else dslbuy = sum(dslbuy, 0);\n\t\tif dslsell in (., 0) then dslsell = wholevent + 10; else dslsell = sum(dslsell, 0);\n\t\tLG_avg_dur = sum(LG_avg_dur, 0);\n\t\tLG_avg_durAP = sum(LG_avg_durAP, 0);\n\t\tNT_avg_dur = sum(NT_avg_dur, 0);\n\t\tNT_avg_durAP = sum(NT_avg_durAP, 0);\n\t\tST_avg_dur = sum(ST_avg_dur, 0);\n\t\tST_avg_durAP = sum(ST_avg_durAP, 0);\n\t\tExitBuy = dslbuy/wholevent;\n\t\tExitSell = dslsell/wholevent;\n\t\tAvgDaysHold = sum(AvgDaysHold, 0);\n\t\tAvgDaysHoldAP = sum(AvgDaysHoldAP, 0);\n\t\tAvgDaysHoldPE = sum(AvgDaysHoldPE, 0);\n\t\tAvgHoldIntrst = sum(AvgHoldIntrst, 0);\n\t\tAvgHoldIntrstAP = sum(AvgHoldIntrstAP, 0);\n\t\tAvgHoldIntrstPE = sum(AvgHoldIntrstPE, 0);\n\t\tAvgOpenIntRat = sum(AvgOpenIntRat, 0);\n\t\tAvgOpenIntRatAP = sum(AvgOpenIntRatAP, 0);\n\t\tAvgOpenIntRatPE = sum(AvgOpenIntRatPE, 0);\n\t\tFreq = sum(Freq, 0);\n\t\tfreq_n_ratio = sum(freq_n_ratio, 0);\n\t\tFreqAP = sum(FreqAP, 0);\n\t\tFreqB = sum(FreqB, 0);\n\t\tFreqBAP = sum(FreqBAP, 0);\n\t\tFreqBPE = sum(FreqBPE, 0);\n\t\tFreqBPo = sum(FreqBPo, 0);\n\t\tFreqLG = sum(FreqLG, 0);\n\t\tFreqLGAP = sum(FreqLGAP, 0);\n\t\tFreqLGPE = sum(FreqLGPE, 0);\n\t\tFreqNT = sum(FreqNT, 0);\n\t\tFreqNTAP = sum(FreqNTAP, 0);\n\t\tFreqNTPE = sum(FreqNTPE, 0);\n\t\tFreqOpen = sum(FreqOpen, 0);\n\t\tFreqOpenAP = sum(FreqOpenAP, 0);\n\t\tFreqOpenPE = sum(FreqOpenPE, 0);\n\t\tFreqPE = sum(FreqPE, 0);\n\t\tFreqPo = sum(FreqPo, 0);\n\t\tFreqS = sum(FreqS, 0);\n\t\tFreqSAP = sum(FreqSAP, 0);\n\t\tFreqSPE = sum(FreqSPE, 0);\n\t\tFreqSPo = sum(FreqSPo, 0);\n\t\tFreqST = sum(FreqST, 0);\n\t\tFreqSTAP = sum(FreqSTAP, 0);\n\t\tFreqSTPE = sum(FreqSTPE, 0);\n\t\tFreqDb = sum(FreqDb, 0);\n\t\tFreqDN = sum(FreqDN, 0);\n\t\tFreqDS = sum(FreqDS, 0);\n\t\tFreqDbAP = sum(FreqDbAP, 0);\n\t\tFreqDNAP = sum(FreqDNAP, 0);\n\t\tFreqDSAP = sum(FreqDSAP, 0);\n\t\tFreqDbPE = sum(FreqDbPE, 0);\n\t\tFreqDNPE = sum(FreqDNPE, 0);\n\t\tFreqDSPE = sum(FreqDSPE, 0);\n\t\thold_buy_all = sum(hold_buy_all, 0);\n\t\thold_buy_sale_all = sum(hold_buy_sale_all, 0);\n\t\thold_SALE_all = sum(hold_SALE_all, 0);\n\t\tLG_hold = sum(LG_hold, 0);\n\t\tLG_holdAP = sum(LG_holdAP, 0);\n\t\tLG_run = sum(LG_run, 0);\n\t\tLG_runAP = sum(LG_runAP, 0);\n\t\tLGOpenRatio = sum(LGOpenRatio, 0);\n\t\tLGOpenRatioAP = sum(LGOpenRatioAP, 0);\n\t\tLGOpenRatioPE = sum(LGOpenRatioPE, 0);\n\t\tMaxDaysHold = sum(MaxDaysHold, 0);\n\t\tMaxDaysHoldAP = sum(MaxDaysHoldAP, 0);\n\t\tMaxDaysHoldPE = sum(MaxDaysHoldPE, 0);\n\t\tMaxHoldIntsrt = sum(MaxHoldIntsrt, 0);\n\t\tMaxHoldIntsrtAP = sum(MaxHoldIntsrtAP, 0);\n\t\tMaxHoldIntsrtPE = sum(MaxHoldIntsrtPE, 0);\n\t\tMaxOpenIntRat = sum(MaxOpenIntRat, 0);\n\t\tMaxOpenIntRatAP = sum(MaxOpenIntRatAP, 0);\n\t\tMaxOpenIntRatPE = sum(MaxOpenIntRatPE, 0);\n\t\tminDaysHold = sum(minDaysHold, 0);\n\t\tminDaysHoldAP = sum(minDaysHoldAP, 0);\n\t\tminDaysHoldPE = sum(minDaysHoldPE, 0);\n\t\tMinHoldIntrst = sum(MinHoldIntrst, 0);\n\t\tMinHoldIntrstAP = sum(MinHoldIntrstAP, 0);\n\t\tMinHoldIntrstPE = sum(MinHoldIntrstPE, 0);\n\t\tMinOpenIntRat = sum(MinOpenIntRat, 0);\n\t\tMinOpenIntRatAP = sum(MinOpenIntRatAP, 0);\n\t\tMinOpenIntRatPE = sum(MinOpenIntRatPE, 0);\n\t\tNT_hold = sum(NT_hold, 0);\n\t\tNT_holdAP = sum(NT_holdAP, 0);\n\t\tNT_run = sum(NT_run, 0);\n\t\tNT_runAP = sum(NT_runAP, 0);\n\t\toth_freq = sum(oth_freq, 0);\n\t\toth_freq_b = sum(oth_freq_b, 0);\n\t\toth_freq_n = sum(oth_freq_n, 0);\n\t\toth_freq_s = sum(oth_freq_s, 0);\n\t\tST_hold = sum(ST_hold, 0);\n\t\tST_holdAP = sum(ST_holdAP, 0);\n\t\tST_run = sum(ST_run, 0);\n\t\tST_runAP = sum(ST_runAP, 0);\n\t\tTradeRatio = sum(TradeRatio, 0);\n\t\tfBuyqty = sum(fBuyqty, 0);\n\t\tfBuyVol = sum(fBuyVol, 0);\n\t\tfSellqty = sum(fSellqty, 0);\n\t\tfSellVol = sum(fSellVol, 0);\n\t\tlBuyqty = sum(lBuyqty, 0);\n\t\tlBuyVol = sum(lBuyVol, 0);\n\t\tlSellqty = sum(lSellqty, 0);\n\t\tlSellVol = sum(lSellVol, 0);\n\t\tNetBuy = sum(NetBuy, 0);\n\t\tNetSellAP = sum(NetSellAP, 0);\n\t\tNetSellPE = sum(NetSellPE, 0);\n\t\tNetSellPo = sum(NetSellPo, 0);\n\t\tNetVal = sum(NetVal, 0);\n\t\tNetValSellAP = sum(NetValSellAP, 0);\n\t\tNetValSellPE = sum(NetValSellPE, 0);\n\t\tNetValSellPo = sum(NetValSellPo, 0);\n\t\toth_buy = sum(oth_buy, 0);\n\t\toth_net_buy = sum(oth_net_buy, 0);\n\t\toth_sale = sum(oth_sale, 0);\n\t\tQTY = sum(QTY, 0);\n\t\tQTYAP = sum(QTYAP, 0);\n\t\tQtyB = sum(QtyB, 0);\n\t\tQtyBAP = sum(QtyBAP, 0);\n\t\tQtyBPE = sum(QtyBPE, 0);\n\t\tQtyBPO = sum(QtyBPO, 0);\n\t\tQtyBPEB = sum(QtyBPEB, 0);\n\t\tQTYPE = sum(QTYPE, 0);\n\t\tQtyS = sum(QtyS, 0);\n\t\tQtySAP = sum(QtySAP, 0);\n\t\tQtySPE = sum(QtySPE, 0);\n\t\tQtySPEb = sum(QtySPEb, 0);\n\t\tQtySPO = sum(QtySPO, 0);\n\t\tVal = sum(Val, 0);\n\t\tValAP = sum(ValAP, 0);\n\t\tValB = sum(ValB, 0);\n\t\tValBAP = sum(ValBAP, 0);\n\t\tValBPE = sum(ValBPE, 0);\n\t\tValBPo = sum(ValBPo, 0);\n\t\tValPE = sum(ValPE, 0);\n\t\tValPo = sum(ValPo, 0);\n\t\tValS = sum(ValS, 0);\n\t\tValSAP = sum(ValSAP, 0);\n\t\tValSPE = sum(ValSPE, 0);\n\t\tValSPo = sum(ValSPo, 0);\n\t\tEntryBuy = sum(EntryBuy, 0);\n\t\tEntrySell = sum(EntrySell, 0);\n\t\tFreqRatio = sum(FreqRatio, 0);\n\t\tPropSell = sum(PropSell, 0);\n\t\tFreqPO = sum(FreqPO, 0);\n\t\tFreqNTPO = sum(FreqNTPO, 0);\n\t\tFreqLGPO = sum(FreqLGPO, 0);\n\t\tFreqSTPO = sum(FreqSTPO, 0);\n\t\tFreqDBPO = sum(FreqDBPO, 0);\n\t\tFreqDSPO = sum(FreqDSPO, 0);\n\t\tFreqDNPO = sum(FreqDNPO, 0);\n\t\tFreqOpenPO = sum(FreqOpenPO, 0);\n\t\tLGOpenRatioPO = sum(LGOpenRatioPO, 0);\n\t\tAvgHoldIntrstPO = sum(AvgHoldIntrstPO, 0);\n\t\tMaxHoldIntsrtPO = sum(MaxHoldIntsrtPO, 0);\n\t\tMinHoldIntrstPO = sum(MinHoldIntrstPO, 0);\n\t\tAvgOpenIntRatPO = sum(AvgOpenIntRatPO, 0);\n\t\tMaxOpenIntRatPO = sum(MaxOpenIntRatPO, 0);\n\t\tMinOpenIntRatPO = sum(MinOpenIntRatPO, 0);\n\t\tAvgDaysHoldPO = sum(AvgDaysHoldPO, 0);\n\t\tMaxDaysHoldPO = sum(MaxDaysHoldPO, 0);\n\t\tminDaysHoldPO = sum(minDaysHoldPO, 0);\n\t\tFreqPEB = sum(FreqPEB, 0);\n\t\tFreqNTPEB = sum(FreqNTPEB, 0);\n\t\tFreqLGPEB = sum(FreqLGPEB, 0);\n\t\tFreqSTPEB = sum(FreqSTPEB, 0);\n\t\tFreqDBPEB = sum(FreqDBPEB, 0);\n\t\tFreqDSPEB = sum(FreqDSPEB, 0);\n\t\tFreqDNPEB = sum(FreqDNPEB, 0);\n\t\tFreqOpenPEB = sum(FreqOpenPEB, 0);\n\t\tLGOpenRatioPEB = sum(LGOpenRatioPEB, 0);\n\t\tAvgHoldIntrstPEB = sum(AvgHoldIntrstPEB, 0);\n\t\tMaxHoldIntsrtPEB = sum(MaxHoldIntsrtPEB, 0);\n\t\tMinHoldIntrstPEB = sum(MinHoldIntrstPEB, 0);\n\t\tAvgOpenIntRatPEB = sum(AvgOpenIntRatPEB, 0);\n\t\tMaxOpenIntRatPEB = sum(MaxOpenIntRatPEB, 0);\n\t\tMinOpenIntRatPEB = sum(MinOpenIntRatPEB, 0);\n\t\tAvgDaysHoldPEB = sum(AvgDaysHoldPEB, 0);\n\t\tMaxDaysHoldPEB = sum(MaxDaysHoldPEB, 0);\n\t\tminDaysHoldPEB = sum(minDaysHoldPEB, 0);\n\t\tif (FBuydt > Anndate) and valsap in (0, .) then BuyExcl = 1;\nrun;\n\n%macro rank (dsn = Tab, wgt = W_QtyBAP, var = QtyBAP, \nrank = r_QtyBAP, quintiles = 100, OUT = temp);\n\nPROC SQL ;\n\tCREATE TABLE temp AS SELECT &var,\n\tcount(&var) as &wgt\t \n\tFROM &dsn \n\tgroup by  &var\n\tORDER BY  &var;\nQUIT;\n\ndata _NULL_;\n\tset temp end=last;\n\tsumofwgt + &wgt;\n\tif last then call symput ('SUM', trim(left(put(sumofwgt, best.))));\nrun;\n\nproc sort data = temp;\n\tby &VAR;\nrun;\n\ndata temp;\n\tset temp;\n    drop sumofwgt;\n\tsumofwgt + &WGT;\n\t&rank = 0;\n\tdo i = 1 to (&quintiles - 1) ;\n\t\tif ((&rank = 0) and (sumofwgt le ((symget('SUM') * i)/&quintiles))) \n\t\tthen &rank = i;\n\tend;\n\tif (&rank = 0) then &rank = &quintiles;\n\t\tdrop i;\n\t*label &rank = \"Rank for the Variable: &VAR.\";\nrun;\n\nproc sort data = &dsn;\n\tby &VAR;\nrun;\n\n\ndata &dsn(drop = &wgt);\n\tmerge &dsn (in= a) temp (in=b);\n\tby &var;\n\tif a;\nrun;\n%mend rank;\n\n*Ranking;\noption mprint;\n/*%rank(dsn = Modelv1, wgt = W_AvgDaysHold, var = AvgDaysHold, rank = r_AvgDaysHold, quintiles = 100, OUT = Temp)*/\n/*%rank(dsn = Modelv1, wgt = W_AvgDaysHoldAP, var = AvgDaysHoldAP, rank = r_AvgDaysHoldAP, quintiles = 100, OUT = Temp)*/\n/*%rank(dsn = Modelv1, wgt = W_AvgDaysHoldPE, var = AvgDaysHoldPE, rank = r_AvgDaysHoldPE, quintiles = 100, OUT = Temp)*/\n/*%rank(dsn = Modelv1, wgt = W_AvgDaysHoldPEb, var = AvgDaysHoldPEb, rank = r_AvgDaysHoldPEb, quintiles = 100, OUT = Temp)*/\n/*%rank(dsn = Modelv1, wgt = W_AvgHoldIntrst, var = AvgHoldIntrst, rank = r_AvgHoldIntrst, quintiles = 100, OUT = Temp)*/\n/*%rank(dsn = Modelv1, wgt = W_AvgHoldIntrstAP, var = AvgHoldIntrstAP, rank = r_AvgHoldIntrstAP, quintiles = 100, OUT = Temp)*/\n/*%rank(dsn = Modelv1, wgt = W_AvgHoldIntrstPE, var = AvgHoldIntrstPE, rank = r_AvgHoldIntrstPE, quintiles = 100, OUT = Temp)*/\n/*%rank(dsn = Modelv1, wgt = W_AvgHoldIntrstPEb, var = AvgHoldIntrstPEb, rank = r_AvgHoldIntrstPEb, quintiles = 100, OUT = Temp)*/\n/*%rank(dsn = Modelv1, wgt = W_AvgOpenIntRat, var = AvgOpenIntRat, rank = r_AvgOpenIntRat, quintiles = 100, OUT = Temp)*/\n/*%rank(dsn = Modelv1, wgt = W_AvgOpenIntRatAP, var = AvgOpenIntRatAP, rank = r_AvgOpenIntRatAP, quintiles = 100, OUT = Temp)*/\n/*%rank(dsn = Modelv1, wgt = W_AvgOpenIntRatPE, var = AvgOpenIntRatPE, rank = r_AvgOpenIntRatPE, quintiles = 100, OUT = Temp)*/\n/*%rank(dsn = Modelv1, wgt = W_AvgOpenIntRatPEb, var = AvgOpenIntRatPEb, rank = r_AvgOpenIntRatPEb, quintiles = 100, OUT = Temp)*/\n/*%rank(dsn = Modelv1, wgt = W_Freq, var = Freq, rank = r_Freq, quintiles = 100, OUT = Temp)*/\n/*%rank(dsn = Modelv1, wgt = W_freq_n_ratio, var = freq_n_ratio, rank = r_freq_n_ratio, quintiles = 100, OUT = Temp)*/\n/*%rank(dsn = Modelv1, wgt = W_FreqAP, var = FreqAP, rank = r_FreqAP, quintiles = 100, OUT = Temp)*/\n/*%rank(dsn = Modelv1, wgt = W_FreqB, var = FreqB, rank = r_FreqB, quintiles = 100, OUT = Temp)*/\n/*%rank(dsn = Modelv1, wgt = W_FreqBAP, var = FreqBAP, rank = r_FreqBAP, quintiles = 100, OUT = Temp)*/\n/*%rank(dsn = Modelv1, wgt = W_FreqBPE, var = FreqBPE, rank = r_FreqBPE, quintiles = 100, OUT = Temp)*/\n/*%rank(dsn = Modelv1, wgt = W_FreqBPEb, var = FreqBPEb, rank = r_FreqBPEb, quintiles = 100, OUT = Temp)*/\n/*%rank(dsn = Modelv1, wgt = W_FreqLG, var = FreqLG, rank = r_FreqLG, quintiles = 100, OUT = Temp)*/\n/*%rank(dsn = Modelv1, wgt = W_FreqLGAP, var = FreqLGAP, rank = r_FreqLGAP, quintiles = 100, OUT = Temp)*/\n/*%rank(dsn = Modelv1, wgt = W_FreqLGPE, var = FreqLGPE, rank = r_FreqLGPE, quintiles = 100, OUT = Temp)*/\n/*%rank(dsn = Modelv1, wgt = W_FreqLGPEb, var = FreqLGPEb, rank = r_FreqLGPEb, quintiles = 100, OUT = Temp)*/\n/*%rank(dsn = Modelv1, wgt = W_FreqNT, var = FreqNT, rank = r_FreqNT, quintiles = 100, OUT = Temp)*/\n/*%rank(dsn = Modelv1, wgt = W_FreqNTAP, var = FreqNTAP, rank = r_FreqNTAP, quintiles = 100, OUT = Temp)*/\n/*%rank(dsn = Modelv1, wgt = W_FreqNTPE, var = FreqNTPE, rank = r_FreqNTPE, quintiles = 100, OUT = Temp)*/\n/*%rank(dsn = Modelv1, wgt = W_FreqNTPEb, var = FreqNTPEb, rank = r_FreqNTPEb, quintiles = 100, OUT = Temp)*/\n/*%rank(dsn = Modelv1, wgt = W_FreqOpen, var = FreqOpen, rank = r_FreqOpen, quintiles = 100, OUT = Temp)*/\n/*%rank(dsn = Modelv1, wgt = W_FreqOpenAP, var = FreqOpenAP, rank = r_FreqOpenAP, quintiles = 100, OUT = Temp)*/\n/*%rank(dsn = Modelv1, wgt = W_FreqOpenPE, var = FreqOpenPE, rank = r_FreqOpenPE, quintiles = 100, OUT = Temp)*/\n/*%rank(dsn = Modelv1, wgt = W_FreqOpenPEb, var = FreqOpenPEb, rank = r_FreqOpenPEb, quintiles = 100, OUT = Temp)*/\n/*%rank(dsn = Modelv1, wgt = W_FreqPE, var = FreqPE, rank = r_FreqPE, quintiles = 100, OUT = Temp)*/\n/*%rank(dsn = Modelv1, wgt = W_FreqPEb, var = FreqPEb, rank = r_FreqPEb, quintiles = 100, OUT = Temp)*/\n/*%rank(dsn = Modelv1, wgt = W_FreqS, var = FreqS, rank = r_FreqS, quintiles = 100, OUT = Temp)*/\n/*%rank(dsn = Modelv1, wgt = W_FreqSAP, var = FreqSAP, rank = r_FreqSAP, quintiles = 100, OUT = Temp)*/\n/*%rank(dsn = Modelv1, wgt = W_FreqSPE, var = FreqSPE, rank = r_FreqSPE, quintiles = 100, OUT = Temp)*/\n/*%rank(dsn = Modelv1, wgt = W_FreqSPEb, var = FreqSPEb, rank = r_FreqSPEb, quintiles = 100, OUT = Temp)*/\n/*%rank(dsn = Modelv1, wgt = W_FreqST, var = FreqST, rank = r_FreqST, quintiles = 100, OUT = Temp)*/\n/*%rank(dsn = Modelv1, wgt = W_FreqSTAP, var = FreqSTAP, rank = r_FreqSTAP, quintiles = 100, OUT = Temp)*/\n/*%rank(dsn = Modelv1, wgt = W_FreqSTPE, var = FreqSTPE, rank = r_FreqSTPE, quintiles = 100, OUT = Temp)*/\n*;\n%rank(dsn = Modelv1, wgt = W_FreqSTPEb, var = FreqSTPEb, rank = r_FreqSTPEb, quintiles = 100, OUT = Temp)\n/*%rank(dsn = Modelv1, wgt = W_hold_buy_all, var = hold_buy_all, rank = r_hold_buy_all, quintiles = 100, OUT = Temp)*/\n/*%rank(dsn = Modelv1, wgt = W_hold_buy_sale_all, var = hold_buy_sale_all, rank = r_hold_buy_sale_all, quintiles = 100, OUT = Temp)*/\n/*%rank(dsn = Modelv1, wgt = W_hold_SALE_all, var = hold_SALE_all, rank = r_hold_SALE_all, quintiles = 100, OUT = Temp)*/\n/*%rank(dsn = Modelv1, wgt = W_LG_hold, var = LG_hold, rank = r_LG_hold, quintiles = 100, OUT = Temp)*/\n/*%rank(dsn = Modelv1, wgt = W_LG_holdAP, var = LG_holdAP, rank = r_LG_holdAP, quintiles = 100, OUT = Temp)*/\n/*%rank(dsn = Modelv1, wgt = W_LG_run, var = LG_run, rank = r_LG_run, quintiles = 100, OUT = Temp)*/\n/*%rank(dsn = Modelv1, wgt = W_LG_runAP, var = LG_runAP, rank = r_LG_runAP, quintiles = 100, OUT = Temp)*/\n/*%rank(dsn = Modelv1, wgt = W_LGOpenRatio, var = LGOpenRatio, rank = r_LGOpenRatio, quintiles = 100, OUT = Temp)*/\n/*%rank(dsn = Modelv1, wgt = W_LGOpenRatioAP, var = LGOpenRatioAP, rank = r_LGOpenRatioAP, quintiles = 100, OUT = Temp)*/\n/*%rank(dsn = Modelv1, wgt = W_LGOpenRatioPE, var = LGOpenRatioPE, rank = r_LGOpenRatioPE, quintiles = 100, OUT = Temp)*/\n/*%rank(dsn = Modelv1, wgt = W_MaxDaysHold, var = MaxDaysHold, rank = r_MaxDaysHold, quintiles = 100, OUT = Temp)*/\n/*%rank(dsn = Modelv1, wgt = W_MaxDaysHoldAP, var = MaxDaysHoldAP, rank = r_MaxDaysHoldAP, quintiles = 100, OUT = Temp)*/\n/*%rank(dsn = Modelv1, wgt = W_MaxDaysHoldPE, var = MaxDaysHoldPE, rank = r_MaxDaysHoldPE, quintiles = 100, OUT = Temp)*/\n/*%rank(dsn = Modelv1, wgt = W_MaxHoldIntsrt, var = MaxHoldIntsrt, rank = r_MaxHoldIntsrt, quintiles = 100, OUT = Temp)*/\n/*%rank(dsn = Modelv1, wgt = W_MaxHoldIntsrtAP, var = MaxHoldIntsrtAP, rank = r_MaxHoldIntsrtAP, quintiles = 100, OUT = Temp)*/\n/*%rank(dsn = Modelv1, wgt = W_MaxHoldIntsrtPE, var = MaxHoldIntsrtPE, rank = r_MaxHoldIntsrtPE, quintiles = 100, OUT = Temp)*/\n/*%rank(dsn = Modelv1, wgt = W_MaxOpenIntRat, var = MaxOpenIntRat, rank = r_MaxOpenIntRat, quintiles = 100, OUT = Temp)*/\n/*%rank(dsn = Modelv1, wgt = W_MaxOpenIntRatAP, var = MaxOpenIntRatAP, rank = r_MaxOpenIntRatAP, quintiles = 100, OUT = Temp)*/\n/*%rank(dsn = Modelv1, wgt = W_MaxOpenIntRatPE, var = MaxOpenIntRatPE, rank = r_MaxOpenIntRatPE, quintiles = 100, OUT = Temp)*/\n/*%rank(dsn = Modelv1, wgt = W_minDaysHold, var = minDaysHold, rank = r_minDaysHold, quintiles = 100, OUT = Temp)*/\n/*%rank(dsn = Modelv1, wgt = W_minDaysHoldAP, var = minDaysHoldAP, rank = r_minDaysHoldAP, quintiles = 100, OUT = Temp)*/\n/*%rank(dsn = Modelv1, wgt = W_minDaysHoldPE, var = minDaysHoldPE, rank = r_minDaysHoldPE, quintiles = 100, OUT = Temp)*/\n/*%rank(dsn = Modelv1, wgt = W_MinHoldIntrst, var = MinHoldIntrst, rank = r_MinHoldIntrst, quintiles = 100, OUT = Temp)*/\n/*%rank(dsn = Modelv1, wgt = W_MinHoldIntrstAP, var = MinHoldIntrstAP, rank = r_MinHoldIntrstAP, quintiles = 100, OUT = Temp)*/\n/*%rank(dsn = Modelv1, wgt = W_MinHoldIntrstPE, var = MinHoldIntrstPE, rank = r_MinHoldIntrstPE, quintiles = 100, OUT = Temp)*/\n/*%rank(dsn = Modelv1, wgt = W_MinOpenIntRat, var = MinOpenIntRat, rank = r_MinOpenIntRat, quintiles = 100, OUT = Temp)*/\n/*%rank(dsn = Modelv1, wgt = W_MinOpenIntRatAP, var = MinOpenIntRatAP, rank = r_MinOpenIntRatAP, quintiles = 100, OUT = Temp)*/\n/*%rank(dsn = Modelv1, wgt = W_MinOpenIntRatPE, var = MinOpenIntRatPE, rank = r_MinOpenIntRatPE, quintiles = 100, OUT = Temp)*/\n*;\n%rank(dsn = Modelv1, wgt = W_NT_hold, var = NT_hold, rank = r_NT_hold, quintiles = 100, OUT = Temp)\n/*%rank(dsn = Modelv1, wgt = W_NT_holdAP, var = NT_holdAP, rank = r_NT_holdAP, quintiles = 100, OUT = Temp)*/\n/*%rank(dsn = Modelv1, wgt = W_NT_run, var = NT_run, rank = r_NT_run, quintiles = 100, OUT = Temp)*/\n/*%rank(dsn = Modelv1, wgt = W_NT_runAP, var = NT_runAP, rank = r_NT_runAP, quintiles = 100, OUT = Temp)*/\n/*%rank(dsn = Modelv1, wgt = W_oth_freq, var = oth_freq, rank = r_oth_freq, quintiles = 100, OUT = Temp)*/\n/*%rank(dsn = Modelv1, wgt = W_oth_freq_b, var = oth_freq_b, rank = r_oth_freq_b, quintiles = 100, OUT = Temp)*/\n/*%rank(dsn = Modelv1, wgt = W_oth_freq_n, var = oth_freq_n, rank = r_oth_freq_n, quintiles = 100, OUT = Temp)*/\n/*%rank(dsn = Modelv1, wgt = W_oth_freq_s, var = oth_freq_s, rank = r_oth_freq_s, quintiles = 100, OUT = Temp)*/\n/*%rank(dsn = Modelv1, wgt = W_ST_hold, var = ST_hold, rank = r_ST_hold, quintiles = 100, OUT = Temp)*/\n/*%rank(dsn = Modelv1, wgt = W_ST_holdAP, var = ST_holdAP, rank = r_ST_holdAP, quintiles = 100, OUT = Temp)*/\n/*%rank(dsn = Modelv1, wgt = W_ST_run, var = ST_run, rank = r_ST_run, quintiles = 100, OUT = Temp)*/\n/*%rank(dsn = Modelv1, wgt = W_ST_runAP, var = ST_runAP, rank = r_ST_runAP, quintiles = 100, OUT = Temp)*/\n/*%rank(dsn = Modelv1, wgt = W_TradeRatio, var = TradeRatio, rank = r_TradeRatio, quintiles = 100, OUT = Temp)*/\n/*%rank(dsn = Modelv1, wgt = W_fBuyqty, var = fBuyqty, rank = r_fBuyqty, quintiles = 100, OUT = Temp)*/\n/*%rank(dsn = Modelv1, wgt = W_fBuyVol, var = fBuyVol, rank = r_fBuyVol, quintiles = 100, OUT = Temp)*/\n/*%rank(dsn = Modelv1, wgt = W_fSellqty, var = fSellqty, rank = r_fSellqty, quintiles = 100, OUT = Temp)*/\n/*%rank(dsn = Modelv1, wgt = W_fSellVol, var = fSellVol, rank = r_fSellVol, quintiles = 100, OUT = Temp)*/\n/*%rank(dsn = Modelv1, wgt = W_lBuyqty, var = lBuyqty, rank = r_lBuyqty, quintiles = 100, OUT = Temp)*/\n/*%rank(dsn = Modelv1, wgt = W_lBuyVol, var = lBuyVol, rank = r_lBuyVol, quintiles = 100, OUT = Temp)*/\n/*%rank(dsn = Modelv1, wgt = W_lSellqty, var = lSellqty, rank = r_lSellqty, quintiles = 100, OUT = Temp)*/\n/*%rank(dsn = Modelv1, wgt = W_lSellVol, var = lSellVol, rank = r_lSellVol, quintiles = 100, OUT = Temp)*/\n*;\n%rank(dsn = Modelv1, wgt = W_Netsell, var = Netsell, rank = r_Netsell, quintiles = 100, OUT = Temp)\n/*%rank(dsn = Modelv1, wgt = W_NetsellAP, var = NetsellAP, rank = r_NetsellAP, quintiles = 100, OUT = Temp)*/\n/*%rank(dsn = Modelv1, wgt = W_NetsellPE, var = NetsellPE, rank = r_NetsellPE, quintiles = 100, OUT = Temp)*/\n/*%rank(dsn = Modelv1, wgt = W_NetsellPEB, var = NetsellPEB, rank = r_NetsellPEB, quintiles = 100, OUT = Temp)*/\n/*%rank(dsn = Modelv1, wgt = W_NetValSell, var = NetValSell, rank = r_NetValSell, quintiles = 100, OUT = Temp)*/\n/*%rank(dsn = Modelv1, wgt = W_NetValSellAP, var = NetValSellAP, rank = r_NetValSellAP, quintiles = 100, OUT = Temp)*/\n/*%rank(dsn = Modelv1, wgt = W_NetValSellPE, var = NetValSellPE, rank = r_NetValSellPE, quintiles = 100, OUT = Temp)*/\n/*%rank(dsn = Modelv1, wgt = W_NetValSellPEb, var = NetValSellPEb, rank = r_NetValSellPEb, quintiles = 100, OUT = Temp)*/\n/*%rank(dsn = Modelv1, wgt = W_oth_buy, var = oth_buy, rank = r_oth_buy, quintiles = 100, OUT = Temp)*/\n/*%rank(dsn = Modelv1, wgt = W_oth_net_buy, var = oth_net_buy, rank = r_oth_net_buy, quintiles = 100, OUT = Temp)*/\n/*%rank(dsn = Modelv1, wgt = W_oth_sale, var = oth_sale, rank = r_oth_sale, quintiles = 100, OUT = Temp)*/\n/*%rank(dsn = Modelv1, wgt = W_QTY, var = QTY, rank = r_QTY, quintiles = 100, OUT = Temp)*/\n/*%rank(dsn = Modelv1, wgt = W_QTYAP, var = QTYAP, rank = r_QTYAP, quintiles = 100, OUT = Temp)*/\n/*%rank(dsn = Modelv1, wgt = W_QtyB, var = QtyB, rank = r_QtyB, quintiles = 100, OUT = Temp)*/\n/*%rank(dsn = Modelv1, wgt = W_QtyBAP, var = QtyBAP, rank = r_QtyBAP, quintiles = 100, OUT = Temp)*/\n/*%rank(dsn = Modelv1, wgt = W_QtyBPE, var = QtyBPE, rank = r_QtyBPE, quintiles = 100, OUT = Temp)*/\n/*%rank(dsn = Modelv1, wgt = W_QTYPE, var = QTYPE, rank = r_QTYPE, quintiles = 100, OUT = Temp)*/\n/*%rank(dsn = Modelv1, wgt = W_QtyS, var = QtyS, rank = r_QtyS, quintiles = 100, OUT = Temp)*/\n*;\n%rank(dsn = Modelv1, wgt = W_QtySAP, var = QtySAP, rank = r_QtySAP, quintiles = 100, OUT = Temp)\n/*%rank(dsn = Modelv1, wgt = W_QtySPE, var = QtySPE, rank = r_QtySPE, quintiles = 100, OUT = Temp)*/\n/*%rank(dsn = Modelv1, wgt = W_QtySPEB, var = QtySPEB, rank = r_QtySPEB, quintiles = 100, OUT = Temp)*/\n*;\n%rank(dsn = Modelv1, wgt = W_Val, var = Val, rank = r_Val, quintiles = 100, OUT = Temp)\n/*%rank(dsn = Modelv1, wgt = W_ValAP, var = ValAP, rank = r_ValAP, quintiles = 100, OUT = Temp)*/\n/*%rank(dsn = Modelv1, wgt = W_ValB, var = ValB, rank = r_ValB, quintiles = 100, OUT = Temp)*/\n/*%rank(dsn = Modelv1, wgt = W_ValBAP, var = ValBAP, rank = r_ValBAP, quintiles = 100, OUT = Temp)*/\n/*%rank(dsn = Modelv1, wgt = W_ValBPE, var = ValBPE, rank = r_ValBPE, quintiles = 100, OUT = Temp)*/\n/*%rank(dsn = Modelv1, wgt = W_ValPE, var = ValPE, rank = r_ValPE, quintiles = 100, OUT = Temp)*/\n/*%rank(dsn = Modelv1, wgt = W_ValBPo, var = ValBPo, rank = r_ValBPo, quintiles = 100, OUT = Temp)*/\n/*%rank(dsn = Modelv1, wgt = W_ValS, var = ValS, rank = r_ValS, quintiles = 100, OUT = Temp)*/\n*;\n%rank(dsn = Modelv1, wgt = W_ValSAP, var = ValSAP, rank = r_ValSAP, quintiles = 100, OUT = Temp)\n/*%rank(dsn = Modelv1, wgt = W_ValSPE, var = ValSPE, rank = r_ValSPE, quintiles = 100, OUT = Temp)*/\n/*%rank(dsn = Modelv1, wgt = W_dsfbuy, var = dsfbuy, rank = r_dsfbuy, quintiles = 100, OUT = Temp)*/\n/*%rank(dsn = Modelv1, wgt = W_dsfsell, var = dsfsell, rank = r_dsfsell, quintiles = 100, OUT = Temp)*/\n/*%rank(dsn = Modelv1, wgt = W_dslbuy, var = dslbuy, rank = r_dslbuy, quintiles = 100, OUT = Temp)*/\n/*%rank(dsn = Modelv1, wgt = W_dslsell, var = dslsell, rank = r_dslsell, quintiles = 100, OUT = Temp)*/\n/*%rank(dsn = Modelv1, wgt = W_LG_avg_dur, var = LG_avg_dur, rank = r_LG_avg_dur, quintiles = 100, OUT = Temp)*/\n/*%rank(dsn = Modelv1, wgt = W_LG_avg_durAP, var = LG_avg_durAP, rank = r_LG_avg_durAP, quintiles = 100, OUT = Temp)*/\n/*%rank(dsn = Modelv1, wgt = W_NT_avg_dur, var = NT_avg_dur, rank = r_NT_avg_dur, quintiles = 100, OUT = Temp)*/\n/*%rank(dsn = Modelv1, wgt = W_NT_avg_durAP, var = NT_avg_durAP, rank = r_NT_avg_durAP, quintiles = 100, OUT = Temp)*/\n/*%rank(dsn = Modelv1, wgt = W_ST_avg_dur, var = ST_avg_dur, rank = r_ST_avg_dur, quintiles = 100, OUT = Temp)*/\n/*%rank(dsn = Modelv1, wgt = W_ST_avg_durAP, var = ST_avg_durAP, rank = r_ST_avg_durAP, quintiles = 100, OUT = Temp)*/\n/*%rank(dsn = Modelv1, wgt = W_Profit, var = Profit, rank = r_Profit, quintiles = 100, OUT = Temp)*/\n/*%rank(dsn = Modelv1, wgt = W_NotProf, var = NotProf, rank = r_NotProf, quintiles = 100, OUT = Temp)*/\n/*%rank(dsn = Modelv1, wgt = W_NotNetGain, var = NotNetGain, rank = r_NotNetGain, quintiles = 100, OUT = Temp)*/\n\n\ndata Model&scripcd;\n\tset Modelv1;\n\tdrop \t\tValB\tValS\t\tVal\n\t\t\tValBAP\tValSAP\t\tNetSellAP\n\tValAP\tNetValSellAP\tLG_avg_durAP\tLG_avg_dur\tNT_avg_durAP\t\n\tNT_avg_dur\tST_avg_durAP\tST_avg_dur\tValBPE\n\tValSPE\tNetSellPE\tValPE\tNetValSellPE\t\n\t\tValBPO\tValSPO\t\tNetSellPO\tValPO\n\tNetValSellPO\t\t\tValBPEB\tValSPEB\t\n\tNetSellPEB\tValPEB\tNetValSellPEB\tfSellqty\tfSellVol\tFselldt\n\tfBuyqty\tfBuyVol\tFBuydt\tlSellqty\tlSellVol\tExitSell\n\tlBuyVol\tExitBuy\toth_buy\toth_sale\toth_net_Sell\t\n\thold_buy_all\thold_buy_sale_all\thold_SALE_all\tNetBuy\tNetVal\toth_net_buy\n\tNetSell NetValSell overallnetsell;\nRUN;\n\nproc sql;\n\tcreate table TestVal as\n\tselect\n\t\tcat(PannoAP, scripcd) as IDTot,\n\t\tPannoap,\n\t\tscripcd,\n\t\tFreqDSPE,\n\t\tNT_holdAP,\n\t\tlBuyqty,\n\t\tlog(AVGOpenIntRatAP + 1) as logAVGOpenIntRatAP,\n\t\tlog(AvgDaysHoldPO + 1) as logAvgDaysHoldPO,\n\t\tlog(MaxDaysHoldPO + 1) as logMaxDaysHoldPO,\n\t\tlog(MaxHoldIntsrtPE + 1) as logMaxHoldIntsrtPE,\n\t\tlog(MinHoldIntrstPO + 1) as logMinHoldIntrstPO,\n\t\tr_FreqSTPEb,\n\t\tr_NT_hold,\n\t\tr_Netsell,\n\t\tr_QtySAP,\n\t\tQtySPEB, \n\t\tQtyBPEB,\n\t\tQtySPE, \n\t\tQtyBPE,\n\t\tQTYPEB/FreqPeb as AvgQtyPeb,\n\t\tr_val,\n\t\tr_valSAP,\n\t\tsum(freqSPEB, 0) as FreqPreS,\n\t\tnotprof,\n/*\t\t***  Effect: FreqDSPE ;*/\n\t\t8.31937170814674 * FreqDSPE as eFreqDSPE,\n/*\t\t***  Effect: LGOpenRatio ;*/\n\t\t48.5856264389636 * NT_holdAP as eNT_holdAP,\n/*\t\t***  Effect: lBuyqty ;*/\n\t\t0.00009240505753 * lBuyqty as elBuyqty,\n/*\t\t***  Effect: logAVGOpenIntRatAP ;*/\n\t\t11.9837766690043 * calculated logAVGOpenIntRatAP as elogAVGOpenIntRatAP,\n/*\t\t***  Effect: logAvgDaysHoldPO ;*/\n\t\t-0.41578799362144 * calculated logAvgDaysHoldPO as elogAvgDaysHoldPO,\n/*\t\t***  Effect: logMaxDaysHoldPO ;*/\n\t\t-42.7180325497087 * calculated logMaxDaysHoldPO as elogMaxDaysHoldPO,\n/*\t\t***  Effect: logMaxHoldIntsrtPE ;*/\n\t\t1.35508322187386 * calculated logMaxHoldIntsrtPE as elogMaxHoldIntsrtPE,\n/*\t\t***  Effect: logMinHoldIntrstPO ;*/\n\t\t-2.08001664187221 * calculated logMinHoldIntrstPO as elogMinHoldIntrstPO,\n/*\t\t***  Effect: r_FreqSTPEb ;*/\n\t\t1.09569054782267 * r_FreqSTPEb as er_FreqSTPEb,\n/*\t\t***  Effect: r_NT_hold ;*/\n\t\t-1.9939777024078 * r_NT_hold as er_NT_hold,\n/*\t\t***  Effect: r_Netsell ;*/\n\t\t0.29173989939193 * r_Netsell as er_Netsell,\n/*\t\t***  Effect: r_QtySAP ;*/\n\t\t0.06488499557156 * r_QtySAP as er_QtySAP,\n/*\t\t*** Intercept;*/\n\t\t-4.17901979318692 as eIntercept\n/*\t\tinsider*/\n\t\tfrom Modelv1\n\t\twhere sum(freqSPEB, 0) >= 1  or r_valSAP >= 95\n\t\torder by scripcd;\nquit;\n\nproc sql;\n\tcreate table test as \n\tselect \n\t*,\n\tcase\n\t\twhen sum(0, QtySPE, QtyBPE) > 0 and sum(0, QtySPEB, QtyBPEb) and QtySPe/sum(0, QtySPE, QtyBPE) < 0.5 and sum(QtySPEB, 0)/sum(0, QtySPEB, QtyBPEb) < 0.5 then \"Less Sells than buys\"\n\t\twhen avgQTYPEb <= 500 then \"Too Less qty Traded\"\n\t\twhen NotProf/100 < 50000 then \"Not profitable enough\" \n/*\t\twhen FreqSAP = 0 and fbuydt >= anndate then \"only buy & after event\"*/\n/*\t\twhen FreqBAP = 0 and PropSell > 0.80 then \"No buy and sell happen before event date\"*/\n/*\t\twhen FreqBAP = 0 and qtySPO = 0 then \"only sell & before event\"*/\n/*\t\twhen PropBuyPO >= 0.60 then \"mostly buy after event\"*/\n/*\t\twhen qtyBpo = 0 and QtySPO = 0 and PropBuyPE <= 0.75 then \"mostly sell before event\"*/\n\t\telse \"potential insider\"\n\tend as Waterfall,\n\t((8.31937170814674 * FreqDSPE) +\n\t\t(48.5856264389636 * NT_holdAP) +\n\t\t(0.00009240505753 * lBuyqty) +\n\t\t(11.9837766690043 * logAVGOpenIntRatAP) + \n\t\t(48.9636747773025 * logAvgDaysHoldPO) +\n\t\t(-42.7180325497087 * logMaxDaysHoldPO) +\n\t\t(1.35508322187386 * logMaxHoldIntsrtPE) +\n\t\t(-2.08001664187221 * logMinHoldIntrstPO) +\n\t\t(1.09569054782267 * r_FreqSTPEb) +\n\t\t(-1.9939777024078 * r_NT_hold) +\n\t\t(0.29173989939193 * r_Netsell) +\n\t\t(-1.01689596238382 * r_QtySAP) +\n\t\t(-4.17901979318692)) as x,\n\texp(calculated x) / (1 + exp(calculated x)) as px,\n\tcase\n\t\twhen calculated px >= 3/45 and calculated waterfall = \"potential insider\" then 1\n\t\telse 0\n\tEND AS Decision\n/*\tcase*/\n/*\t\twhen calculated Decision = 0 then \"Not Insider\"*/\n/*\t\twhen calculated Decision = 1 and PropBuyPE < 0.10 and PropBuyPO < 0.60 then \"insider - possibly(sell)\"*/\n/*\t\twhen calculated Decision = 1 and qtyBpo = 0 and QtySPO = 0 and PropBuyPE > 0.75 then \"insider - possibly(buy)\"*/\n/*\t\telse \"Insider proper\"*/\n/*\tend as InsiderFine*/\n\tfrom TestVal\norder by scripcd, Decision desc, px desc;\nquit;\n\n\nproc sql noprint;\ncreate table intermed as\nselect * \nfrom test\nwhere waterfall = \"potential insider\"\norder by scripcd, Notprof desc, px desc;\nquit;\n\nproc sql;\ncreate table Insiders&scripcd as\nselect \nMONOTONIC() AS RowNum,\na.*\nfrom intermed a, (select sum(decision) as Sumdesc from intermed) b\nwhere calculated rownum <= max(30, b.Sumdesc);\nquit;\n\n%let File = \"/home/sasdemo/bse_reports/ITu&scripcd.&date\";\n/*%let File = \"/SASDATA/DQ/Reports/ITu&scripcd.&date\";*/\n\n%report\n\nproc datasets library = work nolist;\n    delete ABT&scripcd.Raw ABTTEMPV1i;\nquit;\n\n%end;\n\n/*proc datasets library = work nolist;*/\n/*    delete Date&Scripcd ABT&scripcd.Raw ABTTEMPV1i test1 cmcase ABTTempAPv1 ABTTempEPv1 ABTTempPEv1  */\n/*\t\t\tABTTempAPv2 ABTTempEPv2 ABTTempPEv2 LGrunAP LGrunPE LGrunEP */\n/*\t\t\tSTrunAP STrunEP STrunPE NTrunAP NTrunPE NTrunEP */\n/*\t\t\tABTTempAP ABTTempEP ABTTempPE ABTTempv3 ABTTempv4 ABTTempv1D Periodsl ABTTempv5 */\n/*\t\t\tPeriodbl Periodsl Periods Periodb OtherScrip&scripcd abt_&scripcd.v1 */\n/*\t\t\tabt_&scripcd Modelv1 Model&scripcd TestVal test intermed InsiderReportTemp */\n/*\t\t\tInsiders&scripcd;*/\n/*quit;*/\n\n\n%let i = %eval(&i + 1);\n\n%end;\n%mend Eventact;"
    },
    {
      "role": "assistant",
      "content": "step: think\ncontent: |\n  I've examined a significant SAS script file that appears to be analyzing stock trading data related to insider trading detection. This is a complex data processing script that:\n\n  1. Analyzes stock trading patterns before and after company announcements\n  2. Calculates various metrics like buy/sell ratios, trading frequencies, profit calculations\n  3. Creates mathematical models to score and detect potential insider trading\n  4. Generates reports on suspicious trading activity\n\n  Now I understand that this project is focused on financial market analysis, specifically detecting insider trading around Bombay Stock Exchange (BSE) announcements. Let me continue examining the project structure to get a more complete understanding before creating a comprehensive report."
    },
    {
      "role": "user",
      "content": "Continue to the next step."
    },
    {
      "role": "assistant",
      "content": "step: action\ntool: fileManager\ninput: fileManager('read', '/home/rishav/Documents/Code/6th-sense/Optqo_repo_function/repository/BSEProject/SAS_Code_Understanding.xls')"
    },
    {
      "role": "user",
      "content": "OBSERVE: Error: Cannot read /home/rishav/Documents/Code/6th-sense/Optqo_repo_function/repository/BSEProject/SAS_Code_Understanding.xls as text (may be binary file)"
    },
    {
      "role": "assistant",
      "content": "step: action\ntool: executeCommand\ninput: file /home/rishav/Documents/Code/6th-sense/Optqo_repo_function/repository/BSEProject/SAS_Code_Understanding.xls"
    },
    {
      "role": "user",
      "content": "OBSERVE: stdout: /home/rishav/Documents/Code/6th-sense/Optqo_repo_function/repository/BSEProject/SAS_Code_Understanding.xls: Composite Document File V2 Document, Little Endian, Os: Windows, Version 6.1, Code page: 1252, Author: ravi.shekhar, Last Saved By: ravi.shekhar, Name of Creating Application: Microsoft Excel, Create Time/Date: Wed Jan 29 04:05:33 2014, Last Saved Time/Date: Thu Jan 30 13:59:29 2014, Security: 0\n\nstderr: "
    },
    {
      "role": "assistant",
      "content": "step: think\ncontent: |\n  The SAS_Code_Understanding.xls file is a Microsoft Excel file that I cannot read directly as text. Based on the file information, it was created in January 2014 and appears to be documentation for the SAS code in the project.\n\n  Now I have a better understanding of the project:\n  \n  1. The BSEProject is focused on financial market analysis, specifically related to the Bombay Stock Exchange (BSE)\n  2. The code analyzes trading patterns around company announcements to detect potential insider trading\n  3. It uses complex data processing, statistical analysis, and scoring mechanisms\n  4. The project includes SQL queries, SAS macros, and data processing scripts\n  5. There are multiple components including data extraction, transformation, clustering, and report generation\n  \n  Let me look at one more file to understand more details of the project before creating a comprehensive report."
    },
    {
      "role": "user",
      "content": "Continue to the next step."
    },
    {
      "role": "assistant",
      "content": "step: action\ntool: fileManager\ninput: fileManager('read', '/home/rishav/Documents/Code/6th-sense/Optqo_repo_function/repository/BSEProject/LOOP JOB STAND MATCHCODE INCR _3.sql')"
    },
    {
      "role": "user",
      "content": "OBSERVE: File content (63400 characters):\n/****************************************************************************** \n * Job:             3 LOOP JOB STAND MATCHCODE INCR         A5HHMQXQ.BB00001T * \n * Description:                                                               * \n *                                                                            * \n * Metadata Server: 192.168.253.166                                           * \n * Port:            8561                                                      * \n * Location:        /SASDIR/FINAL/INCR_JOBS                                   * \n *                                                                            * \n * Server:          SASApp                                  A5HHMQXQ.AR000002 * \n *                                                                            * \n * Source Table:    TBL_STND_LOOP_INCR -                    A5HHMQXQ.BF00003C * \n *                   saslib.TBL_STND_LOOP_INCR                                * \n *                                                                            * \n * Generated on:    Thursday, January 30, 2014 12:12:35 PM GMT+05:30          * \n * Generated by:    sasdemo                                                   * \n * Version:         SAS Data Integration Studio 4.21                          * \n ******************************************************************************/ \n\n/* General macro variables  */ \n%let jobID = %quote(A5HHMQXQ.BB00001T);\n%let etls_jobName = %nrquote(3 LOOP JOB STAND MATCHCODE INCR);\n%let etls_userID = %nrquote(sasdemo);\n\n/* Setup to capture return codes  */ \n%global job_rc trans_rc sqlrc; \n%let sysrc = 0;\n%let job_rc = 0;\n%let trans_rc = 0;\n%let sqlrc = 0;\n%global etls_stepStartTime; \n/* initialize syserr to 0 */\ndata _null_; run;\n\n%macro rcSet(error); \n   %if (&error gt &trans_rc) %then \n      %let trans_rc = &error;\n   %if (&error gt &job_rc) %then \n      %let job_rc = &error;\n%mend rcSet; \n\n%macro rcSetDS(error); \n   if &error gt input(symget('trans_rc'),12.) then \n      call symput('trans_rc',trim(left(put(&error,12.))));\n   if &error gt input(symget('job_rc'),12.) then \n      call symput('job_rc',trim(left(put(&error,12.))));\n%mend rcSetDS; \n\n/* Create metadata macro variables */\n%let IOMServer      = %nrquote(SASApp);\n%let metaPort       = %nrquote(8561);\n%let metaServer     = %nrquote(192.168.253.166);\n\n/* Set metadata options */\noptions metaport       = &metaPort \n        metaserver     = \"&metaServer\"; \n\n/* Setup for capturing job status  */ \n%let etls_startTime = %sysfunc(datetime(),datetime.);\n%let etls_recordsBefore = 0;\n%let etls_recordsAfter = 0;\n%let etls_lib = 0;\n%let etls_table = 0;\n\n%global etls_debug; \n%macro etls_setDebug; \n   %if %str(&etls_debug) ne 0 %then \n      OPTIONS MPRINT%str(;); \n%mend; \n%etls_setDebug; \n\n/*---- Start of Pre-Process Code  ----*/ \n\n\n%let cpu_cnt = 14;\n%let src_tbl = SASLIB.SAS_DIM_STAGE_INCR;\n\n%global nobs per_cpu;\n\n%macro obsnvars();\n   %global dset nvars nobs;\nproc sql NOPRINT;\n   select count(1) into :nobs from &src_tbl;\nquit;\n/*********Comment this when running job on full data ****************/\n/*   %let nobs = 1000;*/\n/********************************************************************/\n   %let per_cpu = %sysfunc(ceil(&nobs/ &cpu_cnt));\n\n%mend obsnvars;\n\n%obsnvars;\n\n \n\ndata saslib.TBL_STND_LOOP_INCR;\n\n   length etls_handleName $32\n          etls_machineId  $32\n          etls_startTime   8\n          etls_endTime     8\n          etls_status     $32\n          etls_jobRC       8\n          etls_fobs        8\n          etls_lobs        8\n   ;\n\n   label etls_handleName = 'Name of handle to remote session'   ;\n   label etls_machineId  = 'Name of machine executing the task' ;\n   label etls_startTime  = 'Start time of task' format=datetime.;\n   label etls_endTime    = 'End time of task'   format=datetime.;\n   label etls_status     = 'Current status of task'             ;\n   label etls_jobRC      = 'Return code of task'                ;\n   label etls_fobs   = 'First Observation For every parallel process';\n   label etls_lobs   = 'Last Observation For every parallel process';\n\n   do ctr = 1 to &cpu_cnt;\n      etls_handleName= \"\";\n      etls_machineId = \"\";\n      etls_startTime = .;\n      etls_endTime   = .;\n      etls_status    = \"\";\n      etls_jobRC     = .;\n      etls_fobs      = (ctr - 1) * &per_cpu + 1;\n      etls_lobs      = etls_fobs - 1 + &per_cpu;\n\n      if ctr = &cpu_cnt then etls_lobs = &nobs;\n      \n      output;\n   end;\nrun;\n\n/*---- End of Pre-Process Code  ----*/ \n\n%rcSet(&syserr); \n%rcSet(&sqlrc); \n\n%macro genSASCommand; \n   %local noobjserver; \n   %if \"&sysscp\"=\"OS\" %then %let noobjserver=; \n   %else %if \"&sysscp\"=\"VMS_AXP\" %then %let noobjserver=%quote(/noobjectserver); \n   %else %let noobjserver=%quote(-noobjectserver); \n   options sascmd = \"!sascmd &noobjserver\"; \n%mend genSASCommand; \n%genSASCommand; \n\n%macro etls_tsLevel(macroName=, featureName=); \n   data _null_; \n      call symput(\"&macroName\",tslvl(\"&featureName\")); \n   run; \n%mend etls_tsLevel; \n\n%macro etls_signon(handleName=etlsRemote, cmacvar=etls_signonStatus, \n   gridRC=rc, useGrid=1, \n   machineIdMacroVariable=etls_machineId, workloadMacroVariable=, \n   log=, output=, additionalSignonOptions=, signonRetries=3); \n\n   %let etls_gridInstalled =;\n   %etls_tsLevel(macroName=etls_gridInstalled, featureName=uwugrdsvc); \n\n   %if (&useGrid = 1) %then \n   %do; \n      %if (\"&etls_gridInstalled\" ne \"\") %then \n      %do; \n         %if (&gridRC eq ) %then \n            %let gridRC = &handleName.RC ; \n\n         %global &gridRC;\n         %let workload = ; \n         %if (&workloadMacroVariable ne ) %then \n         %do; \n            data _null_;\n               call symput('workload',';workload = '||symget(\"&workloadMacroVariable\"));\n            run;\n         %end; \n         %let &gridRC = %sysfunc(grdsvc_enable(\"&handleName\",\"resource = SASApp &workload \")); \n      %end; \n      %else \n         %put %str(NOTE: Grid service functions are not installed.);\n   %end; \n\n   %local sleeptime sleepIncreaseAmount tryCount; \n   %let sleepIncreaseAmount=5; \n   %let sleeptime=5; \n   %let tryCount=1; \n   %let &cmacvar=1; \n\n   %do %until((&&&cmacvar ne 1) or (&tryCount gt %eval(&signonRetries+1))); \n      data _null_; \n      signon &handleName cmacvar=&cmacvar \n         %if (\"&log\" ne \"\") %then \n            log=&log; \n         %if (\"&output\" ne \"\") %then \n            output=&output; \n         %if (\"&additionalSignonOptions\" ne \"\") %then \n            &additionalSignonOptions; \n      ;run; \n\n      %if \"&&&cmacvar\" eq \"1\" %then \n      %do; \n         %if &tryCount lt %eval(&signonRetries+1) %then \n         %do; \n            %put NOTE: Signon attempt #&tryCount failed. Retrying in &sleeptime seconds.;\n            %let rc=%sysfunc(sleep(&sleeptime,1)); \n         %end; \n         %else %if &signonRetries gt 0 %then \n            %put ERROR%QUOTE(:) Final signon attempt, #&tryCount, failed.;\n\n         %let sleeptime=%sysevalf(&sleeptime+&sleepIncreaseAmount,int); /* increase sleeptime by factor */ \n         %let tryCount=%eval(&tryCount+1); \n      %end; \n   %end; \n   %rcSet(&syserr); \n\n   /* On successful signon, fetch and report machine name if grid was requested. */ \n   %if (\"&machineIdMacroVariable\" ne \"\") %then %let &machineIdMacroVariable = ; \n   %if (\"&&&cmacvar\" ne \"1\" and \"&machineIdMacroVariable\" ne \"\" and \n        &useGrid = 1 and \"&etls_gridInstalled\" ne \"\") %then \n   %do; \n      %put; \n      %if (\"&&&gridRC\" eq \"0\") %then \n      %do; \n         %let &machineIdmacroVariable = %sysfunc(grdsvc_getname(&handleName)); \n         %put %str(NOTE: Signed on to grid machine &&&machineIdmacroVariable..);\n      %end; \n      %else \n         %put %str(NOTE: GRID SERVICES WERE NOT ENABLED.  Signed on to LOCAL machine.);\n      %put; \n   %end; \n\n%mend etls_signon; \n\n%macro etls_serverConnected(serverId=,macvarname=isConnected); \n   %let &macvarname=0; \n   %local search_str none_str savenotes; \n\n   /* setup information for listtask output */ \n   /* listtask output on OS/390 differs */ \n   %if %bquote(&sysscp) eq OS %then \n   %do; \n      %let search_str=Remote submit for; \n      %let token=5; \n   %end; \n   %else  \n   %do; \n      %let search_str=--------------; \n      %let token=1; \n   %end; \n\n   /* Issue listtask within PROC PRINTTO - send output to file */ \n   filename __tmptxt TEMP; \n   %let savenotes=%sysfunc(getoption(notes)); \n   options nonotes; \n\n   proc printto log=__tmptxt new; \n   run; \n\n   options notes; \n   listtask; \n   proc printto; \n   run; \n\n   options nonotes; \n\n   /* read in the output from listtask */ \n   %let dsname=_null_; \n   data _null_(keep=Session); \n      length line $256 sessionId $60; \n      infile __tmptxt length=len; \n      input @1 line $varying. len; \n\n      if line=:'There are no' then \n         stop; \n      /* look for the search string and scan for server name */ \n      if index(line,\"&search_str\") then  \n      do; \n         sessionId=scan(line,&token,\" \"); \n         sessionId=upcase(trim(left(tranwrd(sessionId,'\"',' ')))); \n         if sessionId=upcase(symget(\"serverId\")) then \n         do;  \n            call symput(\"&macvarname\",\"1\"); \n            stop; \n         end; \n      end; \n   run; \n   filename __tmptxt clear; \n   options &savenotes; \n%mend etls_serverConnected; \n\n%macro etls_signoff(handleName=rmt); \n   %local savemprint; \n   %let savemprint=%sysfunc(getoption(mprint)); \n   %put %str(NOTE: Testing connection with etls_serverConnected macro %(mprint off%).);\n   options nomprint; \n   %local isConnected; \n   %etls_serverConnected(serverId=&handleName); \n   options &savemprint; \n   %if &isConnected %then \n      signoff &handleName ;; \n%mend etls_signoff; \n\n%macro etls_getHandle(statusTable=, handleVariable=, row=); \n   %let etls_dsid = %sysfunc(open(&statusTable)); \n   %if (&etls_dsid = 0) %then \n      %put %sysfunc(sysmsg()); \n   %else \n   %do; \n      %let rc = %sysfunc(fetchobs(&etls_dsid, &row)); \n      %if (&rc ne 0) %then \n         %put %sysfunc(sysmsg()); \n      %else \n      %do; \n         %let etls_varnum = %sysfunc(varnum(&etls_dsid,&handleVariable)); \n         %if (&etls_varnum > 0) %then \n            %sysfunc(getvarc(&etls_dsid,&etls_varnum)); \n         %else \n            %put %sysfunc(sysmsg()); \n      %end; \n      %let rc = %sysfunc(close(&etls_dsid)); \n   %end; \n%mend etls_getHandle; \n\n%macro etls_freeHandle(statusTable=, statusVariable=, handleVariable=, \n   handleName=, statusSetting=\"Finished\", \n   endTimeVariable=endTime, startTimeVariable=startTime, signoff=1, \n   returnCodeVariable=, returnCodeMacroVariable=, setMainJobRC=1, \n   statusUnknownReturnCode=., startTimeMacroVariable=, endTimeMacroVariable= ); \n\n   %if (&statusTable ne ) %then \n   %do; \n      %local etls_rcMacroVarExisted; \n      %let etls_rcMacroVarExisted = 0; \n      %if (\"&returnCodeMacroVariable\" ne \"\") %then \n      %do; \n         proc sql noprint; \n            select '1' into: etls_rcMacroVarExisted from dictionary.macros \n            where name=upcase(\"&returnCodeMacroVariable\"); \n         quit; \n\n         %rcSet(&sqlrc); \n         %if (&etls_rcMacroVarExisted = 0) %then \n         %do; \n            %put WARNING%QUOTE(:) Return code from inner job not found.  Setting status to Unknown.;\n            %let &returnCodeMacroVariable=&statusUnknownReturnCode; \n         %end; \n         %if (&setMainJobRC eq 1) %then \n            %rcSet(&&&returnCodeMacroVariable); \n      %end; \n      %else \n      %do; \n         %let returnCodeMacroVariable=etls_rcmacvar; \n         %let &returnCodeMacroVariable=&statusUnknownReturnCode; \n      %end; \n\n      %local etls_startTimeMacroVarExisted; \n      %let etls_startTimeMacroVarExisted = 0; \n      %if (\"&startTimeMacroVariable\" ne \"\") %then \n      %do; \n         proc sql noprint; \n            select '1' into: etls_startTimeMacroVarExisted from dictionary.macros \n            where name=upcase(\"&startTimeMacroVariable\"); \n         quit; \n\n         %rcSet(&sqlrc); \n         %if (&etls_startTimeMacroVarExisted = 0) %then \n         %do; \n            %put WARNING%QUOTE(:) Start time from inner job not found.  No value will be set.;\n            %let &startTimeMacroVariable=; \n         %end; \n      %end; \n\n      %local etls_endTimeMacroVarExisted; \n      %let etls_endTimeMacroVarExisted = 0; \n      %if (\"&endTimeMacroVariable\" ne \"\") %then \n      %do; \n         proc sql noprint; \n            select '1' into: etls_endTimeMacroVarExisted from dictionary.macros \n            where name=upcase(\"&endTimeMacroVariable\"); \n         quit; \n\n         %rcSet(&sqlrc); \n         %if (&etls_endTimeMacroVarExisted = 0) %then \n         %do; \n            %put WARNING%QUOTE(:) End time from inner job not found.  Setting end time to current time.;\n            %let &endTimeMacroVariable=%sysfunc(datetime()); \n         %end; \n      %end; \n\n      data &statusTable; \n         modify &statusTable(where=(&handleVariable = &handleName)); \n         %if (\"&startTimeMacroVariable\" ne \"\") %then \n         %do; \n            &startTimeVariable = input(symget(\"&startTimeMacroVariable\"),32.);; \n         %end; \n         %if (\"&endTimeVariable\" ne \"\") %then \n         %do; \n            %if (\"&endTimeMacroVariable\" ne \"\") %then \n            %do; \n               &endTimeVariable = input(symget(\"&endTimeMacroVariable\"),32.);; \n            %end; \n            %else \n               &endTimeVariable = datetime();; \n         %end; \n         %if (\"&returnCodeVariable\" ne \"\") %then \n            &returnCodeVariable = input(symget(\"&returnCodeMacroVariable\"),32.);; \n         %if (\"&statusVariable\" ne \"\") %then \n         %do; \n            if (symget(\"etls_rcMacroVarExisted\") eq \"0\") then \n               &statusVariable = \"Unknown Status\"; \n            else\n               &statusVariable = &statusSetting;\n         %end;\n         call symput('handle',&handleVariable); \n         replace; \n         stop; \n      run; \n\n      %rcSet(&syserr); \n\n      %if (&signoff eq 1) %then \n         %etls_signoff(handleName=&handle); \n   %end; \n%mend etls_freeHandle; \n\n%macro etls_createHandle(statusTable=, statusVariable=, \n   handleVariable=, handlePrefix=rmt, \n   workloadMacroVariable=, row=, machineVariable=, \n   statusSetting=\"Running\", startTimeVariable=startTime, \n   signon=1, useGrid=1, log=, output=, gridRC=, cmacvar=etls_signonStatus, \n   additionalSignonOptions=, signonRetries= ); \n\n   %local remoteSessionId; \n   %let remoteSessionId = &handlePrefix.&row; \n   %let &cmacvar = 1; \n   %local etls_machineId; \n   %if (&signon eq 1) %then  \n      %etls_signon(handleName=&remoteSessionId, useGrid=&useGrid, \n         machineIdMacroVariable=etls_machineId, workloadMacroVariable=&workloadMacroVariable, \n         log=&log, output=&output, cmacvar=&cmacvar, gridRC=&gridRC, \n         additionalSignonOptions=&additionalSignonOptions,signonRetries=&signonRetries); \n   %else %let &cmacvar=0; \n\n   data &statusTable; \n      retain ptr &row; \n      modify &statusTable point = ptr; \n      &handleVariable = \"&remoteSessionId\"; \n      %if (&signon eq 1) %then \n         &machineVariable = \"&etls_machineId\";; \n      %if (&&&cmacvar ne 0) %then \n      %do; \n         &statusVariable = \"Failed Signon\"; \n      %end; \n      %else \n         &statusVariable = &statusSetting;; \n      %if (&startTimeVariable ne ) %then \n         &startTimeVariable = datetime();; \n      replace; \n      stop; \n   run; \n\n   %rcSet(&syserr); \n%mend etls_createHandle; \n\n%macro etls_waitfor(statusTable=, statusVariable=, runningStatusSetting=\"Running\", handleVariable=, \n   completeStatusSetting=\"Finished\", endTimeVariable=endTime, \n   startTimeVariable=startTime, waitType=_ANY_, signoff=1, \n   returnCodeVariable=, returnCodeMacroVariable=, statusUnknownReturnCode=.); \n\n   proc sql noprint; \n      select count(*) into :etls_rows \n         from &statusTable where &statusVariable = &runningStatusSetting; \n      %let etls_rows = &etls_rows; \n      %if (&etls_rows gt 0) %then \n      %do; \n         select &handleVariable into :etlsHandles1 - :etlsHandles&etls_rows \n            from &statusTable where &statusVariable = &runningStatusSetting; \n      %end; \n   quit; \n\n   %rcSet(&sqlrc); \n\n   %if (&etls_rows gt 0) %then \n   %do; \n      waitfor &waitType \n         %do i=1 %to &etls_rows; \n            &&etlsHandles&i \n         %end; \n      ; \n   %end; \n\n   %local useDefaultRCMacVar; \n   %if (\"&returnCodeMacroVariable\" eq \"\") %then \n      %let useDefaultRCMacVar=Y; \n\n   %do i=1 %to &etls_rows; \n\n      %if (\"&useDefaultRCMacVar\"=\"Y\") %then \n         %let returnCodeMacroVariable=job_rc&&etlsHandles&i; \n\n      waitfor &&etlsHandles&i timeout=1; \n      %if (&SYSRC eq 0) or (&SYSRC eq -2) %then /* process complete  */ \n      %do; \n         %etls_freeHandle(statusTable=&statusTable, statusVariable=&statusVariable,\n            handleVariable=&handleVariable, handleName=\"&&etlsHandles&i\", \n            statusSetting=&completeStatusSetting, endTimeVariable=&endTimeVariable, \n            startTimeVariable=&startTimeVariable, signoff=&signoff, \n            returnCodeVariable=&returnCodeVariable, returnCodeMacroVariable=&returnCodeMacroVariable, \n            statusUnknownReturnCode=&statusUnknownReturnCode, \n            startTimeMacroVariable=etls_startTime_&&etlsHandles&i., \n            endTimeMacroVariable=etls_endTime_&&etlsHandles&i. ); \n         %put NOTE: Process &&etlsHandles&i. has completed.;\n      %end; \n      %else %if (&SYSRC ne -1) %then /* process status unknown  */ \n      %do; \n         %etls_freeHandle(statusTable=&statusTable, statusVariable=&statusVariable,\n            handleVariable=&handleVariable, handleName=\"&&etlsHandles&i\", \n            statusSetting=\"Unknown Status\", endTimeVariable=&endTimeVariable, \n            startTimeVariable=&startTimeVariable, signoff=&signoff, \n            returnCodeVariable=&returnCodeVariable, returnCodeMacroVariable=&returnCodeMacroVariable, \n            statusUnknownReturnCode=&statusUnknownReturnCode, startTimeMacroVariable=etls_startTime_&&etlsHandles&i ); \n         %put NOTE: Cannot retrieve status from process &&etlsHandles&i..;\n      %end; \n   %end; \n%mend etls_waitfor; \n\n%macro etls_getProcessesRunning(statusTable=, statusVariable=, processCountMacro=, \n   statusSetting=\"Running\"); \n\n   proc sql noprint; \n      select count(*) into: &processCountMacro \n         from &statusTable where &statusVariable = &statusSetting; \n   quit; \n\n   %rcSet(&sqlrc); \n%mend etls_getProcessesRunning; \n\n/*============================================================================* \n * Step:            Loop                                    A5HHMQXQ.BJ000048 * \n * Transform:       Loop                                                      * \n * Description:                                                               * \n *                                                                            * \n * Source Table:    TBL_STND_LOOP_INCR -                    A5HHMQXQ.BF00003C * \n *                   saslib.TBL_STND_LOOP_INCR                                * \n * Target Table:    Loop - work.W5WRWB0N                    A5HHMQXQ.BQ00002G * \n *============================================================================*/ \n\n%let transformID = %quote(A5HHMQXQ.BJ000048);\n%let trans_rc = 0;\n%let etls_stepStartTime = %sysfunc(datetime(), datetime20.); \n\n%let SYSLAST = %nrquote(saslib.TBL_STND_LOOP_INCR); \n\n%macro etls_getParameterNames(parameterTable=, parameterVariableMacro=, startingColumnNumber=1);\n   %let &parameterVariableMacro = ;\n   %let dsid = %sysfunc(open(&parameterTable));\n   %if (&dsid gt 0) %then \n   %do; \n      %do i=&startingColumnNumber %to %sysfunc(attrn(&dsid,nvars)); \n         %let &parameterVariableMacro = &&&parameterVariableMacro %sysfunc(varname(&dsid,&i)); \n      %end; \n      %let dsid = %sysfunc(close(&dsid)); \n   %end; \n   %else \n      %put %sysfunc(sysmsg()); \n   %rcSet(&syserr); \n%mend etls_getParameterNames; \n\n%macro etls_getParameters(parameterTable=, row=, startingColumnNumber=1 , handleName=); \n   data _null_; \n      length vname $256 vtype $1 value $3200; \n      dsid = open(\"&parameterTable\"); \n      if (dsid > 0) then \n      do; \n         do _i = 1 to &row; \n            fetchrc = fetch(dsid); \n         end; \n         do _i=&startingColumnNumber to attrn(dsid,'nvars'); \n            vname = varname(dsid,_i); \n            vtype = vartype(dsid,_i); \n            if (fetchrc = 0) then \n            do; \n               if (vtype = 'C') then \n               do; \n                  value = getvarc(dsid,_i); \n                  value = tranwrd(value,\"%\",\"%%\"); \n                  value = tranwrd(value,\"(\",\"%(\"); \n                  value = tranwrd(value,\")\",\"%)\"); \n                  value = tranwrd(value,'\"','%\"'); \n               end; \n               else \n                  value = left(put(getvarn(dsid,_i),best32.)); \n            end; /* fetchrc = 0 */ \n            \n            put ;\n            if indexc(trimn(value),\"+-*/<>=^~;, '()&%\",'\"')>0 then \n            do; \n               value='%str('||trim(value)||')'; \n               put \"NOTE: Special characters encountered; References may require: %nrbquote(%)UNQUOTE(&\" vname+(-1)').';\n            end; \n            %if %str(&handlename) ne %str() %then \n            %do; \n               value = '%syslput '||trim(vname)||'= '||trim(value)||\" / remote = &handleName;\"; \n            %end; \n            %else \n            %do; \n               value = '%let '||trim(vname)||'= '||trim(value)||';'; \n            %end; \n            \n            put \"NOTE: Setting macro variable \" vname \"with statement:\" value ;\n            call execute(value); \n         end; /* do i= */ \n         dsid = close(dsid); \n      end; /* dsid > 0 */ \n      else \n      do; \n         put \"ERROR%QUOTE(:) Parameter table, &parameterTable, could not be opened.\";\n         abort; \n      end; \n      stop; \n   run; \n   \n   %rcSet(&syserr); \n%mend etls_getParameters; \n\n%macro etls_loopW6E21BPT; \n   %local etls_filePrefix; \n   %let etls_filePrefix = ; \n   \n   %macro etls_processToLoopW6E21BQ3(parameterTable=, row=, handleName=rmt);\n      %etls_getParameters(parameterTable=&parameterTable, row=&row, \n         startingColumnNumber=1, handleName=&handleName); \n      %let etls_previousFilePrefix = &etls_filePrefix;\n      %local etls_filePrefix; \n      %let etls_filePrefix = &etls_previousFilePrefix.&handleName; \n      %syslput &etls_controlName = &row / remote = &handleName; \n      %syslput handleName = &handleName / remote = &handleName; \n      %syslput jobID = &jobID / remote = &handlename; \n      %syslput etls_jobName = &etls_jobName / remote = &handlename; \n      %syslput etls_userID = &etls_userID / remote = &handlename; \n      \n      \n      /* Setup to pass macros to remote session  */ \n      data _null_;\n         if &sysver ge 9 then rmtname = \"/ remote = &handleName\";\n         else rmtname = \"\";\n         call execute('%syslput etls_debug = &etls_debug '||rmtname||';');\n         call execute('%syslput etls_filePrefix = &etls_filePrefix '||rmtname||';');\n         call execute('run;');\n      run;\n      \n      rsubmit &handleName wait = no sysrputsync = yes persist = no\n         log = \"&etls_logOutputPath./&etls_filePrefix..log\" \n         output = \"&etls_logOutputPath./&etls_filePrefix..lst\" \n      ; \n      \n         %macro etls_jobW6E21BQD; \n         \n            %macro etls_setClientSideStatus;\n               %sysrput job_rc&handleName = &job_rc; \n               %sysrput etls_endTime_&handleName = %sysfunc(datetime()); \n            %mend etls_setClientSideStatus;\n            \n            %sysrput etls_startTime_&handleName = %sysfunc(datetime()); \n            \n            /* Setup to capture return codes  */ \n                        %global job_rc trans_rc sqlrc; \n                        %let sysrc = 0;\n                        %let job_rc = 0;\n                        %let trans_rc = 0;\n                        %let sqlrc = 0;\n                        %global etls_stepStartTime; \n                        /* initialize syserr to 0 */\n                        data _null_; run;\n                        \n                        %macro rcSet(error); \n                           %if (&error gt &trans_rc) %then \n                              %let trans_rc = &error;\n                           %if (&error gt &job_rc) %then \n                              %let job_rc = &error;\n                        %mend rcSet; \n                        \n                        %macro rcSetDS(error); \n                           if &error gt input(symget('trans_rc'),12.) then \n                              call symput('trans_rc',trim(left(put(&error,12.))));\n                           if &error gt input(symget('job_rc'),12.) then \n                              call symput('job_rc',trim(left(put(&error,12.))));\n                        %mend rcSetDS; \n                        /****************************************************************************** \n                         * Job:             JOB STAND MATCHCODE INCR                A5HHMQXQ.BB00001S * \n                         * Description:     This job standardizes 4 dedupe and 4 other fileds, then   * \n                         *                   calculates Name and Address Matchcodes.                  * \n                         *                                                                            * \n                         * Metadata Server: 192.168.253.166                                           * \n                         * Port:            8561                                                      * \n                         * Location:        /SASDIR/FINAL/INCR_JOBS                                   * \n                         *                                                                            * \n                         * Server:          SASApp                                  A5HHMQXQ.AR000002 * \n                         *                                                                            * \n                         * Generated on:    Thursday, January 30, 2014 12:12:35 PM GMT+05:30          * \n                         * Generated by:    sasdemo                                                   * \n                         * Version:         SAS Data Integration Studio 4.21                          * \n                         ******************************************************************************/ \n                        \n                        /* General macro variables  */ \n                        %let jobID = %quote(A5HHMQXQ.BB00001S);\n                        %let etls_jobName = %nrquote(JOB STAND MATCHCODE INCR);\n                        %let etls_userID = %nrquote(sasdemo);\n                        \n                        \n                        /* Create metadata macro variables */\n                        %let IOMServer      = %nrquote(SASApp);\n                        %let metaPort       = %nrquote(8561);\n                        %let metaServer     = %nrquote(192.168.253.166);\n                        \n                        /* Set metadata options */\n                        options metaport       = &metaPort \n                                metaserver     = \"&metaServer\"; \n                        \n                        /* Setup for capturing job status  */ \n                        %let etls_startTime = %sysfunc(datetime(),datetime.);\n                        %let etls_recordsBefore = 0;\n                        %let etls_recordsAfter = 0;\n                        %let etls_lib = 0;\n                        %let etls_table = 0;\n                        \n                        %global etls_debug; \n                        %macro etls_setDebug; \n                           %if %str(&etls_debug) ne 0 %then \n                              OPTIONS MPRINT%str(;); \n                        %mend; \n                        %etls_setDebug; \n                        \n                        /*---- Start of Pre-Process Code  ----*/ \n                        \n                        %DQLOAD(DQLOCALE=(ENIND), DQSETUPLOC='/SASINST/BSE/SASFoundation/9.2/misc/dquality/dqsetup.txt',DQINFO=1) ;\n                        \n                        \n                        %let src_tbl = SASLIB.SAS_DIM_STAGE_INCR;\n                        data saslib.sas_dim_stage_incr_&ctr(COMPRESS=YES);\n                           set &src_tbl (firstobs = &i obs = &n);\n                        run;\n                        /*---- End of Pre-Process Code  ----*/ \n                        \n                        %rcSet(&syserr); \n                        %rcSet(&sqlrc); \n                        \n                        /*---- Start of User Written Code  ----*/ \n                        \n                        \n                        proc sql;\n                        create index category on saslib.SAS_DIM_STAGE_INCR_&ctr(category) ;\n                        quit;\n                        \n                        \n                        data saslib.SAS_DIM_STAGE_ORG_&ctr(COMPRESS = YES) ;\n                        SET SASLIB.SAS_DIM_STAGE_INCR_&ctr ; \n                        \n                        where (upcase(category) ne 'I' and upcase(category) ne 'NRI' );\n                        run;\n                        \n                        \n                        data saslib.SAS_DIM_STAGE_IND_&ctr(COMPRESS = YES) ;\n                        set SASLIB.SAS_DIM_STAGE_INCR_&ctr ;\n                        where (category eq 'I' or category eq 'NRI' );\n                        run;\n                        \n                              \n                        data saslib.SAS_DIM_DEDUPE_IND_&ctr (COMPRESS = YES);\n                        set saslib.SAS_DIM_STAGE_IND_&ctr;\n                                 attrib NEW_UPDATE_FLAG length = $8 \n                                    format = $8.\n                                    informat = $8.; \n                                 attrib UID_NUM length = 8\n                                    format = 8.\n                                    informat = 8.; \n                                 attrib UID_CHAR length = $100\n                                    format = $100.\n                                    informat = $100.; \n                                 attrib SAS_ID length = $25\n                                    format = $25.\n                                    informat = $25.; \n                                 attrib CLUSTER_ID length = 8\n                                    format = 8.\n                                    informat = 8.; \n                                 attrib NAME_STND length = $100\n                                    format = $100.\n                                    informat = $100.; \n                                 attrib ADDRESS_STND length = $300\n                                    format = $300.\n                                    informat = $300.; \n                                 attrib PAN_STND length = $15\n                                    format = $15.\n                                    informat = $15.; \n                                 attrib DATEOFBIRTH_STND length = $25\n                                    format = $25.\n                                    informat = $25.; \n                                 attrib CITY_STND length = $30\n                                    format = $30.\n                                    informat = $30.; \n                                 attrib STATE_STND length = $25\n                                    format = $25.\n                                    informat = $25.; \n                                 attrib COUNTRY_STND length = $25\n                                    format = $25.\n                                    informat = $25.; \n                                 attrib BANK_NAME_STND length = $50\n                                    format = $50.\n                                    informat = $50.; \n                                 attrib NAME_MC1 length = $100\n                                    format = $100.\n                                    informat = $100.; \n                                 attrib NAME_MC2 length = $100\n                                    format = $100.\n                                    informat = $100.; \n                                 attrib NAME_MC3 length = $100\n                                    format = $100.\n                                    informat = $100.; \n                                 attrib ADDRESS_MC1 length = $150\n                                    format = $100.\n                                    informat = $100.; \n                                 attrib ADDRESS_MC2 length = $150\n                                    format = $100.\n                                    informat = $100.; \n                                 attrib ADDRESS_MC3 length = $150\n                                    format = $100.\n                                    informat = $100.; \n                                 attrib DEDUPE_MATCH_CODE_1 length = $200\n                                    format = $200.\n                                    informat = $200.; \n                                 attrib DEDUPE_MATCH_CODE_2 length = $200\n                                    format = $200.\n                                    informat = $200.; \n                                 attrib DEDUPE_MATCH_CODE_3 length = $200\n                                    format = $200.\n                                    informat = $200.; \n                                 attrib DEDUPE_MATCH_CODE_4 length = $200\n                                    format = $200.\n                                    informat = $200.; \n                                 attrib DEDUPE_MATCH_CODE_5 length = $200\n                                    format = $200.\n                                    informat = $200.; \n                                 attrib DEDUPE_MATCH_CODE_6 length = $200\n                                    format = $200.\n                                    informat = $200.; \n                                 attrib DMC_1_FLAG length = 4\n                                    format = 4.\n                                    informat = 4.; \n                                 attrib DMC_2_FLAG length = 4\n                                    format = 4.\n                                    informat = 4.; \n                                 attrib DMC_3_FLAG length = 4\n                                    format = 4.\n                                    informat = 4.; \n                                 attrib DMC_4_FLAG length = 4\n                                    format = 4.\n                                    informat = 4.; \n                                 attrib DMC_5_FLAG length = 4\n                                    format = 4.\n                                    informat = 4.; \n                                 attrib DMC_6_FLAG length = 4\n                                    format = 4.\n                                    informat = 4.; \n                        \tSAS_ID= CATX('!',put(brokercode,11.), clientcode) ;\n                        \tNAME=upcase(compress(NAME  ,' ','IKNPOH' )); \n                        \tNAME_STND\t=\tupcase(DQSTANDARDIZE(NAME ,'Name','ENIND'))\t;\n                         \tADDRESS = compress(ADDRESS  ,' ','IKNPOH' );\t\t\n                        \tPANNO =  compress(PANNO  ,' ','IKNPOH' );\t\t\n                        \tCITY=  compress(CITY  ,' ','IKNPOH' );\t\t\n                        \tSTATE=   compress(STATE  ,' ','IKNPOH' );\t\t\n                        \tCOUNTRY=   compress(COUNTRY  ,' ','IKNPOH' );\t\t\n                        \n                        if (upcase(PANNO) EQ 'AAAAA9999A')\n                        \t\tthen do ;\n                        \t\t\tPAN_STND= '';\n                        \t\tend;\n                        else if (DQPATTERN (upcase(PANNO),'CHARACTER','ENIND') EQ 'AAAAA9999A' ) \n                        \t\tthen do ;\n                        \t\t\tPAN_STND = DQSTANDARDIZE(PANNO ,'Pan','ENIND');\n                        \t\tend;\n                        else PAN_STND ='' ;\n                        \n                        \n                        DATEOFBIRTH_STND\t=\tSTRIP(DATEOFBIRTH);\t\n                        if DATEOFBIRTH_STND in ('01/01/1900' , '01/01/1800') \n                        then do ; DATEOFBIRTH_STND ='' ; end;\t\n                        \n                        CITY_STND\t=\tupcase(DQSTANDARDIZE(CITY ,'City','ENIND'))\t;\n                        STATE_STND\t=\tupcase(DQSTANDARDIZE(STATE, 'State', 'ENIND'))\t;\n                        COUNTRY_STND =\tupcase(DQSTANDARDIZE( COUNTRY ,'Country','ENIND'))\t; \n                        \n                        if (SCAN(NAME_STND,2,' ') EQ '' |  LENGTH(COMPRESS(NAME_STND, ' ') ) <4 ) \n                        THEN do ;\n                        \t\t\tNAME_MC1='';\n                        \t\t\tNAME_MC2\t='';\n                        \t\t\tNAME_MC3\t\t='';\n                        \tend;\n                        ELSE do;\n                        \t\t\tNAME_MC1=DQMATCH(NAME_STND ,'Name (BSE)', 75 ,'ENIND') ;\n                        \t\t\tNAME_MC2\t= DQMATCH(NAME_STND ,'Name (BSE)', 85 ,'ENIND') ;\n                        \t\t\tNAME_MC3\t= '';\n                        END;\n                        \n                        if\t(SCAN(ADDRESS,3,' ') EQ '' |  LENGTH(COMPRESS(ADDRESS, ' ') ) <10 ) \n                        then do;\n                        \t\tADDRESS_MC1 ='';\n                        \t\tADDRESS_MC2 ='';\n                        \t\tADDRESS_MC3 = '';\n                        \n                        \tend;\n                        else if\t(LENGTH(COMPRESS(ADDRESS, ' ')) >200 ) \n                        \t\t\tthen do;\n                        \t\t\t\tADDRESS_MC1 ='';\n                        \t\t\t\tADDRESS_MC2 ='';\n                        \t\t\t\tADDRESS_MC3 ='';\n                        \tend;\n                        else do;\n                        /*\t\tADDRESS_MC1 = DQMATCH(ADDRESS, 'Address New (BSE)', 75 , 'ENIND') ;*/\n                        \t\tADDRESS_MC1 = '' ;\n                        \t\tADDRESS_MC2\t= DQMATCH(ADDRESS, 'Address New (BSE)', 85 , 'ENIND') ;\n                        \t\tADDRESS_MC3\t= '' ;\n                        \n                        end;\n                        \n                        if (COMPRESS ( NAME_MC1,'$') EQ '' ) then NAME_MC1='';\n                        if (COMPRESS ( NAME_MC2,'$') EQ '' ) then NAME_MC2='';\n                        /*if (COMPRESS ( ADDRESS_MC1,'$') EQ '' ) then ADDRESS_MC1='';*/\n                        if (COMPRESS ( ADDRESS_MC2,'$') EQ '' ) then ADDRESS_MC2='';\n                        \n                        \n                        /**************** Creation of Dedupe Matchcodes and DMC Flags ***************/\n                        /*------------------------DEDUPE_MATCH_CODE_1--------------------------------------*/\n                        if (NAME_MC2 EQ '' |  PAN_STND EQ '' ) \n                        then do ;\n                        \n                        \tDEDUPE_MATCH_CODE_1\t= '' ;\n                        \tDMC_1_FLAG\t\t=\t1 ;\n                        end;\n                        \n                        else do;\n                        \tDEDUPE_MATCH_CODE_1\t= CATX('!',NAME_MC2,PAN_STND) ;\n                        \tDMC_1_FLAG\t\t=\t0 ;\n                        \n                        end;\n                        /*------------------------DEDUPE_MATCH_CODE_2--------------------------------------*/\n                        \n                        if (  ADDRESS_MC2 EQ '' | PAN_STND EQ '' ) \n                        then do ;\n                        \n                        \tDEDUPE_MATCH_CODE_2\t= '' ;\n                        \tDMC_2_FLAG\t\t=\t1 ;\n                        end;\n                        \n                        else do;\n                        \tDEDUPE_MATCH_CODE_2\t= CATX('!',ADDRESS_MC2,PAN_STND )   ;\n                        \tDMC_2_FLAG\t\t=\t0 ;\n                        \n                        end;\n                        \n                        \n                        /*------------------------DEDUPE_MATCH_CODE_3--------------------------------------*/\n                        /*\n                        if (NAME_MC1 EQ '' | ADDRESS_MC1 EQ '' |  DATEOFBIRTH_STND EQ '' )\n                        then do ;\n                        \n                        \tDEDUPE_MATCH_CODE_3\t= '' ;\n                        \tDMC_3_FLAG\t\t=\t1 ;\n                        end;\n                        \n                        else do;\n                        \tDEDUPE_MATCH_CODE_3\t= CATX('!',NAME_MC1,ADDRESS_MC1,DATEOFBIRTH_STND)  ;\n                        \tDMC_3_FLAG\t\t=\t0 ;\n                        \n                        end;\n                        */\n                        \n                        \tDEDUPE_MATCH_CODE_3\t= '' ;\n                        \tDMC_3_FLAG\t\t=\t1 ;\n                        \n                        /*------------------------DEDUPE_MATCH_CODE_4--------------------------------------*/\n                        /*\n                        if (    NAME_MC2 EQ '' | ADDRESS_MC2 EQ '' ) \n                        then do ;\n                        \n                        \tDEDUPE_MATCH_CODE_4\t= '' ;\n                        \tDMC_4_FLAG\t\t=\t1 ;\n                        end;\n                        \n                        else do;\n                        \tDEDUPE_MATCH_CODE_4\t= CATX('!',NAME_MC2,ADDRESS_MC2 )   ;\n                        \tDMC_4_FLAG\t\t=\t0 ;\n                        \n                        end;\t\n                        */\n                        \n                        \tDEDUPE_MATCH_CODE_4\t= '' ;\n                        \tDMC_4_FLAG\t\t=\t1 ;\n                        \n                        \n                        /*------------------------DEDUPE_MATCH_CODE_5--------------------------------------*/\n                        \tDEDUPE_MATCH_CODE_5\t= '' ;\n                        \tDMC_5_FLAG\t\t=\t1 ;\n                        \n                        /*------------------------DEDUPE_MATCH_CODE_6--------------------------------------*/\n                        \n                        \tDEDUPE_MATCH_CODE_6\t= '' ;\n                        \tDMC_6_FLAG\t\t=\t1 ;\n                        \n                        /*------------------------  --------------------------------------*/\n                        run;\n                        \n                              \n                        data saslib.SAS_DIM_DEDUPE_ORG_&ctr (COMPRESS = YES);\n                        set saslib.SAS_DIM_STAGE_ORG_&ctr;\n                                 attrib NEW_UPDATE_FLAG length = $8 \n                                    format = $8.\n                                    informat = $8.; \n                                 attrib UID_NUM length = 8\n                                    format = 8.\n                                    informat = 8.; \n                                 attrib UID_CHAR length = $100\n                                    format = $100.\n                                    informat = $100.; \n                                 attrib SAS_ID length = $25\n                                    format = $25.\n                                    informat = $25.; \n                                 attrib CLUSTER_ID length = 8\n                                    format = 8.\n                                    informat = 8.; \n                                 attrib NAME_STND length = $100\n                                    format = $100.\n                                    informat = $100.; \n                                 attrib ADDRESS_STND length = $300\n                                    format = $300.\n                                    informat = $300.; \n                                 attrib PAN_STND length = $15\n                                    format = $15.\n                                    informat = $15.; \n                                 attrib DATEOFBIRTH_STND length = $25\n                                    format = $25.\n                                    informat = $25.; \n                                 attrib CITY_STND length = $30\n                                    format = $30.\n                                    informat = $30.; \n                                 attrib STATE_STND length = $25\n                                    format = $25.\n                                    informat = $25.; \n                                 attrib COUNTRY_STND length = $25\n                                    format = $25.\n                                    informat = $25.; \n                                 attrib BANK_NAME_STND length = $50\n                                    format = $50.\n                                    informat = $50.; \n                                 attrib NAME_MC1 length = $100\n                                    format = $100.\n                                    informat = $100.; \n                                 attrib NAME_MC2 length = $100\n                                    format = $100.\n                                    informat = $100.; \n                                 attrib NAME_MC3 length = $100\n                                    format = $100.\n                                    informat = $100.; \n                                 attrib ADDRESS_MC1 length = $150\n                                    format = $100.\n                                    informat = $100.; \n                                 attrib ADDRESS_MC2 length = $150\n                                    format = $100.\n                                    informat = $100.; \n                                 attrib ADDRESS_MC3 length = $150\n                                    format = $100.\n                                    informat = $100.; \n                                 attrib DEDUPE_MATCH_CODE_1 length = $200\n                                    format = $200.\n                                    informat = $200.; \n                                 attrib DEDUPE_MATCH_CODE_2 length = $200\n                                    format = $200.\n                                    informat = $200.; \n                                 attrib DEDUPE_MATCH_CODE_3 length = $200\n                                    format = $200.\n                                    informat = $200.; \n                                 attrib DEDUPE_MATCH_CODE_4 length = $200\n                                    format = $200.\n                                    informat = $200.; \n                                 attrib DEDUPE_MATCH_CODE_5 length = $200\n                                    format = $200.\n                                    informat = $200.; \n                                 attrib DEDUPE_MATCH_CODE_6 length = $200\n                                    format = $200.\n                                    informat = $200.; \n                                 attrib DMC_1_FLAG length = 4\n                                    format = 4.\n                                    informat = 4.; \n                                 attrib DMC_2_FLAG length = 4\n                                    format = 4.\n                                    informat = 4.; \n                                 attrib DMC_3_FLAG length = 4\n                                    format = 4.\n                                    informat = 4.; \n                                 attrib DMC_4_FLAG length = 4\n                                    format = 4.\n                                    informat = 4.; \n                                 attrib DMC_5_FLAG length = 4\n                                    format = 4.\n                                    informat = 4.; \n                                 attrib DMC_6_FLAG length = 4\n                                    format = 4.\n                                    informat = 4.; \n                        \n                        \tSAS_ID= CATX('!',put(brokercode,11.), clientcode) ;\n                        \tNAME=upcase(compress(NAME  ,' ','IKNPOH' ));\n                        \n                        \tPANNO =  compress(PANNO  ,' ','IKNPOH' );\t\t\n                        \tCITY=  compress(CITY  ,' ','IKNPOH' );\t\t\n                        \tSTATE=   compress(STATE  ,' ','IKNPOH' );\t\t\n                        \tCOUNTRY=   compress(COUNTRY  ,' ','IKNPOH' );\t\n                        \n                        \n                        \tNAME_STND\t=\tupcase(DQSTANDARDIZE(NAME ,'Name','ENIND'))\t;\n                         \tADDRESS = compress(ADDRESS  ,' ','IKNPOH' );\t\t\n                        \n                        \n                        if (upcase(PANNO) EQ 'AAAAA9999A')\n                        \t\tthen do ;\n                        \t\t\tPAN_STND= '';\n                        \t\tend;\n                        else if (DQPATTERN (upcase(PANNO),'CHARACTER','ENIND') EQ 'AAAAA9999A' ) \n                        \t\tthen do ;\n                        \t\t\tPAN_STND = DQSTANDARDIZE(PANNO ,'Pan','ENIND');\n                        \t\tend;\n                        else PAN_STND ='' ;\n                        \n                        DATEOFBIRTH_STND\t=\tSTRIP(DATEOFBIRTH);\t\n                        \tif DATEOFBIRTH_STND in ('01/01/1900' , '01/01/1800') \n                        \tthen do ; DATEOFBIRTH_STND ='' ; end;\t\n                        \n                        CITY_STND\t=\tupcase(DQSTANDARDIZE(CITY ,'City','ENIND'))\t;\n                        STATE_STND\t=\tupcase(DQSTANDARDIZE(STATE, 'State', 'ENIND'))\t;\n                        COUNTRY_STND =\tupcase(DQSTANDARDIZE( COUNTRY ,'Country','ENIND'))\t; \n                        \n                        if (SCAN(NAME_STND,2,' ') EQ '' |  LENGTH(COMPRESS(NAME_STND, ' ') ) <3 ) \n                        THEN do ;\n                        \t\t\tNAME_MC1='';\n                        \t\t\tNAME_MC2\t='';\n                        \t\t\tNAME_MC3\t\t='';\n                        \tend;\n                        ELSE do;\n                        \t\t\tNAME_MC1=DQMATCH(NAME_STND ,'Organization', 75 ,'ENIND') ;\n                        \t\t\tNAME_MC2\t= DQMATCH(NAME_STND ,'Organization', 85 ,'ENIND');\n                        \t\t\tNAME_MC3\t= '';\n                        END;\n                        \n                        if\t(SCAN(ADDRESS,3,' ') EQ '' |  LENGTH(COMPRESS(ADDRESS, ' ') ) <10 ) \n                        then do;\n                        \t\tADDRESS_MC1 ='';\n                        \t\tADDRESS_MC2 ='';\n                        \t\tADDRESS_MC3 ='';\n                        \n                        \tend;\n                        else if\t(LENGTH(COMPRESS(ADDRESS, ' ')) >200 ) \n                        \t\t\tthen do;\n                        \t\t\t\tADDRESS_MC1 ='';\n                        \t\t\t\tADDRESS_MC2 ='';\n                        \t\t\t\tADDRESS_MC3 ='';\n                        \tend;\n                        else do;\n                        /*\t\tADDRESS_MC1 = DQMATCH(ADDRESS, 'Address New (BSE)', 75 , 'ENIND') ;*/\n                        \t\tADDRESS_MC1 = '' ;\n                        \t\tADDRESS_MC2\t= DQMATCH(ADDRESS, 'Address New (BSE)', 85 , 'ENIND') ;\n                        \t\tADDRESS_MC3\t= '' ;\n                        \n                        end;\n                        \n                        if (COMPRESS ( NAME_MC1,'$') EQ '' ) then NAME_MC1='';\n                        if (COMPRESS ( NAME_MC2,'$') EQ '' ) then NAME_MC2='';\n                        /*if (COMPRESS ( ADDRESS_MC1,'$') EQ '' ) then ADDRESS_MC1='';*/\n                        if (COMPRESS ( ADDRESS_MC2,'$') EQ '' ) then ADDRESS_MC2='';\n                        \n                        /**************** Creation of Dedupe Matchcodes and DMC Flags ***************/\n                        /*------------------------DEDUPE_MATCH_CODE_1--------------------------------------*/\n                        if (NAME_MC2 EQ '' |  PAN_STND EQ '' ) \n                        then do ;\n                        \n                        \tDEDUPE_MATCH_CODE_1\t= '' ;\n                        \tDMC_1_FLAG\t\t=\t1 ;\n                        end;\n                        \n                        else do;\n                        \tDEDUPE_MATCH_CODE_1\t= CATX('!',NAME_MC2,PAN_STND) ;\n                        \tDMC_1_FLAG\t\t=\t0 ;\n                        \n                        end;\n                        /*------------------------DEDUPE_MATCH_CODE_2--------------------------------------*/\n                        if ( ADDRESS_MC2 EQ '' |  PAN_STND EQ ''  )\n                        then do ;\n                        \n                        \tDEDUPE_MATCH_CODE_2\t= '' ;\n                        \tDMC_2_FLAG\t\t=\t1 ;\n                        end;\n                        \n                        else do;\n                        \tDEDUPE_MATCH_CODE_2\t= CATX('!',ADDRESS_MC2,PAN_STND)   ;\n                        \tDMC_2_FLAG\t\t=\t0 ;\n                        \n                        end;\n                        \n                        \n                        /*------------------------DEDUPE_MATCH_CODE_3--------------------------------------*/\n                        /*\n                        if (NAME_MC2 EQ '' |  ADDRESS_MC2 EQ ''  )\n                        then do ;\n                        \n                        \tDEDUPE_MATCH_CODE_3\t= '' ;\n                        \tDMC_3_FLAG\t\t=\t1 ;\n                        end;\n                        \n                        else do;\n                        \tDEDUPE_MATCH_CODE_3\t= CATX('!', NAME_MC2,ADDRESS_MC2)  ;\n                        \tDMC_3_FLAG\t\t=\t0 ;\n                        \n                        end;\n                        */\n                        \n                        \tDEDUPE_MATCH_CODE_3\t= '' ;\n                        \tDMC_3_FLAG\t\t=\t1 ;\n                        \n                        \n                        /*------------------------DEDUPE_MATCH_CODE_4--------------------------------------*/\n                        \n                        \n                        \tDEDUPE_MATCH_CODE_4\t= '' ;\n                        \tDMC_4_FLAG\t\t=\t1 ;\n                        \n                        /*------------------------DEDUPE_MATCH_CODE_5--------------------------------------*/\n                        \n                        \tDEDUPE_MATCH_CODE_5\t= '' ;\n                        \tDMC_5_FLAG\t\t=\t1 ;\n                        \n                        \n                        /*------------------------DEDUPE_MATCH_CODE_6--------------------------------------*/\n                        \n                        \tDEDUPE_MATCH_CODE_6\t= '' ;\n                        \tDMC_6_FLAG\t\t=\t1 ;\n                        \n                        /*------------------------  --------------------------------------*/\n                        run; \n                        \n                        /*proc append base = saslib.SAS_DIM_DEDUPE data = saslib.SAS_DIM_DEDUPE_IND_&i ; */\n                        /*run; */\n                        /*proc append base = saslib.SAS_DIM_DEDUPE data = saslib.SAS_DIM_DEDUPE_ORG_&i ; */\n                        /*run; */\n                        \n                        /*data saslib.SAS_DIM_DEDUPE (COMPRESS = YES);*/\n                        /*set saslib.SAS_DIM_DEDUPE_ORG_&i saslib.SAS_DIM_DEDUPE_IND_&i ;*/\n                        /*run;*/\n                        \n                        \n                        /*---- End of User Written Code  ----*/ \n                        \n                        /*---- Start of Post-Process Code  ----*/ \n                        \n                        \n                        /*---- End of Post-Process Code  ----*/ \n                        \n                        %rcSet(&syserr); \n                        %rcSet(&sqlrc); \n                        \n                        %let etls_endTime = %sysfunc(datetime(),datetime.);\n                        \n                        \n                        \n                        /**  Job end JOB STAND MATCHCODE INCR **/\n                        \n                        /* Reset jobid and name */\n                        %let jobID = %quote(A5HHMQXQ.BB00001T);\n                        %let etls_jobName = %nrquote(3 LOOP JOB STAND MATCHCODE INCR);\n                        \n                        %etls_setClientSideStatus; \n            \n         %mend etls_jobW6E21BQD; \n         \n         %etls_jobW6E21BQD; \n         \n      endrsubmit;\n      \n   %mend etls_processToLoopW6E21BQ3;\n   \n   %local etls_controlTable etls_statusTable etls_controlName \n      etls_processesRunning etls_maxProcesses etls_parameterTable \n      etls_additionalSignonOptions etls_signonRetries;\n   %let etls_controlName = L52_; \n   %let etls_statusTable = work.W5WRWB0N; \n   %let etls_parameterTable = work.W6E21BQN; \n   %let etls_workload = ;\n   %let etls_additionalSignonOptions = ;\n   %let etls_signonRetries = 3;\n   %let &etls_controlName = 0;\n   %let etls_controlTable = saslib.TBL_STND_LOOP_INCR;\n   \n   %put %str(NOTE: Creating status table...);\n   data &etls_statusTable \n      (keep = etls_handleName etls_machineId etls_startTime etls_endTime etls_status \n              etls_jobRC etls_fobs etls_lobs ctr\n      );\n      attrib etls_handleName length = $32\n         label = 'Name of handle to remote session'; \n      attrib etls_machineId length = $32\n         label = 'Name of machine executing the task'; \n      attrib etls_startTime length = 8\n         label = 'Start time of task'; \n      attrib etls_endTime length = 8\n         label = 'End time of task'; \n      attrib etls_status length = $32\n         label = 'Current status of task'; \n      attrib etls_jobRC length = 8\n         label = 'Return code of task'; \n      attrib etls_fobs length = 8\n         label = 'First Observation For every parallel process'; \n      attrib etls_lobs length = 8\n         label = 'Last Observation For every parallel process'; \n      attrib ctr length = 8; \n      set &etls_controlTable;\n   run;\n   \n   %rcSet(&syserr); \n   \n   %put %str(NOTE: Creating parameter table...);\n   proc sql; \n      create table &etls_parameterTable as \n         select etls_fobs as i, \n                etls_lobs as n, \n                ctr as ctr \n         from &etls_controlTable; \n   quit; \n   \n   %rcSet(&sqlrc); \n   \n   /* Get the number of times to iterate from the number of rows in the source  */ \n   /*  table                                                                    */ \n   proc sql noprint; \n      select count(*) into :&etls_controlName._max from &etls_statusTable;\n      %let &etls_controlName._max = &&&etls_controlName._max;\n   quit;\n   \n   %rcSet(&sqlrc); \n   \n   %let etls_gridInstalled =;\n   %etls_tsLevel(macroName=etls_gridInstalled, featureName=uwugrdsv); \n   \n   %if (%str(&etls_gridInstalled) ne %str()) %then \n   %do; \n      %let etls_maxProcesses = %sysfunc(grdsvc_nnodes(\"SASApp\")); \n      %if (&etls_maxProcesses = 0) %then \n      %do; \n         %put %str(NOTE: No configured grid nodes were found; setting maximum concurrent\n               processes to SYSNCPU value.);\n         %let etls_maxProcesses = &SYSNCPU;\n      %end; \n   %end; \n   %else \n   %do; \n      %put %str(NOTE: Grid service functions are not installed; setting maximum concurrent\n            processes to SYSNCPU value.);\n      %let etls_maxProcesses = &SYSNCPU;\n   %end; \n   \n   %if (&etls_maxProcesses > 0) %then \n   %do; \n      %do %until (&&&etls_controlName ge &&&etls_controlName._max); \n      \n         %let etls_lastLoopPtr = &&&etls_controlName;\n         \n         %etls_getProcessesRunning(statusTable=&etls_statusTable, statusVariable=etls_status, \n            processCountMacro=etls_processesRunning, statusSetting=\"Running\");\n            \n         %do %while(&etls_processesRunning lt &&&etls_controlName._max \n            and &etls_processesRunning lt &etls_maxProcesses \n            and &&&etls_controlName lt &&&etls_controlName._max);\n            \n            %let &etls_controlName = %eval(&&&etls_controlName+1);\n            \n            %global etls_signonStatus; \n            %let etls_logOutputPath = /home/sasdemo/bse_di/loop_jobs_logs; \n            \n            %etls_createHandle(statusTable=&etls_statusTable, statusVariable=etls_status, \n               handleVariable=etls_handleName, handlePrefix=&etls_controlName, \n               statusSetting=\"Running\", \n               row=&&&etls_controlName, machineVariable=etls_machineId, \n               startTimeVariable=etls_startTime, cmacvar=etls_signonStatus, signon=1, useGrid=1, \n               additionalSignonOptions=&etls_additionalSignonOptions, signonRetries=&etls_signonRetries);\n               \n            %etls_getProcessesRunning(statusTable=&etls_statusTable, statusVariable=etls_status, \n               processCountMacro=etls_processesRunning, statusSetting=\"Running\");\n               \n            %if &etls_processesRunning > 0 and &etls_signonStatus ne 1 %then \n               %etls_processToLoopW6E21BQ3(parameterTable=&etls_parameterTable, row=&&&etls_controlName,\n                  handleName=%etls_getHandle(statusTable=&etls_statusTable,\n                  handleVariable=etls_handleName, row=&&&etls_controlName)); \n            %else \n            %do; /* if signon error, set iterator to max to force loop to stop. */ \n               %let &etls_controlName = &&&etls_controlName._max; \n               %put %str(ERROR%QUOTE(:) A parallel process did not start.  Exiting loop.);\n            %end; \n         %end; \n         \n         %etls_waitFor(statusTable=&etls_statusTable, statusVariable=etls_status, \n            runningStatusSetting=\"Running\", handleVariable=etls_handleName, \n            completeStatusSetting=\"Finished\", endTimeVariable=etls_endTime, \n            startTimeVariable=etls_startTime, waitType=_ANY_, signoff=1, \n            returnCodeVariable=etls_jobRC, \n            statusUnknownReturnCode=.); \n            \n      %end; \n      \n      %etls_waitFor(statusTable=&etls_statusTable, statusVariable=etls_status, \n         runningStatusSetting=\"Running\", handleVariable=etls_handleName, \n         completeStatusSetting=\"Finished\", endTimeVariable=etls_endTime, \n         startTimeVariable=etls_startTime, waitType=_ALL_, signoff=1, \n         returnCodeVariable=etls_jobRC, \n         statusUnknownReturnCode=.); \n         \n   %end;\n   \n   proc datasets lib = work nolist nowarn memtype = (data view);\n      delete W6E21BQN;\n   quit;\n   \n%mend etls_loopW6E21BPT; \n\n%etls_loopW6E21BPT; \n\n\n\n/**  Step end Loop **/\n\n/*============================================================================* \n * Step:            Loop End                                A5HHMQXQ.BJ00004A * \n * Transform:       Loop End                                                  * \n * Description:                                                               * \n *============================================================================*/ \n\n%let transformID = %quote(A5HHMQXQ.BJ00004A);\n%let trans_rc = 0;\n%let etls_stepStartTime = %sysfunc(datetime(), datetime20.); \n\n\n\n/**  Step end Loop End **/\n\n/*---- Start of Post-Process Code  ----*/ \n\n\ndata saslib.sas_dim_dedupe_incr(compress=yes);\nset saslib.sas_dim_dedupe(obs=0);\nrun;\n\nproc sql noprint;\nselect max(ctr) into:maxctr from saslib.TBL_STND_LOOP_INCR;\nquit;\n\n%macro evalmac(maxctr);\n\n%do i = 1 %to &maxctr %by 1;\t\n\nproc append base = saslib.sas_dim_dedupe_incr \n\tdata =  saslib.SAS_DIM_DEDUPE_IND_&i ;  \nrun;\t\nproc append base = saslib.sas_dim_dedupe_incr \n\tdata =  saslib.SAS_DIM_DEDUPE_ORG_&i ;  \nrun;\t\n\n%end;\n\n%mend evalmac;\n\n%evalmac(&maxctr);\n\n\n\n/*Bellow code is for insert/update of INCR records in SAS_DIM_DEDUPE */\nPROC SQL ;\t\n\tdelete from saslib.sas_dim_dedupe where  sas_id \n\t\tin (select  sas_id from saslib.sas_dim_dedupe_incr );\n;\nQUIT; \n\nproc append base = saslib.SAS_DIM_DEDUPE data = saslib.sas_dim_dedupe_incr ; \nrun;\n/*---- End of Post-Process Code  ----*/ \n\n%rcSet(&syserr); \n%rcSet(&sqlrc); \n\n%let etls_endTime = %sysfunc(datetime(),datetime.);\n"
    },
    {
      "role": "assistant",
      "content": "step: think\ncontent: |\n  Now I have a much better understanding of the BSEProject repository. After examining multiple files, I can see that this is a sophisticated financial data processing system for the Bombay Stock Exchange. Let me summarize what I've discovered:\n\n  1. **Project Purpose**: This project appears to be a data processing and analysis system focused on financial market data from the Bombay Stock Exchange (BSE). It primarily does:\n     - Data deduplication and standardization\n     - Detection of insider trading around company announcements \n     - Clustering and matching of financial records\n     - Generation of reports for suspicious trading activity\n\n  2. **Technical Components**:\n     - SAS code for data processing and statistical analysis\n     - SQL queries for data manipulation\n     - Data clustering and matching algorithms\n     - Parallel processing capabilities\n     - Report generation in Excel format\n\n  3. **Key Features**:\n     - Processing of stock trading data\n     - Analysis of trading patterns before and after company announcements\n     - Standardization of personal information (names, addresses, etc.)\n     - Creation of match codes for deduplication\n     - Insider trading detection through statistical models and scoring\n     - Data quality management\n\n  4. **Project Structure**:\n     - SAS scripts for data processing\n     - SQL files for database operations\n     - Configuration settings for data quality and standardization\n     - Documentation in Excel format\n     - Parallel processing capabilities for handling large datasets\n\n  Now I'll create a comprehensive HTML report summarizing these findings and providing more detailed analysis of the repository."
    },
    {
      "role": "user",
      "content": "Continue to the next step."
    },
    {
      "role": "assistant",
      "content": "step: action\ntool: fileManager\ninput: fileManager('write', 'bse_project_report.html', '<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>BSE Project Repository Analysis</title>\n    <style>\n        body {\n            font-family: Arial, sans-serif;\n            line-height: 1.6;\n            margin: 0;\n            padding: 20px;\n            color: #333;\n            max-width: 1200px;\n            margin: 0 auto;\n        }\n        h1 {\n            color: #2c3e50;\n            border-bottom: 2px solid #3498db;\n            padding-bottom: 10px;\n        }\n        h2 {\n            color: #3498db;\n            margin-top: 30px;\n        }\n        h3 {\n            color: #2980b9;\n        }\n        pre {\n            background-color: #f8f9fa;\n            border: 1px solid #ddd;\n            border-radius: 4px;\n            padding: 15px;\n            overflow-x: auto;\n            font-size: 14px;\n        }\n        code {\n            font-family: Consolas, Monaco, \"Andale Mono\", monospace;\n        }\n        .section {\n            margin-bottom: 40px;\n        }\n        table {\n            border-collapse: collapse;\n            width: 100%;\n            margin: 20px 0;\n        }\n        th, td {\n            border: 1px solid #ddd;\n            padding: 8px 12px;\n            text-align: left;\n        }\n        th {\n            background-color: #f2f2f2;\n        }\n        .file-structure {\n            margin-left: 20px;\n        }\n        .highlight {\n            background-color: #ffffcc;\n            padding: 2px;\n        }\n        .warning {\n            color: #e74c3c;\n        }\n        .success {\n            color: #27ae60;\n        }\n    </style>\n</head>\n<body>\n    <h1>BSE Project Repository Analysis</h1>\n    \n    <div class=\"section\">\n        <h2>Executive Summary</h2>\n        <p>\n            This report provides a comprehensive analysis of the BSEProject repository found at <code>/home/rishav/Documents/Code/6th-sense/Optqo_repo_function/repository/BSEProject</code>. \n            The project is a sophisticated data processing and analysis system focused on Bombay Stock Exchange (BSE) financial data, \n            with particular emphasis on detecting insider trading patterns, data standardization, and record deduplication.\n        </p>\n        <p>\n            The system uses SAS (Statistical Analysis System) and SQL for data manipulation, standardization, \n            and advanced statistical analysis. It includes components for parallel processing, data quality management, \n            and automated report generation.\n        </p>\n    </div>\n\n    <div class=\"section\">\n        <h2>Repository Structure</h2>\n        <p>The repository contains the following key files:</p>\n        <ul class=\"file-structure\">\n            <li><strong>1st Part.sas</strong> - Initial data extraction and announcement analysis</li>\n            <li><strong>2ndQuery.txt, 3rdQuery.txt</strong> - SQL query files for data extraction</li>\n            <li><strong>4thQuery.txt</strong> - Main script for insider trading analysis with multiple parts</li>\n            <li><strong>JOB ASSIGN CLUSTER ID INCR_4.sql</strong> - SQL job for cluster ID assignment</li>\n            <li><strong>JOB REJECT INVALID DATA INCR_2.sql</strong> - SQL job for filtering invalid data</li>\n            <li><strong>LOOP JOB STAND MATCHCODE INCR _3.sql</strong> - SQL job for data standardization</li>\n            <li><strong>README.md</strong"
    },
    {
      "role": "user",
      "content": "OBSERVE: Error: Could not parse fileManager parameters"
    },
    {
      "role": "assistant",
      "content": "step: action\ntool: fileManager\ninput: fileManager('write', 'bse_project_report.html', '<!DOCTYPE html>\\n<html lang=\"en\">\\n<head>\\n    <meta charset=\"UTF-8\">\\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\\n    <title>BSE Project Repository Analysis</title>\\n    <style>\\n        body {\\n            font-family: Arial, sans-serif;\\n            line-height: 1.6;\\n            margin: 0;\\n            padding: 20px;\\n            color: #333;\\n            max-width: 1200px;\\n            margin: 0 auto;\\n        }\\n        h1 {\\n            color: #2c3e50;\\n            border-bottom: 2px solid #3498db;\\n            padding-bottom: 10px;\\n        }\\n        h2 {\\n            color: #3498db;\\n            margin-top: 30px;\\n        }\\n        h3 {\\n            color: #2980b9;\\n        }\\n        pre {\\n            background-color: #f8f9fa;\\n            border: 1px solid #ddd;\\n            border-radius: 4px;\\n            padding: 15px;\\n            overflow-x: auto;\\n            font-size: 14px;\\n        }\\n        code {\\n            font-family: Consolas, Monaco, \"Andale Mono\", monospace;\\n        }\\n        .section {\\n            margin-bottom: 40px;\\n        }\\n        table {\\n            border-collapse: collapse;\\n            width: 100%;\\n            margin: 20px 0;\\n        }\\n        th, td {\\n            border: 1px solid #ddd;\\n            padding: 8px 12px;\\n            text-align: left;\\n        }\\n        th {\\n            background-color: #f2f2f2;\\n        }\\n        .file-structure {\\n            margin-left: 20px;\\n        }\\n        .highlight {\\n            background-color: #ffffcc;\\n            padding: 2px;\\n        }\\n        .warning {\\n            color: #e74c3c;\\n        }\\n        .success {\\n            color: #27ae60;\\n        }\\n    </style>\\n</head>\\n<body>\\n    <h1>BSE Project Repository Analysis</h1>\\n    \\n    <div class=\"section\">\\n        <h2>Executive Summary</h2>\\n        <p>\\n            This report provides a comprehensive analysis of the BSEProject repository found at <code>/home/rishav/Documents/Code/6th-sense/Optqo_repo_function/repository/BSEProject</code>. \\n            The project is a sophisticated data processing and analysis system focused on Bombay Stock Exchange (BSE) financial data, \\n            with particular emphasis on detecting insider trading patterns, data standardization, and record deduplication.\\n        </p>\\n        <p>\\n            The system uses SAS (Statistical Analysis System) and SQL for data manipulation, standardization, \\n            and advanced statistical analysis. It includes components for parallel processing, data quality management, \\n            and automated report generation.\\n        </p>\\n    </div>')"
    },
    {
      "role": "user",
      "content": "OBSERVE: Successfully wrote 2666 characters to /home/rishav/Documents/Code/6th-sense/Optqo_repo_function/bse_project_report.html"
    },
    {
      "role": "assistant",
      "content": "step: action\ntool: fileManager\ninput: fileManager('write', 'bse_project_report.html', '<!DOCTYPE html>\\n<html lang=\"en\">\\n<head>\\n    <meta charset=\"UTF-8\">\\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\\n    <title>BSE Project Repository Analysis</title>\\n    <style>\\n        body {\\n            font-family: Arial, sans-serif;\\n            line-height: 1.6;\\n            margin: 0;\\n            padding: 20px;\\n            color: #333;\\n            max-width: 1200px;\\n            margin: 0 auto;\\n        }\\n        h1 {\\n            color: #2c3e50;\\n            border-bottom: 2px solid #3498db;\\n            padding-bottom: 10px;\\n        }\\n        h2 {\\n            color: #3498db;\\n            margin-top: 30px;\\n        }\\n        h3 {\\n            color: #2980b9;\\n        }\\n        pre {\\n            background-color: #f8f9fa;\\n            border: 1px solid #ddd;\\n            border-radius: 4px;\\n            padding: 15px;\\n            overflow-x: auto;\\n            font-size: 14px;\\n        }\\n        code {\\n            font-family: Consolas, Monaco, \"Andale Mono\", monospace;\\n        }\\n        .section {\\n            margin-bottom: 40px;\\n        }\\n        table {\\n            border-collapse: collapse;\\n            width: 100%;\\n            margin: 20px 0;\\n        }\\n        th, td {\\n            border: 1px solid #ddd;\\n            padding: 8px 12px;\\n            text-align: left;\\n        }\\n        th {\\n            background-color: #f2f2f2;\\n        }\\n        .file-structure {\\n            margin-left: 20px;\\n        }\\n        .highlight {\\n            background-color: #ffffcc;\\n            padding: 2px;\\n        }\\n        .warning {\\n            color: #e74c3c;\\n        }\\n        .success {\\n            color: #27ae60;\\n        }\\n    </style>\\n</head>\\n<body>\\n    <h1>BSE Project Repository Analysis</h1>\\n    \\n    <div class=\"section\">\\n        <h2>Executive Summary</h2>\\n        <p>\\n            This report provides a comprehensive analysis of the BSEProject repository found at <code>/home/rishav/Documents/Code/6th-sense/Optqo_repo_function/repository/BSEProject</code>. \\n            The project is a sophisticated data processing and analysis system focused on Bombay Stock Exchange (BSE) financial data, \\n            with particular emphasis on detecting insider trading patterns, data standardization, and record deduplication.\\n        </p>\\n        <p>\\n            The system uses SAS (Statistical Analysis System) and SQL for data manipulation, standardization, \\n            and advanced statistical analysis. It includes components for parallel processing, data quality management, \\n            and automated report generation.\\n        </p>\\n    </div>\\n\\n    <div class=\"section\">\\n        <h2>Repository Structure</h2>\\n        <p>The repository contains the following key files:</p>\\n        <ul class=\"file-structure\">\\n            <li><strong>1st Part.sas</strong> - Initial data extraction and announcement analysis</li>\\n            <li><strong>2ndQuery.txt, 3rdQuery.txt</strong> - SQL query files for data extraction</li>\\n            <li><strong>4thQuery.txt</strong> - Main script for insider trading analysis with multiple parts</li>\\n            <li><strong>JOB ASSIGN CLUSTER ID INCR_4.sql</strong> - SQL job for cluster ID assignment</li>\\n            <li><strong>JOB REJECT INVALID DATA INCR_2.sql</strong> - SQL job for filtering invalid data</li>\\n            <li><strong>LOOP JO"
    },
    {
      "role": "user",
      "content": "OBSERVE: Error: Could not parse fileManager parameters"
    },
    {
      "role": "assistant",
      "content": "step: action\ntool: fileManager\ninput: fileManager('write', 'bse_project_report_part1.html', '<!DOCTYPE html>\\n<html lang=\"en\">\\n<head>\\n    <meta charset=\"UTF-8\">\\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\\n    <title>BSE Project Repository Analysis</title>\\n    <style>\\n        body {\\n            font-family: Arial, sans-serif;\\n            line-height: 1.6;\\n            margin: 0;\\n            padding: 20px;\\n            color: #333;\\n            max-width: 1200px;\\n            margin: 0 auto;\\n        }\\n        h1 {\\n            color: #2c3e50;\\n            border-bottom: 2px solid #3498db;\\n            padding-bottom: 10px;\\n        }\\n        h2 {\\n            color: #3498db;\\n            margin-top: 30px;\\n        }\\n        h3 {\\n            color: #2980b9;\\n        }\\n        pre {\\n            background-color: #f8f9fa;\\n            border: 1px solid #ddd;\\n            border-radius: 4px;\\n            padding: 15px;\\n            overflow-x: auto;\\n            font-size: 14px;\\n        }\\n        code {\\n            font-family: Consolas, Monaco, \"Andale Mono\", monospace;\\n        }\\n        .section {\\n            margin-bottom: 40px;\\n        }\\n        table {\\n            border-collapse: collapse;\\n            width: 100%;\\n            margin: 20px 0;\\n        }\\n        th, td {\\n            border: 1px solid #ddd;\\n            padding: 8px 12px;\\n            text-align: left;\\n        }\\n        th {\\n            background-color: #f2f2f2;\\n        }\\n        .file-structure {\\n            margin-left: 20px;\\n        }\\n        .highlight {\\n            background-color: #ffffcc;\\n            padding: 2px;\\n        }\\n        .warning {\\n            color: #e74c3c;\\n        }\\n        .success {\\n            color: #27ae60;\\n        }\\n    </style>\\n</head>\\n<body>\\n    <h1>BSE Project Repository Analysis</h1>\\n    \\n    <div class=\"section\">\\n        <h2>Executive Summary</h2>\\n        <p>\\n            This report provides a comprehensive analysis of the BSEProject repository found at <code>/home/rishav/Documents/Code/6th-sense/Optqo_repo_function/repository/BSEProject</code>. \\n            The project is a sophisticated data processing and analysis system focused on Bombay Stock Exchange (BSE) financial data, \\n            with particular emphasis on detecting insider trading patterns, data standardization, and record deduplication.\\n        </p>\\n        <p>\\n            The system uses SAS (Statistical Analysis System) and SQL for data manipulation, standardization, \\n            and advanced statistical analysis. It includes components for parallel processing, data quality management, \\n            and automated report generation.\\n        </p>\\n    </div>')"
    },
    {
      "role": "user",
      "content": "OBSERVE: Successfully wrote 2666 characters to /home/rishav/Documents/Code/6th-sense/Optqo_repo_function/bse_project_report_part1.html"
    },
    {
      "role": "assistant",
      "content": "step: action\ntool: fileManager\ninput: fileManager('write', 'bse_project_report_part2.html', '\\n    <div class=\"section\">\\n        <h2>Repository Structure</h2>\\n        <p>The repository contains the following key files:</p>\\n        <ul class=\"file-structure\">\\n            <li><strong>1st Part.sas</strong> - Initial data extraction and announcement analysis</li>\\n            <li><strong>2ndQuery.txt, 3rdQuery.txt</strong> - SQL query files for data extraction</li>\\n            <li><strong>4thQuery.txt</strong> - Main script for insider trading analysis with multiple parts</li>\\n            <li><strong>JOB ASSIGN CLUSTER ID INCR_4.sql</strong> - SQL job for cluster ID assignment</li>\\n            <li><strong>JOB REJECT INVALID DATA INCR_2.sql</strong> - SQL job for filtering invalid data</li>\\n            <li><strong>LOOP JOB STAND MATCHCODE INCR _3.sql</strong> - SQL job for data standardization</li>\\n            <li><strong>README.md</strong> - Minimal project documentation</li>\\n            <li><strong>SAS Code for Revised Insider Daily PAN.txt</strong> - SAS code for insider detection</li>\\n            <li><strong>SAS_Code_Understanding.xls</strong> - Excel documentation of the codebase</li>\\n        </ul>\\n    </div>\\n\\n    <div class=\"section\">\\n        <h2>Technical Architecture</h2>\\n        <p>\\n            The BSE Project implements a comprehensive data processing pipeline focused on financial data analysis. The key technical components include:\\n        </p>\\n\\n        <h3>1. Data Sources and Extraction</h3>\\n        <p>\\n            The system connects to data sources that appear to be from the Bombay Stock Exchange, including:\\n        </p>\\n        <ul>\\n            <li>Company announcement data</li>\\n            <li>Company scrip (stock) master data</li>\\n            <li>Member scrip client summary (trading data)</li>\\n            <li>Scrip summary (market data)</li>\\n            <li>UCC (Unique Client Code) dimension data</li>\\n        </ul>\\n\\n        <h3>2. Data Processing Pipeline</h3>\\n        <p>\\n            The codebase implements several sequential processing stages:\\n        </p>\\n        <ol>\\n            <li><strong>Data Standardization</strong> - Standardizing names, addresses, PAN numbers, and other fields</li>\\n            <li><strong>Match Code Generation</strong> - Creating match codes for deduplication</li>\\n            <li><strong>Clustering</strong> - Grouping similar records</li>\\n            <li><strong>Analysis</strong> - Detecting patterns indicative of insider trading</li>\\n            <li><strong>Reporting</strong> - Generating reports and Excel outputs</li>\\n        </ol>\\n\\n        <h3>3. Parallel Processing Architecture</h3>\\n        <p>\\n            The system implements a parallel processing framework that distributes workload across multiple CPU cores or grid nodes. Key components include:\\n        </p>\\n        <ul>\\n            <li>Task distribution across multiple processing units</li>\\n            <li>Parameterized remote job execution</li>\\n            <li>Synchronization mechanisms for job completion</li>\\n            <li>Status tracking and logging</li>\\n        </ul>\\n    </div>')"
    },
    {
      "role": "user",
      "content": "OBSERVE: Successfully wrote 3097 characters to /home/rishav/Documents/Code/6th-sense/Optqo_repo_function/bse_project_report_part2.html"
    },
    {
      "role": "assistant",
      "content": "step: action\ntool: fileManager\ninput: fileManager('write', 'bse_project_report_part3.html', '\\n    <div class=\"section\">\\n        <h2>Key Functionalities</h2>\\n\\n        <h3>1. Data Deduplication and Standardization</h3>\\n        <p>\\n            A significant portion of the codebase is dedicated to data standardization and deduplication. This includes:\\n        </p>\\n        <ul>\\n            <li><strong>Name Standardization</strong> - Using SAS Data Quality functions to standardize individual and organization names</li>\\n            <li><strong>Address Standardization</strong> - Processing address fields to create consistent formats</li>\\n            <li><strong>PAN Number Validation</strong> - Validating and standardizing PAN (Permanent Account Number) fields</li>\\n            <li><strong>Match Code Generation</strong> - Creating match codes for names and addresses at different confidence levels (75%, 85%)</li>\\n            <li><strong>Cluster ID Assignment</strong> - Grouping similar records based on match codes</li>\\n        </ul>\\n\\n        <h3>2. Insider Trading Detection</h3>\\n        <p>\\n            The system implements sophisticated algorithms to detect potential insider trading patterns around company announcements:\\n        </p>\\n        <ul>\\n            <li><strong>Announcement Analysis</strong> - Scanning company announcements for significant events like mergers, dividends, rights issues</li>\\n            <li><strong>Trading Pattern Analysis</strong> - Analyzing buying and selling patterns before and after announcements</li>\\n            <li><strong>Statistical Modeling</strong> - Using scoring models to identify suspicious trading activity</li>\\n            <li><strong>Transaction Profiling</strong> - Examining transaction sizes, timing, and price variations</li>\\n            <li><strong>Profit Calculation</strong> - Calculating actual and notional profits from potentially suspicious trades</li>\\n        </ul>\\n        <p>\\n            The insider trading detection algorithm pays special attention to:\\n        </p>\\n        <ul>\\n            <li>Trading volume relative to market volume</li>\\n            <li>Timing of trades relative to announcements</li>\\n            <li>Holding patterns (long vs. short positions)</li>\\n            <li>Buy/sell ratios before and after announcements</li>\\n            <li>Profit realization patterns</li>\\n        </ul>\\n\\n        <h3>3. Reporting and Output Generation</h3>\\n        <p>\\n            The system generates various reports to support analysis:\\n        </p>\\n        <ul>\\n            <li><strong>Announcement Reports</strong> - Details of company announcements with classification</li>\\n            <li><strong>Summary Reports</strong> - Suspicious trading activity summaries</li>\\n            <li><strong>Transaction Reports</strong> - Detailed transaction logs for suspicious accounts</li>\\n            <li><strong>Market Behavior Reports</strong> - Analysis of trading patterns across the market</li>\\n        </ul>\\n        <p>\\n            Reports are exported to Excel format with multiple sheets for different views of the data.\\n        </p>\\n    </div>')"
    },
    {
      "role": "user",
      "content": "OBSERVE: Successfully wrote 3075 characters to /home/rishav/Documents/Code/6th-sense/Optqo_repo_function/bse_project_report_part3.html"
    },
    {
      "role": "assistant",
      "content": "step: action\ntool: fileManager\ninput: fileManager('write', 'bse_project_report_part4.html', '\\n    <div class=\"section\">\\n        <h2>Code Analysis</h2>\\n\\n        <h3>1. SAS Data Processing</h3>\\n        <p>\\n            The project makes extensive use of SAS (Statistical Analysis System) for data processing. Key aspects include:\\n        </p>\\n        <ul>\\n            <li><strong>SAS Macros</strong> - Extensive use of macros for parameterized and reusable code blocks</li>\\n            <li><strong>SAS SQL</strong> - Complex SQL queries embedded within SAS for data manipulation</li>\\n            <li><strong>Data Step Processing</strong> - Advanced data transformations using SAS data steps</li>\\n            <li><strong>SAS Data Quality Functions</strong> - Usage of specialized functions for data standardization</li>\\n        </ul>\\n\\n        <h3>2. Complex SQL Operations</h3>\\n        <p>\\n            The SQL files implement sophisticated database operations:\\n        </p>\\n        <ul>\\n            <li><strong>Complex Joins</strong> - Multiple table joins for integrated data analysis</li>\\n            <li><strong>Aggregations</strong> - Statistical aggregations for pattern detection</li>\\n            <li><strong>Window Functions</strong> - Analysis of time-series patterns in trading data</li>\\n            <li><strong>Incremental Processing</strong> - Efficient handling of incremental data updates</li>\\n        </ul>\\n\\n        <h3>3. Statistical Models</h3>\\n        <p>\\n            The insider trading detection incorporates statistical models for scoring and ranking suspicious activities:\\n        </p>\\n        <ul>\\n            <li><strong>Ranking Algorithms</strong> - Ranking transactions based on multiple indicators</li>\\n            <li><strong>Weighted Scoring</strong> - Different weights assigned to various trading patterns</li>\\n            <li><strong>Threshold-based Classification</strong> - Classification of trading patterns using defined thresholds</li>\\n            <li><strong>Pattern Recognition</strong> - Identification of known suspicious patterns in trading data</li>\\n        </ul>\\n    </div>\\n\\n    <div class=\"section\">\\n        <h2>Performance Considerations</h2>\\n        <p>\\n            The codebase incorporates several performance optimization techniques:\\n        </p>\\n        <ul>\\n            <li><strong>Parallel Processing</strong> - Distribution of workload across multiple processing units</li>\\n            <li><strong>Data Compression</strong> - Use of compression for large datasets (COMPRESS=YES)</li>\\n            <li><strong>Indexed Access</strong> - Creation and use of indexes for efficient data retrieval</li>\\n            <li><strong>In-Memory Processing</strong> - Hash table implementations for high-performance lookups</li>\\n            <li><strong>Incremental Processing</strong> - Processing only new or changed records</li>\\n        </ul>\\n    </div>')"
    },
    {
      "role": "user",
      "content": "OBSERVE: Successfully wrote 2845 characters to /home/rishav/Documents/Code/6th-sense/Optqo_repo_function/bse_project_report_part4.html"
    },
    {
      "role": "assistant",
      "content": "step: action\ntool: fileManager\ninput: fileManager('write', 'bse_project_report_part5.html', '\\n    <div class=\"section\">\\n        <h2>Technical Observations and Findings</h2>\\n\\n        <h3>Strengths</h3>\\n        <ul>\\n            <li><strong>Sophisticated Analysis</strong> - Advanced statistical methods for insider trading detection</li>\\n            <li><strong>Efficient Data Processing</strong> - Well-designed parallel processing architecture</li>\\n            <li><strong>Data Quality Focus</strong> - Extensive data standardization and quality control</li>\\n            <li><strong>Scalability</strong> - Designed to handle large datasets efficiently</li>\\n            <li><strong>Comprehensive Reporting</strong> - Detailed reports for analysis and investigation</li>\\n        </ul>\\n\\n        <h3>Areas for Improvement</h3>\\n        <ul>\\n            <li><strong>Limited Documentation</strong> - The README.md is minimal, making it challenging for new developers</li>\\n            <li><strong>Complex Codebase</strong> - High complexity that could benefit from more modularization</li>\\n            <li><strong>Hard-coded Parameters</strong> - Some parameters are hard-coded rather than externalized</li>\\n            <li><strong>Error Handling</strong> - Could benefit from more robust error handling in some areas</li>\\n        </ul>\\n    </div>\\n\\n    <div class=\"section\">\\n        <h2>Conclusion</h2>\\n        <p>\\n            The BSEProject repository contains a sophisticated financial data analysis system focused on \\n            insider trading detection, data standardization, and record deduplication for the Bombay Stock Exchange. \\n            It demonstrates advanced use of SAS and SQL for complex data processing and analysis.\\n        </p>\\n        <p>\\n            The system\\'s strengths lie in its statistical analysis capabilities, parallel processing architecture, \\n            and comprehensive reporting. Areas for improvement include documentation, code organization, and error handling.\\n        </p>\\n        <p>\\n            Overall, this appears to be a production-grade system for financial market analysis with a \\n            specific focus on detecting suspicious trading patterns around company announcements.\\n        </p>\\n    </div>\\n</body>\\n</html>')"
    },
    {
      "role": "user",
      "content": "OBSERVE: Error: Could not parse fileManager parameters"
    },
    {
      "role": "assistant",
      "content": "step: action\ntool: fileManager\ninput: fileManager('write', 'bse_project_report_part5.html', '\\n    <div class=\"section\">\\n        <h2>Technical Observations and Findings</h2>\\n\\n        <h3>Strengths</h3>\\n        <ul>\\n            <li><strong>Sophisticated Analysis</strong> - Advanced statistical methods for insider trading detection</li>\\n            <li><strong>Efficient Data Processing</strong> - Well-designed parallel processing architecture</li>\\n            <li><strong>Data Quality Focus</strong> - Extensive data standardization and quality control</li>\\n            <li><strong>Scalability</strong> - Designed to handle large datasets efficiently</li>\\n            <li><strong>Comprehensive Reporting</strong> - Detailed reports for analysis and investigation</li>\\n        </ul>\\n\\n        <h3>Areas for Improvement</h3>\\n        <ul>\\n            <li><strong>Limited Documentation</strong> - The README.md is minimal, making it challenging for new developers</li>\\n            <li><strong>Complex Codebase</strong> - High complexity that could benefit from more modularization</li>\\n            <li><strong>Hard-coded Parameters</strong> - Some parameters are hard-coded rather than externalized</li>\\n            <li><strong>Error Handling</strong> - Could benefit from more robust error handling in some areas</li>\\n        </ul>\\n    </div>')"
    },
    {
      "role": "user",
      "content": "OBSERVE: Successfully wrote 1266 characters to /home/rishav/Documents/Code/6th-sense/Optqo_repo_function/bse_project_report_part5.html"
    },
    {
      "role": "assistant",
      "content": "step: action\ntool: fileManager\ninput: fileManager('write', 'bse_project_report_part6.html', '\\n    <div class=\"section\">\\n        <h2>Conclusion</h2>\\n        <p>\\n            The BSEProject repository contains a sophisticated financial data analysis system focused on \\n            insider trading detection, data standardization, and record deduplication for the Bombay Stock Exchange. \\n            It demonstrates advanced use of SAS and SQL for complex data processing and analysis.\\n        </p>\\n        <p>\\n            The system\\'s strengths lie in its statistical analysis capabilities, parallel processing architecture, \\n            and comprehensive reporting. Areas for improvement include documentation, code organization, and error handling.\\n        </p>\\n        <p>\\n            Overall, this appears to be a production-grade system for financial market analysis with a \\n            specific focus on detecting suspicious trading patterns around company announcements.\\n        </p>\\n    </div>\\n</body>\\n</html>')"
    },
    {
      "role": "user",
      "content": "OBSERVE: Error: Could not parse fileManager parameters"
    },
    {
      "role": "assistant",
      "content": "step: action\ntool: fileManager\ninput: fileManager('write', 'bse_project_report_part6.html', '\\n    <div class=\"section\">\\n        <h2>Conclusion</h2>\\n        <p>\\n            The BSEProject repository contains a sophisticated financial data analysis system focused on insider trading detection, data standardization, and record deduplication for the Bombay Stock Exchange. It demonstrates advanced use of SAS and SQL for complex data processing and analysis.\\n        </p>\\n        <p>\\n            The system\\'s strengths lie in its statistical analysis capabilities, parallel processing architecture, and comprehensive reporting. Areas for improvement include documentation, code organization, and error handling.\\n        </p>\\n        <p>\\n            Overall, this appears to be a production-grade system for financial market analysis with a specific focus on detecting suspicious trading patterns around company announcements.\\n        </p>\\n    </div>\\n</body>\\n</html>')"
    },
    {
      "role": "user",
      "content": "OBSERVE: Error: Could not parse fileManager parameters"
    },
    {
      "role": "assistant",
      "content": "step: action\ntool: fileManager\ninput: fileManager('write', 'bse_project_report_final.html', '<!DOCTYPE html>\\n<html lang=\"en\">\\n<head>\\n    <meta charset=\"UTF-8\">\\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\\n    <title>BSE Project Repository Analysis</title>\\n    <style>\\n        body {\\n            font-family: Arial, sans-serif;\\n            line-height: 1.6;\\n            margin: 0;\\n            padding: 20px;\\n            color: #333;\\n            max-width: 1200px;\\n            margin: 0 auto;\\n        }\\n        h1 {\\n            color: #2c3e50;\\n            border-bottom: 2px solid #3498db;\\n            padding-bottom: 10px;\\n        }\\n        h2 {\\n            color: #3498db;\\n            margin-top: 30px;\\n        }\\n        h3 {\\n            color: #2980b9;\\n        }\\n        pre {\\n            background-color: #f8f9fa;\\n            border: 1px solid #ddd;\\n            border-radius: 4px;\\n            padding: 15px;\\n            overflow-x: auto;\\n            font-size: 14px;\\n        }\\n        code {\\n            font-family: Consolas, Monaco, \"Andale Mono\", monospace;\\n        }\\n        .section {\\n            margin-bottom: 40px;\\n        }\\n        table {\\n            border-collapse: collapse;\\n            width: 100%;\\n            margin: 20px 0;\\n        }\\n        th, td {\\n            border: 1px solid #ddd;\\n            padding: 8px 12px;\\n            text-align: left;\\n        }\\n        th {\\n            background-color: #f2f2f2;\\n        }\\n        .file-structure {\\n            margin-left: 20px;\\n        }\\n        .highlight {\\n            background-color: #ffffcc;\\n            padding: 2px;\\n        }\\n        .warning {\\n            color: #e74c3c;\\n        }\\n        .success {\\n            color: #27ae60;\\n        }\\n    </style>\\n</head>\\n<body>\\n    <h1>BSE Project Repository Analysis</h1>\\n    \\n    <div class=\"section\">\\n        <h2>Executive Summary</h2>\\n        <p>\\n            This report provides a comprehensive analysis of the BSEProject repository found at <code>/home/rishav/Documents/Code/6th-sense/Optqo_repo_function/repository/BSEProject</code>. \\n            The project is a sophisticated data processing and analysis system focused on Bombay Stock Exchange (BSE) financial data, \\n            with particular emphasis on detecting insider trading patterns, data standardization, and record deduplication.\\n        </p>\\n        <p>\\n            The system uses SAS (Statistical Analysis System) and SQL for data manipulation, standardization, \\n            and advanced statistical analysis. It includes components for parallel processing, data quality management, \\n            and automated report generation.\\n        </p>\\n    </div>')"
    }
  ]
}